{"ast":null,"code":"'use strict';\n\nconst bignumber = require('bignumber.js').BigNumber;\n\nconst utils = require('./utils');\n\nconst url = require('url');\n\nconst MINUS_ONE = new bignumber(-1);\nconst TWO = new bignumber(2);\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\n\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} [err] - the error that was thrown parsing the tag, or null\n   */\n  constructor(tag, value, err) {\n    this.tag = tag;\n    this.value = value;\n    this.err = err;\n\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + typeof this.tag + ')');\n    }\n\n    if (this.tag < 0 || (this.tag | 0) !== this.tag) {\n      throw new Error('Tag must be a positive integer: ' + this.tag);\n    }\n  }\n  /**\n   * Convert to a String\n   *\n   * @returns {string} string of the form '1(2)'\n   */\n\n\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`;\n  }\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {Object} gen The generator to push onto\n   */\n\n\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag);\n\n    return gen.pushAny(this.value);\n  }\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n\n\n  convert(converters) {\n    let f = converters != null ? converters[this.tag] : void 0;\n\n    if (typeof f !== 'function') {\n      f = Tagged['_tag_' + this.tag];\n\n      if (typeof f !== 'function') {\n        return this;\n      }\n    }\n\n    try {\n      return f.call(Tagged, this.value);\n    } catch (error) {\n      this.err = error;\n      return this;\n    }\n  }\n\n  static _tag_0(v) {\n    return new Date(v);\n  }\n\n  static _tag_1(v) {\n    return new Date(v * 1000);\n  }\n\n  static _tag_2(v) {\n    return utils.bufferToBignumber(v);\n  }\n\n  static _tag_3(v) {\n    return MINUS_ONE.minus(utils.bufferToBignumber(v));\n  }\n\n  static _tag_4(v) {\n    return bignumber(v[1]).shiftedBy(v[0]);\n  }\n\n  static _tag_5(v) {\n    return TWO.pow(v[0]).times(v[1]);\n  }\n\n  static _tag_32(v) {\n    return url.parse(v);\n  }\n\n  static _tag_35(v) {\n    return new RegExp(v);\n  }\n\n}\n\nmodule.exports = Tagged;","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/cbor/lib/tagged.js"],"names":["bignumber","require","BigNumber","utils","url","MINUS_ONE","TWO","Tagged","constructor","tag","value","err","Error","toString","JSON","stringify","encodeCBOR","gen","_pushTag","pushAny","convert","converters","f","call","error","_tag_0","v","Date","_tag_1","_tag_2","bufferToBignumber","_tag_3","minus","_tag_4","shiftedBy","_tag_5","pow","times","_tag_32","parse","_tag_35","RegExp","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst bignumber = require('bignumber.js').BigNumber\nconst utils = require('./utils')\nconst url = require('url')\n\nconst MINUS_ONE = new bignumber(-1)\nconst TWO = new bignumber(2)\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} [err] - the error that was thrown parsing the tag, or null\n   */\n  constructor(tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error('Tag must be a positive integer: ' + this.tag)\n    }\n  }\n\n  /**\n   * Convert to a String\n   *\n   * @returns {string} string of the form '1(2)'\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {Object} gen The generator to push onto\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n  convert(converters) {\n    let f = converters != null ? converters[this.tag] : void 0\n    if (typeof f !== 'function') {\n      f = Tagged['_tag_' + this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(Tagged, this.value)\n    } catch (error) {\n      this.err = error\n      return this\n    }\n  }\n\n  static _tag_0(v) {\n    return new Date(v)\n  }\n\n  static _tag_1(v) {\n    return new Date(v * 1000)\n  }\n\n  static _tag_2(v) {\n    return utils.bufferToBignumber(v)\n  }\n\n  static _tag_3(v) {\n    return MINUS_ONE.minus(utils.bufferToBignumber(v))\n  }\n\n  static _tag_4(v) {\n    return bignumber(v[1]).shiftedBy(v[0])\n  }\n\n  static _tag_5(v) {\n    return TWO.pow(v[0]).times(v[1])\n  }\n\n  static _tag_32(v) {\n    return url.parse(v)\n  }\n\n  static _tag_35(v) {\n    return new RegExp(v)\n  }\n}\n\nmodule.exports = Tagged\n"]},"metadata":{},"sourceType":"script"}