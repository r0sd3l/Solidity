{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEventAllocations = exports.getReturndataAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = exports.Utils = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:allocate\");\nexports.Utils = __importStar(require(\"./utils\"));\n\nconst Import = __importStar(require(\"../import\"));\n\nconst AbiDataUtils = __importStar(require(\"../utils\"));\n\nconst Web3Utils = require(\"web3-utils\"); //sorry for untyped import\n\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst Common = __importStar(require(\"../../common\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Ast = __importStar(require(\"../../ast\"));\n\nconst import_1 = require(\"../../contexts/import\");\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst lodash_partition_1 = __importDefault(require(\"lodash.partition\"));\n\nexports.FallbackOutputAllocation = {\n  kind: \"returnmessage\",\n  selector: new Uint8Array(),\n  allocationMode: \"full\"\n};\n\nfunction getAbiAllocations(userDefinedTypes) {\n  let allocations = {};\n\n  for (const dataType of Object.values(userDefinedTypes)) {\n    if (dataType.typeClass === \"struct\") {\n      try {\n        allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n      } catch (_) {//if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n        //note: a better way of handling this would probably be to *mark* it\n        //as failed rather than throwing an exception as that would lead to less\n        //recomputation, but this is simpler and I don't think the recomputation\n        //should really be a problem\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getAbiAllocations = getAbiAllocations;\n\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n} //note: we will still allocate circular structs, even though they're not allowed in the abi, because it's\n//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)\n\n\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations) {\n  let start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let dynamic = false; //note that we will mutate the start argument also!\n  //don't allocate things that have already been allocated\n\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n\n  let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n\n  let memberAllocations = [];\n\n  for (const member of members) {\n    let length;\n    let dynamicMember;\n    ({\n      size: length,\n      dynamic: dynamicMember,\n      allocations\n    } = abiSizeAndAllocate(member.type, userDefinedTypes, allocations)); //vomit on illegal types in calldata -- note the short-circuit!\n\n    if (length === undefined) {\n      allocations[parentId] = null;\n      return allocations;\n    }\n\n    let pointer = {\n      location: \"abi\",\n      start,\n      length\n    };\n    memberAllocations.push({\n      name: member.name,\n      type: member.type,\n      pointer\n    });\n    start += length;\n    dynamic = dynamic || dynamicMember;\n  }\n\n  allocations[parentId] = {\n    members: memberAllocations,\n    length: dynamic ? Evm.Utils.WORD_SIZE : start,\n    dynamic\n  };\n  return allocations;\n} //first return value is the actual size.\n//second return value is whether the type is dynamic\n//both will be undefined if type is a mapping or internal function\n//third return value is resulting allocations, INCLUDING the ones passed in\n\n\nfunction abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n  switch (dataType.typeClass) {\n    case \"bool\":\n    case \"address\":\n    case \"contract\":\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n    case \"enum\":\n    case \"userDefinedValueType\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: false,\n        allocations: existingAllocations\n      };\n\n    case \"string\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: true,\n        allocations: existingAllocations\n      };\n\n    case \"bytes\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: dataType.kind === \"dynamic\",\n        allocations: existingAllocations\n      };\n\n    case \"mapping\":\n      return {\n        allocations: existingAllocations\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            size: Evm.Utils.WORD_SIZE,\n            dynamic: false,\n            allocations: existingAllocations\n          };\n\n        case \"internal\":\n          return {\n            allocations: existingAllocations\n          };\n      }\n\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: Evm.Utils.WORD_SIZE,\n              dynamic: true,\n              allocations: existingAllocations\n            };\n\n          case \"static\":\n            if (dataType.length.isZero()) {\n              //arrays of length 0 are static regardless of base type\n              return {\n                size: 0,\n                dynamic: false,\n                allocations: existingAllocations\n              };\n            }\n\n            const {\n              size: baseSize,\n              dynamic,\n              allocations\n            } = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n            return {\n              //WARNING!  The use of toNumber() here may throw an exception!\n              //I'm judging this OK since if you have arrays that large we have bigger problems :P\n              size: dataType.length.toNumber() * baseSize,\n              dynamic,\n              allocations\n            };\n        }\n      }\n\n    case \"struct\":\n      {\n        let allocations = existingAllocations;\n        let allocation = allocations[dataType.id];\n\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          const storedType = userDefinedTypes[dataType.id];\n\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n\n          allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = allocations[storedType.id];\n        } //having found our allocation, if it's not null, we can just look up its size and dynamicity\n\n\n        if (allocation !== null) {\n          return {\n            size: allocation.length,\n            dynamic: allocation.dynamic,\n            allocations\n          };\n        } //if it is null, this type doesn't go in the abi\n        else {\n          return {\n            allocations\n          };\n        }\n      }\n\n    case \"tuple\":\n      {\n        //Warning! Yucky wasteful recomputation here!\n        let size = 0;\n        let dynamic = false; //note that we don't just invoke allocateStruct here!\n        //why not? because it has no ID to store the result in!\n        //and we can't use a fake like -1 because there might be a recursive call to it,\n        //and then the results would overwrite each other\n        //I mean, we could do some hashing thing or something, but I think it's easier to just\n        //copy the logic in this one case (sorry)\n\n        for (let member of dataType.memberTypes) {\n          let {\n            size: memberSize,\n            dynamic: memberDynamic\n          } = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations);\n          size += memberSize;\n          dynamic = dynamic || memberDynamic;\n        }\n\n        return {\n          size,\n          dynamic,\n          allocations: existingAllocations\n        };\n      }\n  }\n} //assumes you've already done allocation! don't use if you haven't!\n\n/**\n * @protected\n */\n\n\nfunction abiSizeInfo(dataType, allocations) {\n  let {\n    size,\n    dynamic\n  } = abiSizeAndAllocate(dataType, null, allocations); //the above line should work fine... as long as allocation is already done!\n  //the middle argument, userDefinedTypes, is only needed during allocation\n  //again, this function is only for use if allocation is done, so it's safe to pass null here\n\n  return {\n    size,\n    dynamic\n  };\n}\n\nexports.abiSizeInfo = abiSizeInfo; //allocates an external call\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n//NOTE: returns undefined if attempting to allocate a constructor but we don't have the\n//bytecode for the constructor\n\nfunction allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {\n  //first: determine the corresponding function node\n  //(simultaneously: determine the offset)\n  let node = undefined;\n  let inputParametersFull;\n  let outputParametersFull;\n  let inputParametersAbi;\n  let outputParametersAbi;\n  let offset; //refers to INPUT offset; output offset is always 0\n\n  debug(\"allocating calldata and returndata\");\n\n  switch (abiEntry.type) {\n    case \"constructor\":\n      if (!constructorContext) {\n        return undefined;\n      }\n\n      let rawLength = constructorContext.binary.length;\n      offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n      //for a constructor, we only want to search the particular contract\n\n      if (contractNode) {\n        node = contractNode.nodes.find(functionNode => AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a function node, but then it will\n        //return false (well, unless it's a getter node!)\n        abiEntry, functionNode, referenceDeclarations));\n      } //if we can't find it, we'll handle this below\n\n\n      break;\n\n    case \"function\":\n      offset = Evm.Utils.SELECTOR_SIZE; //search through base contracts, from most derived (left) to most base (right)\n\n      if (contractNode) {\n        const linearizedBaseContracts = contractNode.linearizedBaseContracts;\n        debug(\"linearized: %O\", linearizedBaseContracts);\n        node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, functionNode => AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations), contractNode).node; //may be undefined!  that's OK!\n\n        debug(\"found node: %o\", Boolean(node));\n      }\n\n      break;\n  } //now: get the parameters (both full-mode & ABI)\n\n\n  if (node) {\n    switch (node.nodeType) {\n      case \"FunctionDefinition\":\n        //normal case\n        inputParametersFull = node.parameters.parameters;\n        outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!\n\n        break;\n\n      case \"VariableDeclaration\":\n        //getter case\n        ({\n          inputs: inputParametersFull,\n          outputs: outputParametersFull\n        } = Ast.Utils.getterParameters(node, referenceDeclarations));\n        break;\n    }\n  } else {\n    inputParametersFull = undefined;\n    outputParametersFull = undefined;\n  }\n\n  inputParametersAbi = abiEntry.inputs;\n\n  switch (abiEntry.type) {\n    case \"function\":\n      outputParametersAbi = abiEntry.outputs;\n      break;\n\n    case \"constructor\":\n      //we just leave this empty for constructors\n      outputParametersAbi = [];\n      break;\n  } //now: do the allocation!\n\n\n  let {\n    allocation: abiAllocationInput,\n    mode: inputMode\n  } = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset);\n  let {\n    allocation: abiAllocationOutput,\n    mode: outputMode\n  } = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler //note no offset\n  );\n  debug(\"modes: %s in, %s out\", inputMode, outputMode); //finally: transform the allocation appropriately\n\n  let inputArgumentsAllocation = abiAllocationInput.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"calldata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  let outputArgumentsAllocation = abiAllocationOutput.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"returndata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  let inputsAllocation = {\n    abi: abiEntry,\n    offset,\n    arguments: inputArgumentsAllocation,\n    allocationMode: inputMode\n  };\n  let outputsAllocation;\n\n  switch (abiEntry.type) {\n    case \"function\":\n      outputsAllocation = {\n        selector: new Uint8Array(),\n        arguments: outputArgumentsAllocation,\n        allocationMode: outputMode,\n        kind: \"return\"\n      };\n      break;\n\n    case \"constructor\":\n      outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);\n      break;\n  }\n\n  return {\n    input: inputsAllocation,\n    output: outputsAllocation\n  }; //TS chokes on this for some reason\n} //note: allocateEvent doesn't use this because it needs additional\n//handling for indexed parameters (maybe these can be unified in\n//the future though?)\n\n\nfunction allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let allocationMode = fullModeParameters ? \"full\" : \"abi\"; //can degrade\n\n  let parameterTypes;\n  let abiAllocation;\n\n  if (allocationMode === \"full\") {\n    let id = \"-1\"; //fake ID that doesn't matter\n\n    parameterTypes = fullModeParameters.map(parameter => ({\n      name: parameter.name,\n      type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!\n\n    }));\n    debug(\"parameterTypes: %O\", parameterTypes); //now: perform the allocation!\n\n    try {\n      abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n    } catch (_a) {\n      //if something goes wrong, switch to ABI mdoe\n      debug(\"falling back to ABI due to exception!\");\n      allocationMode = \"abi\";\n    }\n  }\n\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    //this is the ABI case.  we end up here EITHER\n    //if node doesn't exist, OR if something went wrong\n    //during allocation\n    let id = \"-1\"; //fake irrelevant ID\n\n    parameterTypes = abiParameters.map(parameter => ({\n      name: parameter.name,\n      type: Import.abiParameterToType(parameter)\n    }));\n    abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n  }\n\n  return {\n    allocation: abiAllocation,\n    mode: allocationMode\n  };\n} //allocates an event\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n\n\nfunction allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let parameterTypes;\n  let nodeId;\n  let id; //first: determine the corresponding event node\n  //search through base contracts, from most derived (right) to most base (left)\n\n  let node = undefined;\n  let definedIn = undefined;\n  let allocationMode = \"full\"; //degrade to abi as needed\n\n  debug(\"allocating ABI: %O\", abiEntry);\n\n  if (contractNode) {\n    //first: check same contract for the event\n    node = contractNode.nodes.find(eventNode => AbiDataUtils.definitionMatchesAbi( //note this needn't actually be an event node, but then it will\n    //return false\n    abiEntry, eventNode, referenceDeclarations)); //if we found the node, great!  If not...\n\n    if (!node) {\n      debug(\"didn't find node in base contract...\"); //let's search for the node among the base contracts.\n      //but if we find it...\n      //[note: the following code is overcomplicated; it was used\n      //when we were trying to get the actual node, it's overcomplicated\n      //now that we're just determining its presence.  oh well]\n\n      let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n      linearizedBaseContractsMinusSelf.shift(); //remove self\n\n      debug(\"checking contracts: %o\", linearizedBaseContractsMinusSelf);\n      node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, eventNode => AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a event node, but then it will return false\n      abiEntry, eventNode, referenceDeclarations) //don't pass deriveContractNode here, we're not checking the contract itself\n      ).node; //may be undefined! that's OK!\n\n      if (node) {\n        //...if we find the node in an ancestor, we\n        //deliberately *don't* allocate!  instead such cases\n        //will be handled during a later combination step\n        debug(\"bailing out for later handling!\");\n        debug(\"ABI: %O\", abiEntry);\n        return undefined;\n      }\n    }\n  } //otherwise, leave node undefined\n\n\n  if (node) {\n    debug(\"found node\"); //if we found the node, let's also turn it into a type\n\n    definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler); //can skip reference declarations argument here\n    //...and set the ID\n\n    id = import_1.makeTypeId(node.id, compilationId);\n  } else {\n    //if no node, have to fall back into ABI mode\n    debug(\"falling back to ABI because no node\");\n    allocationMode = \"abi\";\n  } //now: construct the list of parameter types, attaching indexedness info\n  //and overall position (for later reconstruction)\n\n\n  let indexed;\n  let nonIndexed;\n  let abiAllocation; //the untransformed allocation for the non-indexed parameters\n\n  if (allocationMode === \"full\") {\n    nodeId = node.id.toString();\n    let parameters = node.parameters.parameters;\n    parameterTypes = parameters.map(definition => ({\n      //note: if node is defined, compiler had better be defined, too!\n      type: Ast.Import.definitionToType(definition, compilationId, compiler),\n      name: definition.name,\n      indexed: definition.indexed\n    })); //now: split the list of parameters into indexed and non-indexed\n\n    [indexed, nonIndexed] = lodash_partition_1.default(parameterTypes, parameter => parameter.indexed);\n\n    try {\n      //now: perform the allocation for the non-indexed parameters!\n      abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n    } catch (_a) {\n      allocationMode = \"abi\";\n    }\n  }\n\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    nodeId = \"-1\"; //fake irrelevant ID\n\n    parameterTypes = abiEntry.inputs.map(abiParameter => ({\n      type: Import.abiParameterToType(abiParameter),\n      name: abiParameter.name,\n      indexed: abiParameter.indexed\n    })); //now: split the list of parameters into indexed and non-indexed\n\n    [indexed, nonIndexed] = lodash_partition_1.default(parameterTypes, parameter => parameter.indexed); //now: perform the allocation for the non-indexed parameters!\n\n    abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n  } //now: transform the result appropriately\n\n\n  const nonIndexedArgumentsAllocation = abiAllocation.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"eventdata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  })); //now: allocate the indexed parameters\n\n  const startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0\n\n  const indexedArgumentsAllocation = indexed.map((_ref, position) => {\n    let {\n      type,\n      name\n    } = _ref;\n    return {\n      type,\n      name,\n      pointer: {\n        location: \"eventtopic\",\n        topic: startingTopic + position\n      }\n    };\n  }); //finally: weave these back together\n\n  let argumentsAllocation = [];\n\n  for (let parameter of parameterTypes) {\n    let arrayToGrabFrom = parameter.indexed ? indexedArgumentsAllocation : nonIndexedArgumentsAllocation;\n    argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n  } //...and return\n\n\n  return {\n    abi: abiEntry,\n    contextHash: undefined,\n    definedIn,\n    id,\n    arguments: argumentsAllocation,\n    allocationMode,\n    anonymous: abiEntry.anonymous\n  };\n}\n\nfunction allocateError(abiEntry, errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  //first: if we got passed just a node & no abi entry,\n  let id = undefined;\n  let definedIn = undefined;\n  let parametersFull = undefined;\n  const parametersAbi = abiEntry.inputs;\n\n  if (errorNode) {\n    //first, set parametersFull\n    parametersFull = errorNode.parameters.parameters; //now, set id\n\n    id = import_1.makeTypeId(errorNode.id, compilationId); //now, set definedIn\n\n    let contractNode = null;\n\n    for (const node of Object.values(referenceDeclarations)) {\n      if (node.nodeType === \"ContractDefinition\") {\n        if (node.nodes.some(subNode => subNode.id === errorNode.id)) {\n          contractNode = node;\n          break;\n        }\n      } //if we didn't find it, then contractNode is null\n      //(and thus so will be definedIn)\n\n    }\n\n    if (contractNode === null) {\n      definedIn = null;\n    } else {\n      definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler);\n    }\n  } //otherwise, leave parametersFull, id, and definedIn undefined\n\n\n  const {\n    allocation: abiAllocation,\n    mode: allocationMode\n  } = allocateDataArguments(parametersFull, parametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, Evm.Utils.SELECTOR_SIZE //errors use a 4-byte selector\n  ); //finally: transform the allocation appropriately\n\n  const argumentsAllocation = abiAllocation.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"returndata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  const selector = Conversion.toBytes(AbiDataUtils.abiSelector(abiEntry));\n  return {\n    kind: \"revert\",\n    selector,\n    abi: abiEntry,\n    id,\n    definedIn,\n    arguments: argumentsAllocation,\n    allocationMode\n  };\n}\n\nfunction getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let allocations = {\n    constructorAllocation: undefined,\n    //(if it doesn't then it will remain as default)\n    functionAllocations: {}\n  };\n\n  if (!abi) {\n    //if no ABI, can't do much!\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    return allocations;\n  }\n\n  for (let abiEntry of abi) {\n    if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) || AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {\n      //the first of these conditions is a hack workaround for a Solidity bug.\n      //the second of these is because... seriously? we're not handling these\n      //(at least not for now!) (these only exist prior to Solidity 0.5.6,\n      //thankfully)\n      continue;\n    }\n\n    switch (abiEntry.type) {\n      case \"constructor\":\n        allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n        debug(\"constructor alloc: %O\", allocations.constructorAllocation);\n        break;\n\n      case \"function\":\n        allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n        break;\n\n      default:\n        //skip over fallback, error, and event\n        break;\n    }\n  }\n\n  if (!allocations.constructorAllocation) {\n    //set a default constructor allocation if we haven't allocated one yet\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    debug(\"default constructor alloc: %O\", allocations.constructorAllocation);\n  }\n\n  return allocations;\n}\n\nfunction defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {\n  if (!constructorContext) {\n    return undefined;\n  }\n\n  const rawLength = constructorContext.binary.length;\n  const offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n\n  const input = {\n    offset,\n    abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,\n    arguments: [],\n    allocationMode: \"full\"\n  };\n  const output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, \"full\"); //assume full, degrade as necessary\n\n  return {\n    input,\n    output\n  };\n} //note: context should be deployed context!\n\n\nfunction constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {\n  if (!context) {\n    //just return a default abi mode result\n    return {\n      selector: new Uint8Array(),\n      allocationMode: \"abi\",\n      kind: \"bytecode\",\n      delegatecallGuard: false\n    };\n  }\n\n  const {\n    immutableReferences,\n    compilationId,\n    compiler,\n    contractKind,\n    binary\n  } = context;\n  let immutables;\n\n  if (allocationMode === \"full\" && immutableReferences) {\n    if (contractNode) {\n      debug(\"allocating immutables\");\n      immutables = [];\n\n      for (const [id, references] of Object.entries(immutableReferences)) {\n        if (references.length === 0) {\n          continue; //don't allocate immutables that don't exist\n        }\n\n        const astId = parseInt(id); //get the corresponding variable node; potentially fail\n\n        const {\n          node: definition,\n          contract: definedIn\n        } = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, node => node.id === astId, contractNode);\n\n        if (!definition || definition.nodeType !== \"VariableDeclaration\") {\n          debug(\"didn't find definition for %d!\", astId);\n          allocationMode = \"abi\";\n          immutables = undefined;\n          break;\n        }\n\n        const definedInClass = Ast.Import.definitionToStoredType(definedIn, compilationId, compiler); //can skip reference declarations argument here\n\n        const dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n        immutables.push({\n          name: definition.name,\n          definedIn: definedInClass,\n          type: dataType,\n          pointer: {\n            location: \"returndata\",\n            start: references[0].start,\n            length: references[0].length\n          }\n        });\n      }\n    } else if (Object.entries(immutableReferences).length > 0) {\n      //if there are immutables, but no contract mode, go to abi mode\n      debug(\"immutables but no node!\");\n      allocationMode = \"abi\";\n    }\n  } else {\n    debug(\"no immutables\");\n  } //now, is there a delegatecall guard?\n\n\n  let delegatecallGuard = false;\n\n  if (contractKind === \"library\") {\n    //note: I am relying on this being present!\n    //(also this part is a bit HACKy)\n    const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n\n    const delegateCallGuardString = \"0x\" + pushAddressInstruction + \"..\".repeat(Evm.Utils.ADDRESS_SIZE);\n\n    if (binary.startsWith(delegateCallGuardString)) {\n      delegatecallGuard = true;\n    }\n  }\n\n  return {\n    selector: new Uint8Array(),\n    allocationMode,\n    kind: \"bytecode\",\n    immutables,\n    delegatecallGuard\n  };\n}\n\nfunction getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allocations = {\n    constructorAllocations: {},\n    functionAllocations: {}\n  };\n\n  for (let contract of contracts) {\n    const contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n\n    if (contract.constructorContext) {\n      allocations.constructorAllocations[contract.constructorContext.context] = contractAllocations.constructorAllocation;\n    }\n\n    if (contract.deployedContext) {\n      allocations.functionAllocations[contract.deployedContext.context] = contractAllocations.functionAllocations; //set this up under both constructor *and* deployed! this is to handle\n      //constructor returndata decoding\n\n      allocations.constructorAllocations[contract.deployedContext.context] = contractAllocations.constructorAllocation;\n    }\n  }\n\n  return allocations;\n}\n\nexports.getCalldataAllocations = getCalldataAllocations;\n\nfunction getReturndataAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let useAst = Boolean(contractNode && contractNode.usedErrors);\n\n  if (useAst) {\n    const errorNodes = contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]);\n    let abis;\n\n    try {\n      abis = errorNodes.map(errorNode => Ast.Utils.definitionToAbi(errorNode, referenceDeclarations));\n    } catch (_a) {\n      useAst = false;\n    }\n\n    if (useAst) {\n      //i.e. if the above operation succeeded\n      return contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]).map((errorNode, index) => allocateError(abis[index], errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n    }\n  }\n\n  if (!useAst && abi) {\n    //deliberately *not* an else!\n    return abi.filter(abiEntry => abiEntry.type === \"error\").filter(abiEntry => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n    .map(abiEntry => allocateError(abiEntry, undefined, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n  } //otherwise just return nothing\n\n\n  return [];\n}\n\nfunction getReturndataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allContexts = [].concat(...contracts.map(_ref2 => {\n    let {\n      deployedContext,\n      constructorContext\n    } = _ref2;\n    return [deployedContext, constructorContext];\n  })).filter(x => x) //filter out nonexistent contexts\n  .map(context => context.context);\n  allContexts.push(\"\"); //HACK: add fictional empty-string context to represent no-context\n  //holds allocations for a given context\n\n  let selfAllocations = {}; //holds allocations for *other* contexts\n\n  let additionalAllocations = {}; //now: process the allocations for each contract. we'll add each contract's\n  //allocations to *its* entries in allocations, and to every *other* entry\n  //in additionalAllocations.\n\n  for (const contract of contracts) {\n    const contractAllocations = getReturndataAllocationsForContract(contract.abi, contract.contractNode, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n    const contexts = [//contexts for this contract\n    contract.deployedContext, contract.constructorContext].filter(x => x) //filter out nonexistent contexts\n    .map(context => context.context);\n    const otherContexts = allContexts.filter( //contexts for all other contracts\n    contextHash => !contexts.includes(contextHash)); //add them to selfAllocations\n\n    for (const contextHash of contexts) {\n      selfAllocations[contextHash] = contractAllocations;\n    } //add them to additionalAllocations\n\n\n    for (const contextHash of otherContexts) {\n      if (additionalAllocations[contextHash] === undefined) {\n        additionalAllocations[contextHash] = [];\n      }\n\n      additionalAllocations[contextHash] = additionalAllocations[contextHash].concat(contractAllocations);\n    }\n  }\n\n  let allocations = Object.assign({}, ...allContexts.map(contextHash => ({\n    [contextHash]: {}\n  }))); //now: perform coalescense!\n\n  for (const contract of contracts) {\n    //we're setting up contexts again, sorry >_>\n    const contexts = [//contexts for this contract\n    contract.deployedContext, contract.constructorContext].filter(x => x) //filter out nonexistent contexts\n    .map(context => context.context);\n\n    for (const contextHash of contexts) {\n      allocations[contextHash] = coalesceReturndataAllocations(selfAllocations[contextHash] || [], additionalAllocations[contextHash] || []);\n      debug(\"allocations: %O\", allocations[contextHash]);\n    }\n  } //...also coalesce the fake \"\" context\n\n\n  allocations[\"\"] = coalesceReturndataAllocations([], additionalAllocations[\"\"] || []);\n  /*\n  for (const [contextHash, contextAllocations] of Object.entries(allAllocations)) {\n    for (const [signature, signatureAllocations] of Object.entries(contextAllocations)) {\n      const selector = Web3Utils.soliditySha3({ type: \"string\", value: signature })\n        .slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n      if (!allocations[contextHash][selector]) {\n        allocations[contextHash][selector] = [];\n      }\n      allocations[contextHash][selector] = allocations[contextHash][selector].concat(signatureAllocations);\n    }\n  }\n  */\n\n  debug(\"error allocations: %O\", allocations);\n  return allocations;\n}\n\nexports.getReturndataAllocations = getReturndataAllocations;\n\nfunction coalesceReturndataAllocations(selfAllocations, additionalAllocations) {\n  let bySelector = {}; //start with the additional allocations; we want to process\n  //the self allocations last, due to special handling of no-ID allocations there\n\n  for (const allocation of additionalAllocations) {\n    const signature = AbiDataUtils.abiSignature(allocation.abi);\n    const selector = Web3Utils.soliditySha3({\n      type: \"string\",\n      value: signature\n    }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n\n    if (bySelector[selector]) {\n      //note: at this point, for any given signature, there should only be a\n      //no-ID allocation for that signature if it's the only one\n      if (allocation.id !== undefined) {\n        //delete anything with that signature but w/o an ID, or with this same ID\n        bySelector[selector] = bySelector[selector].filter(_ref3 => {\n          let {\n            abi,\n            id\n          } = _ref3;\n          return !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id));\n        }); //add this allocation\n\n        bySelector[selector].push(allocation);\n      } else if (!bySelector[selector].some(_ref4 => {\n        let {\n          abi\n        } = _ref4;\n        return AbiDataUtils.abiSignature(abi) === signature;\n      })) {\n        //only add ID-less ones if there isn't anything of that signature already\n        bySelector[selector].push(allocation);\n      }\n    } else {\n      //if there's nothing there thus far, add it\n      bySelector[selector] = [allocation];\n    }\n  } //now we're going to perform a modified version of this procedure for the self allocations:\n  //1. we're going to add to the front, not the back\n  //2. we can add an ID-less one even if there are already ones with IDs there\n  //(sorry for the copypaste)\n\n\n  for (const allocation of selfAllocations) {\n    const signature = AbiDataUtils.abiSignature(allocation.abi);\n    const selector = Web3Utils.soliditySha3({\n      type: \"string\",\n      value: signature\n    }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n\n    if (bySelector[selector]) {\n      //delete anything with that signature but w/o an ID, or with this same ID\n      //(if this alloc has no ID, this will only delete ID-less ones :) )\n      bySelector[selector] = bySelector[selector].filter(_ref5 => {\n        let {\n          abi,\n          id\n        } = _ref5;\n        return !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id));\n      }); //add this allocation to front, not back!\n\n      bySelector[selector].unshift(allocation);\n    } else {\n      //if there's nothing there thus far, add it\n      bySelector[selector] = [allocation];\n    }\n  }\n\n  return bySelector;\n}\n\nfunction getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  return abi.filter(abiEntry => abiEntry.type === \"event\").filter(abiEntry => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n  .map(abiEntry => ({\n    selector: AbiDataUtils.abiSelector(abiEntry),\n    anonymous: abiEntry.anonymous,\n    topics: AbiDataUtils.topicsCount(abiEntry),\n    allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)\n  })); //note we do *not* filter out undefined allocations; we need these as placeholders\n} //note: constructor context is ignored by this function; no need to pass it in\n//WARNING: this function is full of hacks... sorry\n\n\nfunction getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  //first: do allocations for individual contracts\n  let individualAllocations = {};\n  let groupedAllocations = {};\n  let allocations = {};\n\n  for (let {\n    abi,\n    deployedContext,\n    contractNode,\n    compilationId,\n    compiler\n  } of contracts) {\n    if (!deployedContext && !contractNode) {\n      //we'll need *one* of these two at least\n      continue;\n    }\n\n    let contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);\n    let key = makeContractKey(deployedContext, contractNode ? contractNode.id : undefined, compilationId);\n\n    if (individualAllocations[key] === undefined) {\n      individualAllocations[key] = {};\n    }\n\n    for (let allocationTemporary of contractAllocations) {\n      //we'll use selector *even for anonymous* here, because it's just\n      //for determining what overrides what at this point\n      individualAllocations[key][allocationTemporary.selector] = {\n        context: deployedContext,\n        contractNode,\n        allocationTemporary,\n        compilationId\n      };\n    }\n  } //now: put things together for inheritance\n  //note how we always put things in order from most derived to most base\n\n\n  for (let contextOrId in individualAllocations) {\n    groupedAllocations[contextOrId] = {};\n\n    for (let selector in individualAllocations[contextOrId]) {\n      let {\n        context,\n        contractNode,\n        allocationTemporary,\n        compilationId\n      } = individualAllocations[contextOrId][selector];\n      debug(\"allocationTemporary: %O\", allocationTemporary);\n      let allocationsTemporary = allocationTemporary.allocation ? [allocationTemporary] : []; //filter out undefined allocations\n      //first, copy from individual allocations\n\n      groupedAllocations[contextOrId][selector] = {\n        context,\n        contractNode,\n        allocationsTemporary\n      }; //if no contract node, that's all.  if there is...\n\n      if (contractNode) {\n        //...we have to do inheritance processing\n        debug(\"contract Id: %d\", contractNode.id);\n        debug(\"base contracts: %o\", contractNode.linearizedBaseContracts);\n        let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n        linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors\n\n        for (let baseId of linearizedBaseContractsMinusSelf) {\n          debug(\"checking baseId: %d\", baseId);\n          let baseNode = referenceDeclarations[compilationId][baseId];\n\n          if (!baseNode || baseNode.nodeType !== \"ContractDefinition\") {\n            debug(\"failed to find node for baseId: %d\", baseId);\n            break; //not a continue!\n            //if we can't find the base node, it's better to stop the loop,\n            //rather than continue to potentially erroneous things\n          } //note: we're not actually going to *use* the baseNode here.\n          //we're just checking for whether we can *find* it\n          //why? because if we couldn't find it, that means that events defined in\n          //base contracts *weren't* skipped earlier, and so we shouldn't now add them in\n\n\n          let baseContractInfo = contracts.find(contractAllocationInfo => contractAllocationInfo.compilationId === compilationId && contractAllocationInfo.contractNode && contractAllocationInfo.contractNode.id === baseId);\n\n          if (!baseContractInfo) {\n            //similar to above... this failure case can happen when there are\n            //two contracts with the same name and you attempt to use the\n            //artifacts; say you have contracts A, B, and B', where A inherits\n            //from B, and B and B' have the same name, and B' is the one that\n            //gets the artifact; B will end up in reference declarations and so\n            //get found above, but it won't appear in contracts, causing the\n            //problem here.  Unfortunately I don't know any great way to handle this,\n            //so, uh, we treat it as a failure same as above.\n            debug(\"failed to find contract info for baseId: %d\", baseId);\n            break;\n          }\n\n          let baseContext = baseContractInfo.deployedContext;\n          let baseKey = makeContractKey(baseContext, baseId, compilationId);\n\n          if (individualAllocations[baseKey][selector] !== undefined) {\n            let baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;\n            debug(\"(probably) pushing inherited alloc from baseId: %d\", baseId);\n\n            if (baseAllocation.allocation) {\n              //don't push undefined!\n              groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);\n            }\n          }\n        }\n      }\n    }\n  } //finally: transform into final form & return,\n  //filtering out things w/o a context\n\n\n  for (let contractKey in groupedAllocations) {\n    if (!hasContext(contractKey)) {\n      continue; //(this filters out ones that had no context and therefore were\n      //given by ID; we needed these at the previous stage but from\n      //here on they're irrelevant)\n    }\n\n    let contextHash = contextHashForKey(contractKey);\n\n    for (let selector in groupedAllocations[contextHash]) {\n      let {\n        allocationsTemporary,\n        context\n      } = groupedAllocations[contextHash][selector];\n\n      for (let {\n        anonymous,\n        topics,\n        allocation\n      } of allocationsTemporary) {\n        let contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK\n\n        if (contractKind !== \"library\") {\n          contractKind = \"contract\"; //round off interfaces to being contracts for our purposes :P\n        }\n\n        allocation = Object.assign(Object.assign({}, allocation), {\n          contextHash\n        }); //the allocation's context hash at this point depends on where it was defined, but\n        //that's not what we want going in the final allocation table!\n\n        if (allocations[topics] === undefined) {\n          allocations[topics] = {\n            bySelector: {},\n            anonymous: {\n              contract: {},\n              library: {}\n            }\n          };\n        }\n\n        if (!anonymous) {\n          if (allocations[topics].bySelector[selector] === undefined) {\n            allocations[topics].bySelector[selector] = {\n              contract: {},\n              library: {}\n            };\n          }\n\n          if (allocations[topics].bySelector[selector][contractKind][contextHash] === undefined) {\n            allocations[topics].bySelector[selector][contractKind][contextHash] = [];\n          }\n\n          allocations[topics].bySelector[selector][contractKind][contextHash].push(allocation);\n        } else {\n          if (allocations[topics].anonymous[contractKind][contextHash] === undefined) {\n            allocations[topics].anonymous[contractKind][contextHash] = [];\n          }\n\n          allocations[topics].anonymous[contractKind][contextHash].push(allocation);\n        }\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getEventAllocations = getEventAllocations; //if derivedContractNode is passed, we check that before referenceDeclarations\n\nfunction findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {\n  const searchResult = linearizedBaseContracts.reduce((foundNodeAndContract, baseContractId) => {\n    if (foundNodeAndContract !== undefined) {\n      return foundNodeAndContract; //once we've found something, we don't need to keep looking\n    }\n\n    debug(\"searching contract %d\", baseContractId);\n    let baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision\n    : referenceDeclarations[baseContractId];\n\n    if (baseContractNode === undefined || baseContractNode.nodeType !== \"ContractDefinition\") {\n      debug(\"bad contract node!\");\n      return null; //return null rather than undefined so that this will propagate through\n      //(i.e. by returning null here we give up the search)\n      //(we don't want to continue due to possibility of grabbing the wrong override)\n    }\n\n    const node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!\n\n    if (node) {\n      debug(\"found node: %o\", node);\n      return {\n        node,\n        contract: baseContractNode\n      };\n    } else {\n      return undefined;\n    }\n  }, undefined //start with no node found\n  );\n  return searchResult || {\n    node: undefined,\n    contract: undefined\n  };\n}\n\nfunction makeContractKey(context, id, compilationId) {\n  return context ? context.context : id + \":\" + compilationId; //HACK!\n}\n\nfunction hasContext(key) {\n  return key.startsWith(\"0x\"); //HACK!\n}\n\nfunction contextHashForKey(key) {\n  return hasContext(key) ? key //HACK!\n  : undefined;\n}","map":{"version":3,"sources":["../../../../lib/abi-data/allocate/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getEventAllocations = exports.getReturndataAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = exports.Utils = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:abi-data:allocate\");\nexports.Utils = __importStar(require(\"./utils\"));\nconst Import = __importStar(require(\"../import\"));\nconst AbiDataUtils = __importStar(require(\"../utils\"));\nconst Web3Utils = require(\"web3-utils\"); //sorry for untyped import\nconst Evm = __importStar(require(\"../../evm\"));\nconst Common = __importStar(require(\"../../common\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Ast = __importStar(require(\"../../ast\"));\nconst import_1 = require(\"../../contexts/import\");\nconst Format = __importStar(require(\"../../format\"));\nconst lodash_partition_1 = __importDefault(require(\"lodash.partition\"));\nexports.FallbackOutputAllocation = {\n    kind: \"returnmessage\",\n    selector: new Uint8Array(),\n    allocationMode: \"full\"\n};\nfunction getAbiAllocations(userDefinedTypes) {\n    let allocations = {};\n    for (const dataType of Object.values(userDefinedTypes)) {\n        if (dataType.typeClass === \"struct\") {\n            try {\n                allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n            }\n            catch (_) {\n                //if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n                //note: a better way of handling this would probably be to *mark* it\n                //as failed rather than throwing an exception as that would lead to less\n                //recomputation, but this is simpler and I don't think the recomputation\n                //should really be a problem\n            }\n        }\n    }\n    return allocations;\n}\nexports.getAbiAllocations = getAbiAllocations;\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n    //NOTE: dataType here should be a *stored* type!\n    //it is up to the caller to take care of this\n    return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n}\n//note: we will still allocate circular structs, even though they're not allowed in the abi, because it's\n//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations, start = 0) {\n    let dynamic = false;\n    //note that we will mutate the start argument also!\n    //don't allocate things that have already been allocated\n    if (parentId in existingAllocations) {\n        return existingAllocations;\n    }\n    let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n    let memberAllocations = [];\n    for (const member of members) {\n        let length;\n        let dynamicMember;\n        ({\n            size: length,\n            dynamic: dynamicMember,\n            allocations\n        } = abiSizeAndAllocate(member.type, userDefinedTypes, allocations));\n        //vomit on illegal types in calldata -- note the short-circuit!\n        if (length === undefined) {\n            allocations[parentId] = null;\n            return allocations;\n        }\n        let pointer = {\n            location: \"abi\",\n            start,\n            length\n        };\n        memberAllocations.push({\n            name: member.name,\n            type: member.type,\n            pointer\n        });\n        start += length;\n        dynamic = dynamic || dynamicMember;\n    }\n    allocations[parentId] = {\n        members: memberAllocations,\n        length: dynamic ? Evm.Utils.WORD_SIZE : start,\n        dynamic\n    };\n    return allocations;\n}\n//first return value is the actual size.\n//second return value is whether the type is dynamic\n//both will be undefined if type is a mapping or internal function\n//third return value is resulting allocations, INCLUDING the ones passed in\nfunction abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n    switch (dataType.typeClass) {\n        case \"bool\":\n        case \"address\":\n        case \"contract\":\n        case \"int\":\n        case \"uint\":\n        case \"fixed\":\n        case \"ufixed\":\n        case \"enum\":\n        case \"userDefinedValueType\":\n            return {\n                size: Evm.Utils.WORD_SIZE,\n                dynamic: false,\n                allocations: existingAllocations\n            };\n        case \"string\":\n            return {\n                size: Evm.Utils.WORD_SIZE,\n                dynamic: true,\n                allocations: existingAllocations\n            };\n        case \"bytes\":\n            return {\n                size: Evm.Utils.WORD_SIZE,\n                dynamic: dataType.kind === \"dynamic\",\n                allocations: existingAllocations\n            };\n        case \"mapping\":\n            return {\n                allocations: existingAllocations\n            };\n        case \"function\":\n            switch (dataType.visibility) {\n                case \"external\":\n                    return {\n                        size: Evm.Utils.WORD_SIZE,\n                        dynamic: false,\n                        allocations: existingAllocations\n                    };\n                case \"internal\":\n                    return {\n                        allocations: existingAllocations\n                    };\n            }\n        case \"array\": {\n            switch (dataType.kind) {\n                case \"dynamic\":\n                    return {\n                        size: Evm.Utils.WORD_SIZE,\n                        dynamic: true,\n                        allocations: existingAllocations\n                    };\n                case \"static\":\n                    if (dataType.length.isZero()) {\n                        //arrays of length 0 are static regardless of base type\n                        return {\n                            size: 0,\n                            dynamic: false,\n                            allocations: existingAllocations\n                        };\n                    }\n                    const { size: baseSize, dynamic, allocations } = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n                    return {\n                        //WARNING!  The use of toNumber() here may throw an exception!\n                        //I'm judging this OK since if you have arrays that large we have bigger problems :P\n                        size: dataType.length.toNumber() * baseSize,\n                        dynamic,\n                        allocations\n                    };\n            }\n        }\n        case \"struct\": {\n            let allocations = existingAllocations;\n            let allocation = allocations[dataType.id];\n            if (allocation === undefined) {\n                //if we don't find an allocation, we'll have to do the allocation ourselves\n                const storedType = (userDefinedTypes[dataType.id]);\n                if (!storedType) {\n                    throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n                }\n                allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n                allocation = allocations[storedType.id];\n            }\n            //having found our allocation, if it's not null, we can just look up its size and dynamicity\n            if (allocation !== null) {\n                return {\n                    size: allocation.length,\n                    dynamic: allocation.dynamic,\n                    allocations\n                };\n            }\n            //if it is null, this type doesn't go in the abi\n            else {\n                return {\n                    allocations\n                };\n            }\n        }\n        case \"tuple\": {\n            //Warning! Yucky wasteful recomputation here!\n            let size = 0;\n            let dynamic = false;\n            //note that we don't just invoke allocateStruct here!\n            //why not? because it has no ID to store the result in!\n            //and we can't use a fake like -1 because there might be a recursive call to it,\n            //and then the results would overwrite each other\n            //I mean, we could do some hashing thing or something, but I think it's easier to just\n            //copy the logic in this one case (sorry)\n            for (let member of dataType.memberTypes) {\n                let { size: memberSize, dynamic: memberDynamic } = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations);\n                size += memberSize;\n                dynamic = dynamic || memberDynamic;\n            }\n            return { size, dynamic, allocations: existingAllocations };\n        }\n    }\n}\n//assumes you've already done allocation! don't use if you haven't!\n/**\n * @protected\n */\nfunction abiSizeInfo(dataType, allocations) {\n    let { size, dynamic } = abiSizeAndAllocate(dataType, null, allocations);\n    //the above line should work fine... as long as allocation is already done!\n    //the middle argument, userDefinedTypes, is only needed during allocation\n    //again, this function is only for use if allocation is done, so it's safe to pass null here\n    return { size, dynamic };\n}\nexports.abiSizeInfo = abiSizeInfo;\n//allocates an external call\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n//NOTE: returns undefined if attempting to allocate a constructor but we don't have the\n//bytecode for the constructor\nfunction allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {\n    //first: determine the corresponding function node\n    //(simultaneously: determine the offset)\n    let node = undefined;\n    let inputParametersFull;\n    let outputParametersFull;\n    let inputParametersAbi;\n    let outputParametersAbi;\n    let offset; //refers to INPUT offset; output offset is always 0\n    debug(\"allocating calldata and returndata\");\n    switch (abiEntry.type) {\n        case \"constructor\":\n            if (!constructorContext) {\n                return undefined;\n            }\n            let rawLength = constructorContext.binary.length;\n            offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n            //for a constructor, we only want to search the particular contract\n            if (contractNode) {\n                node = contractNode.nodes.find(functionNode => AbiDataUtils.definitionMatchesAbi(\n                //note this needn't actually be a function node, but then it will\n                //return false (well, unless it's a getter node!)\n                abiEntry, functionNode, referenceDeclarations));\n            }\n            //if we can't find it, we'll handle this below\n            break;\n        case \"function\":\n            offset = Evm.Utils.SELECTOR_SIZE;\n            //search through base contracts, from most derived (left) to most base (right)\n            if (contractNode) {\n                const linearizedBaseContracts = contractNode.linearizedBaseContracts;\n                debug(\"linearized: %O\", linearizedBaseContracts);\n                node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, functionNode => AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations), contractNode).node; //may be undefined!  that's OK!\n                debug(\"found node: %o\", Boolean(node));\n            }\n            break;\n    }\n    //now: get the parameters (both full-mode & ABI)\n    if (node) {\n        switch (node.nodeType) {\n            case \"FunctionDefinition\":\n                //normal case\n                inputParametersFull = node.parameters.parameters;\n                outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!\n                break;\n            case \"VariableDeclaration\":\n                //getter case\n                ({ inputs: inputParametersFull, outputs: outputParametersFull } =\n                    Ast.Utils.getterParameters(node, referenceDeclarations));\n                break;\n        }\n    }\n    else {\n        inputParametersFull = undefined;\n        outputParametersFull = undefined;\n    }\n    inputParametersAbi = abiEntry.inputs;\n    switch (abiEntry.type) {\n        case \"function\":\n            outputParametersAbi = abiEntry.outputs;\n            break;\n        case \"constructor\":\n            //we just leave this empty for constructors\n            outputParametersAbi = [];\n            break;\n    }\n    //now: do the allocation!\n    let { allocation: abiAllocationInput, mode: inputMode } = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset);\n    let { allocation: abiAllocationOutput, mode: outputMode } = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler\n    //note no offset\n    );\n    debug(\"modes: %s in, %s out\", inputMode, outputMode);\n    //finally: transform the allocation appropriately\n    let inputArgumentsAllocation = abiAllocationInput.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {\n            location: \"calldata\",\n            start: member.pointer.start,\n            length: member.pointer.length\n        } })));\n    let outputArgumentsAllocation = abiAllocationOutput.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {\n            location: \"returndata\",\n            start: member.pointer.start,\n            length: member.pointer.length\n        } })));\n    let inputsAllocation = {\n        abi: abiEntry,\n        offset,\n        arguments: inputArgumentsAllocation,\n        allocationMode: inputMode\n    };\n    let outputsAllocation;\n    switch (abiEntry.type) {\n        case \"function\":\n            outputsAllocation = {\n                selector: new Uint8Array(),\n                arguments: outputArgumentsAllocation,\n                allocationMode: outputMode,\n                kind: \"return\"\n            };\n            break;\n        case \"constructor\":\n            outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);\n            break;\n    }\n    return {\n        input: inputsAllocation,\n        output: outputsAllocation\n    }; //TS chokes on this for some reason\n}\n//note: allocateEvent doesn't use this because it needs additional\n//handling for indexed parameters (maybe these can be unified in\n//the future though?)\nfunction allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler, offset = 0) {\n    let allocationMode = fullModeParameters ? \"full\" : \"abi\"; //can degrade\n    let parameterTypes;\n    let abiAllocation;\n    if (allocationMode === \"full\") {\n        let id = \"-1\"; //fake ID that doesn't matter\n        parameterTypes = fullModeParameters.map(parameter => ({\n            name: parameter.name,\n            type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!\n        }));\n        debug(\"parameterTypes: %O\", parameterTypes);\n        //now: perform the allocation!\n        try {\n            abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n        }\n        catch (_a) {\n            //if something goes wrong, switch to ABI mdoe\n            debug(\"falling back to ABI due to exception!\");\n            allocationMode = \"abi\";\n        }\n    }\n    if (allocationMode === \"abi\") {\n        //THIS IS DELIBERATELY NOT AN ELSE\n        //this is the ABI case.  we end up here EITHER\n        //if node doesn't exist, OR if something went wrong\n        //during allocation\n        let id = \"-1\"; //fake irrelevant ID\n        parameterTypes = abiParameters.map(parameter => ({\n            name: parameter.name,\n            type: Import.abiParameterToType(parameter)\n        }));\n        abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n    }\n    return { allocation: abiAllocation, mode: allocationMode };\n}\n//allocates an event\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\nfunction allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n    let parameterTypes;\n    let nodeId;\n    let id;\n    //first: determine the corresponding event node\n    //search through base contracts, from most derived (right) to most base (left)\n    let node = undefined;\n    let definedIn = undefined;\n    let allocationMode = \"full\"; //degrade to abi as needed\n    debug(\"allocating ABI: %O\", abiEntry);\n    if (contractNode) {\n        //first: check same contract for the event\n        node = contractNode.nodes.find(eventNode => AbiDataUtils.definitionMatchesAbi(\n        //note this needn't actually be an event node, but then it will\n        //return false\n        abiEntry, eventNode, referenceDeclarations));\n        //if we found the node, great!  If not...\n        if (!node) {\n            debug(\"didn't find node in base contract...\");\n            //let's search for the node among the base contracts.\n            //but if we find it...\n            //[note: the following code is overcomplicated; it was used\n            //when we were trying to get the actual node, it's overcomplicated\n            //now that we're just determining its presence.  oh well]\n            let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n            linearizedBaseContractsMinusSelf.shift(); //remove self\n            debug(\"checking contracts: %o\", linearizedBaseContractsMinusSelf);\n            node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, eventNode => AbiDataUtils.definitionMatchesAbi(\n            //note this needn't actually be a event node, but then it will return false\n            abiEntry, eventNode, referenceDeclarations)\n            //don't pass deriveContractNode here, we're not checking the contract itself\n            ).node; //may be undefined! that's OK!\n            if (node) {\n                //...if we find the node in an ancestor, we\n                //deliberately *don't* allocate!  instead such cases\n                //will be handled during a later combination step\n                debug(\"bailing out for later handling!\");\n                debug(\"ABI: %O\", abiEntry);\n                return undefined;\n            }\n        }\n    }\n    //otherwise, leave node undefined\n    if (node) {\n        debug(\"found node\");\n        //if we found the node, let's also turn it into a type\n        definedIn = (Ast.Import.definitionToStoredType(contractNode, compilationId, compiler)); //can skip reference declarations argument here\n        //...and set the ID\n        id = import_1.makeTypeId(node.id, compilationId);\n    }\n    else {\n        //if no node, have to fall back into ABI mode\n        debug(\"falling back to ABI because no node\");\n        allocationMode = \"abi\";\n    }\n    //now: construct the list of parameter types, attaching indexedness info\n    //and overall position (for later reconstruction)\n    let indexed;\n    let nonIndexed;\n    let abiAllocation; //the untransformed allocation for the non-indexed parameters\n    if (allocationMode === \"full\") {\n        nodeId = node.id.toString();\n        let parameters = node.parameters.parameters;\n        parameterTypes = parameters.map(definition => ({\n            //note: if node is defined, compiler had better be defined, too!\n            type: Ast.Import.definitionToType(definition, compilationId, compiler),\n            name: definition.name,\n            indexed: definition.indexed\n        }));\n        //now: split the list of parameters into indexed and non-indexed\n        [indexed, nonIndexed] = lodash_partition_1.default(parameterTypes, (parameter) => parameter.indexed);\n        try {\n            //now: perform the allocation for the non-indexed parameters!\n            abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n        }\n        catch (_a) {\n            allocationMode = \"abi\";\n        }\n    }\n    if (allocationMode === \"abi\") {\n        //THIS IS DELIBERATELY NOT AN ELSE\n        nodeId = \"-1\"; //fake irrelevant ID\n        parameterTypes = abiEntry.inputs.map(abiParameter => ({\n            type: Import.abiParameterToType(abiParameter),\n            name: abiParameter.name,\n            indexed: abiParameter.indexed\n        }));\n        //now: split the list of parameters into indexed and non-indexed\n        [indexed, nonIndexed] = lodash_partition_1.default(parameterTypes, (parameter) => parameter.indexed);\n        //now: perform the allocation for the non-indexed parameters!\n        abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n    }\n    //now: transform the result appropriately\n    const nonIndexedArgumentsAllocation = abiAllocation.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {\n            location: \"eventdata\",\n            start: member.pointer.start,\n            length: member.pointer.length\n        } })));\n    //now: allocate the indexed parameters\n    const startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0\n    const indexedArgumentsAllocation = indexed.map(({ type, name }, position) => ({\n        type,\n        name,\n        pointer: {\n            location: \"eventtopic\",\n            topic: startingTopic + position\n        }\n    }));\n    //finally: weave these back together\n    let argumentsAllocation = [];\n    for (let parameter of parameterTypes) {\n        let arrayToGrabFrom = parameter.indexed\n            ? indexedArgumentsAllocation\n            : nonIndexedArgumentsAllocation;\n        argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n    }\n    //...and return\n    return {\n        abi: abiEntry,\n        contextHash: undefined,\n        definedIn,\n        id,\n        arguments: argumentsAllocation,\n        allocationMode,\n        anonymous: abiEntry.anonymous\n    };\n}\nfunction allocateError(abiEntry, errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n    //first: if we got passed just a node & no abi entry,\n    let id = undefined;\n    let definedIn = undefined;\n    let parametersFull = undefined;\n    const parametersAbi = abiEntry.inputs;\n    if (errorNode) {\n        //first, set parametersFull\n        parametersFull = errorNode.parameters.parameters;\n        //now, set id\n        id = import_1.makeTypeId(errorNode.id, compilationId);\n        //now, set definedIn\n        let contractNode = null;\n        for (const node of Object.values(referenceDeclarations)) {\n            if (node.nodeType === \"ContractDefinition\") {\n                if (node.nodes.some((subNode) => subNode.id === errorNode.id)) {\n                    contractNode = node;\n                    break;\n                }\n            }\n            //if we didn't find it, then contractNode is null\n            //(and thus so will be definedIn)\n        }\n        if (contractNode === null) {\n            definedIn = null;\n        }\n        else {\n            definedIn = (Ast.Import.definitionToStoredType(contractNode, compilationId, compiler));\n        }\n    }\n    //otherwise, leave parametersFull, id, and definedIn undefined\n    const { allocation: abiAllocation, mode: allocationMode } = allocateDataArguments(parametersFull, parametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, Evm.Utils.SELECTOR_SIZE //errors use a 4-byte selector\n    );\n    //finally: transform the allocation appropriately\n    const argumentsAllocation = abiAllocation.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {\n            location: \"returndata\",\n            start: member.pointer.start,\n            length: member.pointer.length\n        } })));\n    const selector = Conversion.toBytes(AbiDataUtils.abiSelector(abiEntry));\n    return {\n        kind: \"revert\",\n        selector,\n        abi: abiEntry,\n        id,\n        definedIn,\n        arguments: argumentsAllocation,\n        allocationMode\n    };\n}\nfunction getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n    let allocations = {\n        constructorAllocation: undefined,\n        //(if it doesn't then it will remain as default)\n        functionAllocations: {}\n    };\n    if (!abi) {\n        //if no ABI, can't do much!\n        allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n        return allocations;\n    }\n    for (let abiEntry of abi) {\n        if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) ||\n            AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {\n            //the first of these conditions is a hack workaround for a Solidity bug.\n            //the second of these is because... seriously? we're not handling these\n            //(at least not for now!) (these only exist prior to Solidity 0.5.6,\n            //thankfully)\n            continue;\n        }\n        switch (abiEntry.type) {\n            case \"constructor\":\n                allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n                debug(\"constructor alloc: %O\", allocations.constructorAllocation);\n                break;\n            case \"function\":\n                allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n                break;\n            default:\n                //skip over fallback, error, and event\n                break;\n        }\n    }\n    if (!allocations.constructorAllocation) {\n        //set a default constructor allocation if we haven't allocated one yet\n        allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n        debug(\"default constructor alloc: %O\", allocations.constructorAllocation);\n    }\n    return allocations;\n}\nfunction defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {\n    if (!constructorContext) {\n        return undefined;\n    }\n    const rawLength = constructorContext.binary.length;\n    const offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n    const input = {\n        offset,\n        abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,\n        arguments: [],\n        allocationMode: \"full\"\n    };\n    const output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, \"full\"); //assume full, degrade as necessary\n    return { input, output };\n}\n//note: context should be deployed context!\nfunction constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {\n    if (!context) {\n        //just return a default abi mode result\n        return {\n            selector: new Uint8Array(),\n            allocationMode: \"abi\",\n            kind: \"bytecode\",\n            delegatecallGuard: false\n        };\n    }\n    const { immutableReferences, compilationId, compiler, contractKind, binary } = context;\n    let immutables;\n    if (allocationMode === \"full\" && immutableReferences) {\n        if (contractNode) {\n            debug(\"allocating immutables\");\n            immutables = [];\n            for (const [id, references] of Object.entries(immutableReferences)) {\n                if (references.length === 0) {\n                    continue; //don't allocate immutables that don't exist\n                }\n                const astId = parseInt(id);\n                //get the corresponding variable node; potentially fail\n                const { node: definition, contract: definedIn } = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, node => node.id === astId, contractNode);\n                if (!definition || definition.nodeType !== \"VariableDeclaration\") {\n                    debug(\"didn't find definition for %d!\", astId);\n                    allocationMode = \"abi\";\n                    immutables = undefined;\n                    break;\n                }\n                const definedInClass = (Ast.Import.definitionToStoredType(definedIn, compilationId, compiler)); //can skip reference declarations argument here\n                const dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n                immutables.push({\n                    name: definition.name,\n                    definedIn: definedInClass,\n                    type: dataType,\n                    pointer: {\n                        location: \"returndata\",\n                        start: references[0].start,\n                        length: references[0].length\n                    }\n                });\n            }\n        }\n        else if (Object.entries(immutableReferences).length > 0) {\n            //if there are immutables, but no contract mode, go to abi mode\n            debug(\"immutables but no node!\");\n            allocationMode = \"abi\";\n        }\n    }\n    else {\n        debug(\"no immutables\");\n    }\n    //now, is there a delegatecall guard?\n    let delegatecallGuard = false;\n    if (contractKind === \"library\") {\n        //note: I am relying on this being present!\n        //(also this part is a bit HACKy)\n        const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n        const delegateCallGuardString = \"0x\" + pushAddressInstruction + \"..\".repeat(Evm.Utils.ADDRESS_SIZE);\n        if (binary.startsWith(delegateCallGuardString)) {\n            delegatecallGuard = true;\n        }\n    }\n    return {\n        selector: new Uint8Array(),\n        allocationMode,\n        kind: \"bytecode\",\n        immutables,\n        delegatecallGuard\n    };\n}\nfunction getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n    let allocations = {\n        constructorAllocations: {},\n        functionAllocations: {}\n    };\n    for (let contract of contracts) {\n        const contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n        if (contract.constructorContext) {\n            allocations.constructorAllocations[contract.constructorContext.context] =\n                contractAllocations.constructorAllocation;\n        }\n        if (contract.deployedContext) {\n            allocations.functionAllocations[contract.deployedContext.context] =\n                contractAllocations.functionAllocations;\n            //set this up under both constructor *and* deployed! this is to handle\n            //constructor returndata decoding\n            allocations.constructorAllocations[contract.deployedContext.context] =\n                contractAllocations.constructorAllocation;\n        }\n    }\n    return allocations;\n}\nexports.getCalldataAllocations = getCalldataAllocations;\nfunction getReturndataAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n    let useAst = Boolean(contractNode && contractNode.usedErrors);\n    if (useAst) {\n        const errorNodes = contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]);\n        let abis;\n        try {\n            abis = errorNodes.map(errorNode => (Ast.Utils.definitionToAbi(errorNode, referenceDeclarations)));\n        }\n        catch (_a) {\n            useAst = false;\n        }\n        if (useAst) {\n            //i.e. if the above operation succeeded\n            return contractNode.usedErrors\n                .map(errorNodeId => referenceDeclarations[errorNodeId])\n                .map((errorNode, index) => allocateError(abis[index], errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n        }\n    }\n    if (!useAst && abi) {\n        //deliberately *not* an else!\n        return abi\n            .filter((abiEntry) => abiEntry.type === \"error\")\n            .filter((abiEntry) => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n            .map((abiEntry) => allocateError(abiEntry, undefined, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n    }\n    //otherwise just return nothing\n    return [];\n}\nfunction getReturndataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n    let allContexts = []\n        .concat(...contracts.map(({ deployedContext, constructorContext }) => [\n        deployedContext,\n        constructorContext\n    ]))\n        .filter(x => x) //filter out nonexistent contexts\n        .map(context => context.context);\n    allContexts.push(\"\"); //HACK: add fictional empty-string context to represent no-context\n    //holds allocations for a given context\n    let selfAllocations = {};\n    //holds allocations for *other* contexts\n    let additionalAllocations = {};\n    //now: process the allocations for each contract. we'll add each contract's\n    //allocations to *its* entries in allocations, and to every *other* entry\n    //in additionalAllocations.\n    for (const contract of contracts) {\n        const contractAllocations = getReturndataAllocationsForContract(contract.abi, contract.contractNode, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n        const contexts = [\n            //contexts for this contract\n            contract.deployedContext,\n            contract.constructorContext\n        ]\n            .filter(x => x) //filter out nonexistent contexts\n            .map(context => context.context);\n        const otherContexts = allContexts.filter(\n        //contexts for all other contracts\n        contextHash => !contexts.includes(contextHash));\n        //add them to selfAllocations\n        for (const contextHash of contexts) {\n            selfAllocations[contextHash] = contractAllocations;\n        }\n        //add them to additionalAllocations\n        for (const contextHash of otherContexts) {\n            if (additionalAllocations[contextHash] === undefined) {\n                additionalAllocations[contextHash] = [];\n            }\n            additionalAllocations[contextHash] =\n                additionalAllocations[contextHash].concat(contractAllocations);\n        }\n    }\n    let allocations = Object.assign({}, ...allContexts.map(contextHash => ({ [contextHash]: {} })));\n    //now: perform coalescense!\n    for (const contract of contracts) {\n        //we're setting up contexts again, sorry >_>\n        const contexts = [\n            //contexts for this contract\n            contract.deployedContext,\n            contract.constructorContext\n        ]\n            .filter(x => x) //filter out nonexistent contexts\n            .map(context => context.context);\n        for (const contextHash of contexts) {\n            allocations[contextHash] = coalesceReturndataAllocations(selfAllocations[contextHash] || [], additionalAllocations[contextHash] || []);\n            debug(\"allocations: %O\", allocations[contextHash]);\n        }\n    }\n    //...also coalesce the fake \"\" context\n    allocations[\"\"] = coalesceReturndataAllocations([], additionalAllocations[\"\"] || []);\n    /*\n    for (const [contextHash, contextAllocations] of Object.entries(allAllocations)) {\n      for (const [signature, signatureAllocations] of Object.entries(contextAllocations)) {\n        const selector = Web3Utils.soliditySha3({ type: \"string\", value: signature })\n          .slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n        if (!allocations[contextHash][selector]) {\n          allocations[contextHash][selector] = [];\n        }\n        allocations[contextHash][selector] = allocations[contextHash][selector].concat(signatureAllocations);\n      }\n    }\n    */\n    debug(\"error allocations: %O\", allocations);\n    return allocations;\n}\nexports.getReturndataAllocations = getReturndataAllocations;\nfunction coalesceReturndataAllocations(selfAllocations, additionalAllocations) {\n    let bySelector = {};\n    //start with the additional allocations; we want to process\n    //the self allocations last, due to special handling of no-ID allocations there\n    for (const allocation of additionalAllocations) {\n        const signature = AbiDataUtils.abiSignature(allocation.abi);\n        const selector = Web3Utils.soliditySha3({\n            type: \"string\",\n            value: signature\n        }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n        if (bySelector[selector]) {\n            //note: at this point, for any given signature, there should only be a\n            //no-ID allocation for that signature if it's the only one\n            if (allocation.id !== undefined) {\n                //delete anything with that signature but w/o an ID, or with this same ID\n                bySelector[selector] = bySelector[selector].filter(({ abi, id }) => !(AbiDataUtils.abiSignature(abi) === signature &&\n                    (id === undefined || id === allocation.id)));\n                //add this allocation\n                bySelector[selector].push(allocation);\n            }\n            else if (!bySelector[selector].some(({ abi }) => AbiDataUtils.abiSignature(abi) === signature)) {\n                //only add ID-less ones if there isn't anything of that signature already\n                bySelector[selector].push(allocation);\n            }\n        }\n        else {\n            //if there's nothing there thus far, add it\n            bySelector[selector] = [allocation];\n        }\n    }\n    //now we're going to perform a modified version of this procedure for the self allocations:\n    //1. we're going to add to the front, not the back\n    //2. we can add an ID-less one even if there are already ones with IDs there\n    //(sorry for the copypaste)\n    for (const allocation of selfAllocations) {\n        const signature = AbiDataUtils.abiSignature(allocation.abi);\n        const selector = Web3Utils.soliditySha3({\n            type: \"string\",\n            value: signature\n        }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n        if (bySelector[selector]) {\n            //delete anything with that signature but w/o an ID, or with this same ID\n            //(if this alloc has no ID, this will only delete ID-less ones :) )\n            bySelector[selector] = bySelector[selector].filter(({ abi, id }) => !(AbiDataUtils.abiSignature(abi) === signature &&\n                (id === undefined || id === allocation.id)));\n            //add this allocation to front, not back!\n            bySelector[selector].unshift(allocation);\n        }\n        else {\n            //if there's nothing there thus far, add it\n            bySelector[selector] = [allocation];\n        }\n    }\n    return bySelector;\n}\nfunction getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n    return abi\n        .filter((abiEntry) => abiEntry.type === \"event\")\n        .filter((abiEntry) => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n        .map((abiEntry) => ({\n        selector: AbiDataUtils.abiSelector(abiEntry),\n        anonymous: abiEntry.anonymous,\n        topics: AbiDataUtils.topicsCount(abiEntry),\n        allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)\n    }));\n    //note we do *not* filter out undefined allocations; we need these as placeholders\n}\n//note: constructor context is ignored by this function; no need to pass it in\n//WARNING: this function is full of hacks... sorry\nfunction getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n    //first: do allocations for individual contracts\n    let individualAllocations = {};\n    let groupedAllocations = {};\n    let allocations = {};\n    for (let { abi, deployedContext, contractNode, compilationId, compiler } of contracts) {\n        if (!deployedContext && !contractNode) {\n            //we'll need *one* of these two at least\n            continue;\n        }\n        let contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);\n        let key = makeContractKey(deployedContext, contractNode ? contractNode.id : undefined, compilationId);\n        if (individualAllocations[key] === undefined) {\n            individualAllocations[key] = {};\n        }\n        for (let allocationTemporary of contractAllocations) {\n            //we'll use selector *even for anonymous* here, because it's just\n            //for determining what overrides what at this point\n            individualAllocations[key][allocationTemporary.selector] = {\n                context: deployedContext,\n                contractNode,\n                allocationTemporary,\n                compilationId\n            };\n        }\n    }\n    //now: put things together for inheritance\n    //note how we always put things in order from most derived to most base\n    for (let contextOrId in individualAllocations) {\n        groupedAllocations[contextOrId] = {};\n        for (let selector in individualAllocations[contextOrId]) {\n            let { context, contractNode, allocationTemporary, compilationId } = individualAllocations[contextOrId][selector];\n            debug(\"allocationTemporary: %O\", allocationTemporary);\n            let allocationsTemporary = allocationTemporary.allocation\n                ? [allocationTemporary]\n                : []; //filter out undefined allocations\n            //first, copy from individual allocations\n            groupedAllocations[contextOrId][selector] = {\n                context,\n                contractNode,\n                allocationsTemporary\n            };\n            //if no contract node, that's all.  if there is...\n            if (contractNode) {\n                //...we have to do inheritance processing\n                debug(\"contract Id: %d\", contractNode.id);\n                debug(\"base contracts: %o\", contractNode.linearizedBaseContracts);\n                let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n                linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors\n                for (let baseId of linearizedBaseContractsMinusSelf) {\n                    debug(\"checking baseId: %d\", baseId);\n                    let baseNode = referenceDeclarations[compilationId][baseId];\n                    if (!baseNode || baseNode.nodeType !== \"ContractDefinition\") {\n                        debug(\"failed to find node for baseId: %d\", baseId);\n                        break; //not a continue!\n                        //if we can't find the base node, it's better to stop the loop,\n                        //rather than continue to potentially erroneous things\n                    }\n                    //note: we're not actually going to *use* the baseNode here.\n                    //we're just checking for whether we can *find* it\n                    //why? because if we couldn't find it, that means that events defined in\n                    //base contracts *weren't* skipped earlier, and so we shouldn't now add them in\n                    let baseContractInfo = contracts.find(contractAllocationInfo => contractAllocationInfo.compilationId === compilationId &&\n                        contractAllocationInfo.contractNode &&\n                        contractAllocationInfo.contractNode.id === baseId);\n                    if (!baseContractInfo) {\n                        //similar to above... this failure case can happen when there are\n                        //two contracts with the same name and you attempt to use the\n                        //artifacts; say you have contracts A, B, and B', where A inherits\n                        //from B, and B and B' have the same name, and B' is the one that\n                        //gets the artifact; B will end up in reference declarations and so\n                        //get found above, but it won't appear in contracts, causing the\n                        //problem here.  Unfortunately I don't know any great way to handle this,\n                        //so, uh, we treat it as a failure same as above.\n                        debug(\"failed to find contract info for baseId: %d\", baseId);\n                        break;\n                    }\n                    let baseContext = baseContractInfo.deployedContext;\n                    let baseKey = makeContractKey(baseContext, baseId, compilationId);\n                    if (individualAllocations[baseKey][selector] !== undefined) {\n                        let baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;\n                        debug(\"(probably) pushing inherited alloc from baseId: %d\", baseId);\n                        if (baseAllocation.allocation) {\n                            //don't push undefined!\n                            groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //finally: transform into final form & return,\n    //filtering out things w/o a context\n    for (let contractKey in groupedAllocations) {\n        if (!hasContext(contractKey)) {\n            continue;\n            //(this filters out ones that had no context and therefore were\n            //given by ID; we needed these at the previous stage but from\n            //here on they're irrelevant)\n        }\n        let contextHash = contextHashForKey(contractKey);\n        for (let selector in groupedAllocations[contextHash]) {\n            let { allocationsTemporary, context } = groupedAllocations[contextHash][selector];\n            for (let { anonymous, topics, allocation } of allocationsTemporary) {\n                let contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK\n                if (contractKind !== \"library\") {\n                    contractKind = \"contract\"; //round off interfaces to being contracts for our purposes :P\n                }\n                allocation = Object.assign(Object.assign({}, allocation), { contextHash }); //the allocation's context hash at this point depends on where it was defined, but\n                //that's not what we want going in the final allocation table!\n                if (allocations[topics] === undefined) {\n                    allocations[topics] = {\n                        bySelector: {},\n                        anonymous: { contract: {}, library: {} }\n                    };\n                }\n                if (!anonymous) {\n                    if (allocations[topics].bySelector[selector] === undefined) {\n                        allocations[topics].bySelector[selector] = {\n                            contract: {},\n                            library: {}\n                        };\n                    }\n                    if (allocations[topics].bySelector[selector][contractKind][contextHash] === undefined) {\n                        allocations[topics].bySelector[selector][contractKind][contextHash] = [];\n                    }\n                    allocations[topics].bySelector[selector][contractKind][contextHash].push(allocation);\n                }\n                else {\n                    if (allocations[topics].anonymous[contractKind][contextHash] ===\n                        undefined) {\n                        allocations[topics].anonymous[contractKind][contextHash] = [];\n                    }\n                    allocations[topics].anonymous[contractKind][contextHash].push(allocation);\n                }\n            }\n        }\n    }\n    return allocations;\n}\nexports.getEventAllocations = getEventAllocations;\n//if derivedContractNode is passed, we check that before referenceDeclarations\nfunction findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {\n    const searchResult = linearizedBaseContracts.reduce((foundNodeAndContract, baseContractId) => {\n        if (foundNodeAndContract !== undefined) {\n            return foundNodeAndContract; //once we've found something, we don't need to keep looking\n        }\n        debug(\"searching contract %d\", baseContractId);\n        let baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id\n            ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision\n            : referenceDeclarations[baseContractId];\n        if (baseContractNode === undefined ||\n            baseContractNode.nodeType !== \"ContractDefinition\") {\n            debug(\"bad contract node!\");\n            return null; //return null rather than undefined so that this will propagate through\n            //(i.e. by returning null here we give up the search)\n            //(we don't want to continue due to possibility of grabbing the wrong override)\n        }\n        const node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!\n        if (node) {\n            debug(\"found node: %o\", node);\n            return {\n                node,\n                contract: baseContractNode\n            };\n        }\n        else {\n            return undefined;\n        }\n    }, undefined //start with no node found\n    );\n    return searchResult || { node: undefined, contract: undefined };\n}\nfunction makeContractKey(context, id, compilationId) {\n    return context ? context.context : id + \":\" + compilationId; //HACK!\n}\nfunction hasContext(key) {\n    return key.startsWith(\"0x\"); //HACK!\n}\nfunction contextHashForKey(key) {\n    return hasContext(key)\n        ? key //HACK!\n        : undefined;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}