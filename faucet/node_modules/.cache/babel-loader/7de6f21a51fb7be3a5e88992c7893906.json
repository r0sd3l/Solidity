{"ast":null,"code":"const execute = require(\"../execute\");\n\nconst debug = require(\"debug\")(\"contract:contract:bootstrap\");\n\nmodule.exports = fn => {\n  // Add our static methods\n  // Add something here about excluding send, privately defined methods\n  Object.keys(fn._constructorMethods).forEach(function (key) {\n    fn[key] = fn._constructorMethods[key].bind(fn);\n  }); // Add our properties.\n\n  Object.keys(fn._properties).forEach(function (key) {\n    fn.addProp(key, fn._properties[key]);\n  }); // estimateGas & request as sub-property of new\n\n  fn[\"new\"].estimateGas = execute.estimateDeployment.bind(fn);\n  fn[\"new\"].request = execute.requestDeployment.bind(fn); //add enumerations. (probably these should go in\n  //constructorMethods.js, but this is easier to modify... we'll\n  //redo all this in the rewrite anyway)\n\n  if (fn._json) {\n    //getters will throw otherwise!\n    if (fn.ast) {\n      //note this was set up earlier\n      const node = locateNode(fn.contractName, fn.ast); //name also set up earlier\n\n      if (node) {\n        fn.enums = extractEnums(node);\n\n        for (const [name, enumeration] of Object.entries(fn.enums)) {\n          //enum is a reserved word :P\n          if (!(name in fn)) {\n            //don't overwrite anything!\n            fn[name] = enumeration;\n          }\n        }\n      }\n    }\n  }\n\n  return fn;\n};\n\nfunction locateNode(name, ast) {\n  if (ast.nodeType === \"SourceUnit\") {\n    return ast.nodes.find(node => node.nodeType === \"ContractDefinition\" && node.name === name);\n  } else {\n    return undefined;\n  }\n}\n\nfunction extractEnums(node) {\n  return Object.assign({}, ...node.nodes.filter(definition => definition.nodeType === \"EnumDefinition\").map(definition => ({\n    [definition.name]: Object.assign({}, ...definition.members.map((member, index) => ({\n      [member.name]: index\n    })))\n  })));\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/@truffle/contract/lib/contract/bootstrap.js"],"names":["execute","require","debug","module","exports","fn","Object","keys","_constructorMethods","forEach","key","bind","_properties","addProp","estimateGas","estimateDeployment","request","requestDeployment","_json","ast","node","locateNode","contractName","enums","extractEnums","name","enumeration","entries","nodeType","nodes","find","undefined","assign","filter","definition","map","members","member","index"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAAP,CAAiB,6BAAjB,CAAd;;AAEAE,MAAM,CAACC,OAAP,GAAiBC,EAAE,IAAI;AACrB;AACA;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAYF,EAAE,CAACG,mBAAf,EAAoCC,OAApC,CAA4C,UAAUC,GAAV,EAAe;AACzDL,IAAAA,EAAE,CAACK,GAAD,CAAF,GAAUL,EAAE,CAACG,mBAAH,CAAuBE,GAAvB,EAA4BC,IAA5B,CAAiCN,EAAjC,CAAV;AACD,GAFD,EAHqB,CAOrB;;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAYF,EAAE,CAACO,WAAf,EAA4BH,OAA5B,CAAoC,UAAUC,GAAV,EAAe;AACjDL,IAAAA,EAAE,CAACQ,OAAH,CAAWH,GAAX,EAAgBL,EAAE,CAACO,WAAH,CAAeF,GAAf,CAAhB;AACD,GAFD,EARqB,CAYrB;;AACAL,EAAAA,EAAE,CAAC,KAAD,CAAF,CAAUS,WAAV,GAAwBd,OAAO,CAACe,kBAAR,CAA2BJ,IAA3B,CAAgCN,EAAhC,CAAxB;AACAA,EAAAA,EAAE,CAAC,KAAD,CAAF,CAAUW,OAAV,GAAoBhB,OAAO,CAACiB,iBAAR,CAA0BN,IAA1B,CAA+BN,EAA/B,CAApB,CAdqB,CAgBrB;AACA;AACA;;AACA,MAAIA,EAAE,CAACa,KAAP,EAAc;AACZ;AACA,QAAIb,EAAE,CAACc,GAAP,EAAY;AACV;AACA,YAAMC,IAAI,GAAGC,UAAU,CAAChB,EAAE,CAACiB,YAAJ,EAAkBjB,EAAE,CAACc,GAArB,CAAvB,CAFU,CAEwC;;AAClD,UAAIC,IAAJ,EAAU;AACRf,QAAAA,EAAE,CAACkB,KAAH,GAAWC,YAAY,CAACJ,IAAD,CAAvB;;AACA,aAAK,MAAM,CAACK,IAAD,EAAOC,WAAP,CAAX,IAAkCpB,MAAM,CAACqB,OAAP,CAAetB,EAAE,CAACkB,KAAlB,CAAlC,EAA4D;AAC1D;AACA,cAAI,EAAEE,IAAI,IAAIpB,EAAV,CAAJ,EAAmB;AACjB;AACAA,YAAAA,EAAE,CAACoB,IAAD,CAAF,GAAWC,WAAX;AACD;AACF;AACF;AACF;AACF;;AAED,SAAOrB,EAAP;AACD,CAtCD;;AAwCA,SAASgB,UAAT,CAAoBI,IAApB,EAA0BN,GAA1B,EAA+B;AAC7B,MAAIA,GAAG,CAACS,QAAJ,KAAiB,YAArB,EAAmC;AACjC,WAAOT,GAAG,CAACU,KAAJ,CAAUC,IAAV,CACLV,IAAI,IAAIA,IAAI,CAACQ,QAAL,KAAkB,oBAAlB,IAA0CR,IAAI,CAACK,IAAL,KAAcA,IAD3D,CAAP;AAGD,GAJD,MAIO;AACL,WAAOM,SAAP;AACD;AACF;;AAED,SAASP,YAAT,CAAsBJ,IAAtB,EAA4B;AAC1B,SAAOd,MAAM,CAAC0B,MAAP,CACL,EADK,EAEL,GAAGZ,IAAI,CAACS,KAAL,CACAI,MADA,CACOC,UAAU,IAAIA,UAAU,CAACN,QAAX,KAAwB,gBAD7C,EAEAO,GAFA,CAEID,UAAU,KAAK;AAClB,KAACA,UAAU,CAACT,IAAZ,GAAmBnB,MAAM,CAAC0B,MAAP,CACjB,EADiB,EAEjB,GAAGE,UAAU,CAACE,OAAX,CAAmBD,GAAnB,CAAuB,CAACE,MAAD,EAASC,KAAT,MAAoB;AAAC,OAACD,MAAM,CAACZ,IAAR,GAAea;AAAhB,KAApB,CAAvB,CAFc;AADD,GAAL,CAFd,CAFE,CAAP;AAWD","sourcesContent":["const execute = require(\"../execute\");\nconst debug = require(\"debug\")(\"contract:contract:bootstrap\");\n\nmodule.exports = fn => {\n  // Add our static methods\n  // Add something here about excluding send, privately defined methods\n  Object.keys(fn._constructorMethods).forEach(function (key) {\n    fn[key] = fn._constructorMethods[key].bind(fn);\n  });\n\n  // Add our properties.\n  Object.keys(fn._properties).forEach(function (key) {\n    fn.addProp(key, fn._properties[key]);\n  });\n\n  // estimateGas & request as sub-property of new\n  fn[\"new\"].estimateGas = execute.estimateDeployment.bind(fn);\n  fn[\"new\"].request = execute.requestDeployment.bind(fn);\n\n  //add enumerations. (probably these should go in\n  //constructorMethods.js, but this is easier to modify... we'll\n  //redo all this in the rewrite anyway)\n  if (fn._json) {\n    //getters will throw otherwise!\n    if (fn.ast) {\n      //note this was set up earlier\n      const node = locateNode(fn.contractName, fn.ast); //name also set up earlier\n      if (node) {\n        fn.enums = extractEnums(node);\n        for (const [name, enumeration] of Object.entries(fn.enums)) {\n          //enum is a reserved word :P\n          if (!(name in fn)) {\n            //don't overwrite anything!\n            fn[name] = enumeration;\n          }\n        }\n      }\n    }\n  }\n\n  return fn;\n};\n\nfunction locateNode(name, ast) {\n  if (ast.nodeType === \"SourceUnit\") {\n    return ast.nodes.find(\n      node => node.nodeType === \"ContractDefinition\" && node.name === name\n    );\n  } else {\n    return undefined;\n  }\n}\n\nfunction extractEnums(node) {\n  return Object.assign(\n    {},\n    ...node.nodes\n      .filter(definition => definition.nodeType === \"EnumDefinition\")\n      .map(definition => ({\n        [definition.name]: Object.assign(\n          {},\n          ...definition.members.map((member, index) => ({[member.name]: index}))\n        )\n      }))\n  );\n}\n"]},"metadata":{},"sourceType":"script"}