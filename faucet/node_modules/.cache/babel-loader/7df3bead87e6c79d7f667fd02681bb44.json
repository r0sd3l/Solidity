{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeAbi(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (Format.Types.isReferenceType(dataType) || dataType.typeClass === \"tuple\") {\n    //I don't want tuples to be considered a reference type, but it makes sense\n    //to group them for this purpose\n    let dynamic;\n\n    try {\n      dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;\n    } catch (error) {\n      return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);\n    }\n\n    if (dynamic) {\n      return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);\n    } else {\n      return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);\n    }\n  } else {\n    debug(\"pointer %o\", pointer);\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n  }\n}\n\nexports.decodeAbi = decodeAbi;\n\nfunction* decodeAbiReferenceByAddress(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let {\n    strictAbiMode: strict,\n    abiPointerBase: base,\n    lengthOverride\n  } = options;\n  base = base || 0; //in case base was undefined\n\n  const {\n    allocations: {\n      abi: allocations\n    },\n    state\n  } = info;\n  debug(\"pointer %o\", pointer); //this variable holds the location we should look to *next*\n  //stack pointers point to calldata; other pointers point to same location\n\n  const location = pointer.location === \"stack\" || pointer.location === \"stackliteral\" ? \"calldata\" : pointer.location;\n\n  if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n    //length overrides are only applicable when you're decoding a pointer\n    //from the stack!  otherwise they must be ignored!\n    lengthOverride = undefined;\n  }\n\n  let rawValue;\n\n  try {\n    rawValue = yield* read_1.default(pointer, state);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error, strict);\n  }\n\n  let rawValueAsBN = Conversion.toBN(rawValue);\n  debug(\"rawValue: %O\", rawValue);\n  debug(\"rawValueAsBN: %O\", rawValueAsBN);\n  let rawValueAsNumber;\n\n  try {\n    rawValueAsNumber = rawValueAsBN.toNumber();\n  } catch (_a) {\n    let error = {\n      kind: \"OverlargePointersNotImplementedError\",\n      pointerAsBN: rawValueAsBN\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      //again with the TS failures...\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  let startPosition = rawValueAsNumber + base;\n  debug(\"startPosition %d\", startPosition);\n  let dynamic;\n  let size;\n\n  try {\n    ({\n      dynamic,\n      size\n    } = allocate_1.abiSizeInfo(dataType, allocations));\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error, strict);\n  }\n\n  if (!dynamic) {\n    //this will only come up when called from stack.ts\n    let staticPointer = {\n      location,\n      start: startPosition,\n      length: size\n    };\n    return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);\n  }\n\n  let length;\n  let lengthAsBN;\n  let rawLength;\n\n  switch (dataType.typeClass) {\n    case \"bytes\":\n    case \"string\":\n      //initial word contains length (unless an override was given)\n      if (lengthOverride !== undefined) {\n        lengthAsBN = lengthOverride; //note in this case we do *not* increment start position;\n        //if a length override is given, that means the given start\n        //position skips over the length word!\n      } else {\n        try {\n          rawLength = yield* read_1.default({\n            location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error, strict);\n        }\n\n        lengthAsBN = Conversion.toBN(rawLength);\n        startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n        //so it'll be set up to read the data\n      }\n\n      if (strict && lengthAsBN.gtn(state[location].length)) {\n        //you may notice that the comparison is a bit crude; that's OK, this is\n        //just to prevent huge numbers from DOSing us, other errors will still\n        //be caught regardless\n        throw new errors_1.StopDecodingError({\n          kind: \"OverlongArrayOrStringStrictModeError\",\n          lengthAsBN,\n          dataLength: state[location].length\n        });\n      }\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_b) {\n        //note: if we're in this situation, we can assume we're not in strict mode,\n        //as the strict case was handled above\n        return {\n          //again with the TS failures...\n          type: dataType,\n          kind: \"error\",\n          error: {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          }\n        };\n      }\n\n      let childPointer = {\n        location,\n        start: startPosition,\n        length\n      };\n      return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);\n\n    case \"array\":\n      if (dataType.kind === \"static\") {\n        //static-length array\n        lengthAsBN = dataType.length; //note we don't increment start position; static arrays don't\n        //include a length word!\n      } else if (lengthOverride !== undefined) {\n        debug(\"override: %o\", lengthOverride); //dynamic-length array, but with length override\n\n        lengthAsBN = lengthOverride; //we don't increment start position; if a length override was\n        //given, that means the pointer skipped the length word!\n      } else {\n        //dynamic-length array, read length from data\n        //initial word contains array length\n        try {\n          rawLength = yield* read_1.default({\n            location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error, strict);\n        }\n\n        lengthAsBN = Conversion.toBN(rawLength);\n        startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n        //to next word, as first word was used for length\n      }\n\n      if (strict && lengthAsBN.gtn(state[location].length)) {\n        //you may notice that the comparison is a bit crude; that's OK, this is\n        //just to prevent huge numbers from DOSing us, other errors will still\n        //be caught regardless\n        throw new errors_1.StopDecodingError({\n          kind: \"OverlongArraysAndStringsNotImplementedError\",\n          lengthAsBN,\n          dataLength: state[location].length\n        });\n      }\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_c) {\n        //again, if we get here, we can assume we're not in strict mode\n        return {\n          type: dataType,\n          kind: \"error\",\n          error: {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          }\n        };\n      } //note: I've written this fairly generically, but it is worth noting that\n      //since this array is of dynamic type, we know that if it's static length\n      //then size must be EVM.WORD_SIZE\n\n\n      let baseSize;\n\n      try {\n        baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;\n      } catch (error) {\n        return errors_1.handleDecodingError(dataType, error, strict);\n      }\n\n      let decodedChildren = [];\n\n      for (let index = 0; index < length; index++) {\n        decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n          location,\n          start: startPosition + index * baseSize,\n          length: baseSize\n        }, info, Object.assign(Object.assign({}, options), {\n          abiPointerBase: startPosition\n        }))); //pointer base is always start of list, never the length\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedChildren\n      };\n\n    case \"struct\":\n      return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);\n\n    case \"tuple\":\n      return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);\n  }\n}\n\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\n\nfunction* decodeAbiReferenceStatic(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  debug(\"static\");\n  debug(\"pointer %o\", pointer);\n  const location = pointer.location;\n\n  switch (dataType.typeClass) {\n    case \"array\":\n      //we're in the static case, so we know the array must be statically sized\n      const lengthAsBN = dataType.length;\n      let length;\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_a) {\n        //note: since this is the static case, we don't bother including the stronger\n        //strict-mode guard against getting DOSed by large array sizes, since in this\n        //case we're not reading the size from the input; if there's a huge static size\n        //array, well, we'll just have to deal with it\n        let error = {\n          kind: \"OverlongArraysAndStringsNotImplementedError\",\n          lengthAsBN\n        };\n\n        if (options.strictAbiMode) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      }\n\n      let baseSize;\n\n      try {\n        baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;\n      } catch (error) {\n        return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);\n      }\n\n      let decodedChildren = [];\n\n      for (let index = 0; index < length; index++) {\n        decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n          location,\n          start: pointer.start + index * baseSize,\n          length: baseSize\n        }, info, options));\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedChildren\n      };\n\n    case \"struct\":\n      return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);\n\n    case \"tuple\":\n      return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);\n  }\n}\n\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic; //note that this function takes the start position as a *number*; it does not take a pointer\n\nfunction* decodeAbiStructByPosition(dataType, location, startPosition, info) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const {\n    allocations: {\n      abi: allocations\n    }\n  } = info;\n  const typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n\n  const typeId = dataType.id;\n  const structAllocation = allocations[typeId];\n\n  if (!structAllocation) {\n    let error = {\n      kind: \"UserDefinedTypeNotFoundError\",\n      type: dataType\n    };\n\n    if (options.strictAbiMode || options.allowRetry) {\n      throw new errors_1.StopDecodingError(error, true); //note that we allow a retry if we couldn't locate the allocation!\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  let decodedMembers = [];\n\n  for (let index = 0; index < structAllocation.members.length; index++) {\n    const memberAllocation = structAllocation.members[index];\n    const memberPointer = memberAllocation.pointer;\n    const childPointer = {\n      location,\n      start: startPosition + memberPointer.start,\n      length: memberPointer.length\n    };\n    let memberName = memberAllocation.name;\n    let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n    decodedMembers.push({\n      name: memberName,\n      value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n        abiPointerBase: startPosition\n      })) //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n\n    });\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: decodedMembers\n  };\n} //note that this function takes the start position as a *number*; it does not take a pointer\n\n\nfunction* decodeAbiTupleByPosition(dataType, location, startPosition, info) {\n  let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n  //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n  //However it may be worth revisiting this in the future if performance turns out to be a problem\n  //(changing this may be pretty hard though)\n  let decodedMembers = [];\n  let position = startPosition;\n\n  for (const {\n    name,\n    type: memberType\n  } of dataType.memberTypes) {\n    const memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;\n    const childPointer = {\n      location,\n      start: position,\n      length: memberSize\n    };\n    decodedMembers.push({\n      name,\n      value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n        abiPointerBase: startPosition\n      })) //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n\n    });\n    position += memberSize;\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: decodedMembers\n  };\n}","map":{"version":3,"sources":["../../../../lib/abi-data/decode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:abi-data:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst errors_1 = require(\"../../errors\");\nfunction* decodeAbi(dataType, pointer, info, options = {}) {\n    if (Format.Types.isReferenceType(dataType) ||\n        dataType.typeClass === \"tuple\") {\n        //I don't want tuples to be considered a reference type, but it makes sense\n        //to group them for this purpose\n        let dynamic;\n        try {\n            dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;\n        }\n        catch (error) {\n            return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);\n        }\n        if (dynamic) {\n            return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);\n        }\n        else {\n            return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);\n        }\n    }\n    else {\n        debug(\"pointer %o\", pointer);\n        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n    }\n}\nexports.decodeAbi = decodeAbi;\nfunction* decodeAbiReferenceByAddress(dataType, pointer, info, options = {}) {\n    let { strictAbiMode: strict, abiPointerBase: base, lengthOverride } = options;\n    base = base || 0; //in case base was undefined\n    const { allocations: { abi: allocations }, state } = info;\n    debug(\"pointer %o\", pointer);\n    //this variable holds the location we should look to *next*\n    //stack pointers point to calldata; other pointers point to same location\n    const location = pointer.location === \"stack\" || pointer.location === \"stackliteral\"\n        ? \"calldata\"\n        : pointer.location;\n    if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n        //length overrides are only applicable when you're decoding a pointer\n        //from the stack!  otherwise they must be ignored!\n        lengthOverride = undefined;\n    }\n    let rawValue;\n    try {\n        rawValue = yield* read_1.default(pointer, state);\n    }\n    catch (error) {\n        return errors_1.handleDecodingError(dataType, error, strict);\n    }\n    let rawValueAsBN = Conversion.toBN(rawValue);\n    debug(\"rawValue: %O\", rawValue);\n    debug(\"rawValueAsBN: %O\", rawValueAsBN);\n    let rawValueAsNumber;\n    try {\n        rawValueAsNumber = rawValueAsBN.toNumber();\n    }\n    catch (_a) {\n        let error = {\n            kind: \"OverlargePointersNotImplementedError\",\n            pointerAsBN: rawValueAsBN\n        };\n        if (strict) {\n            throw new errors_1.StopDecodingError(error);\n        }\n        return {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error\n        };\n    }\n    let startPosition = rawValueAsNumber + base;\n    debug(\"startPosition %d\", startPosition);\n    let dynamic;\n    let size;\n    try {\n        ({ dynamic, size } = allocate_1.abiSizeInfo(dataType, allocations));\n    }\n    catch (error) {\n        return errors_1.handleDecodingError(dataType, error, strict);\n    }\n    if (!dynamic) {\n        //this will only come up when called from stack.ts\n        let staticPointer = {\n            location,\n            start: startPosition,\n            length: size\n        };\n        return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);\n    }\n    let length;\n    let lengthAsBN;\n    let rawLength;\n    switch (dataType.typeClass) {\n        case \"bytes\":\n        case \"string\":\n            //initial word contains length (unless an override was given)\n            if (lengthOverride !== undefined) {\n                lengthAsBN = lengthOverride;\n                //note in this case we do *not* increment start position;\n                //if a length override is given, that means the given start\n                //position skips over the length word!\n            }\n            else {\n                try {\n                    rawLength = yield* read_1.default({\n                        location,\n                        start: startPosition,\n                        length: Evm.Utils.WORD_SIZE\n                    }, state);\n                }\n                catch (error) {\n                    return errors_1.handleDecodingError(dataType, error, strict);\n                }\n                lengthAsBN = Conversion.toBN(rawLength);\n                startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n                //so it'll be set up to read the data\n            }\n            if (strict && lengthAsBN.gtn(state[location].length)) {\n                //you may notice that the comparison is a bit crude; that's OK, this is\n                //just to prevent huge numbers from DOSing us, other errors will still\n                //be caught regardless\n                throw new errors_1.StopDecodingError({\n                    kind: \"OverlongArrayOrStringStrictModeError\",\n                    lengthAsBN,\n                    dataLength: state[location].length\n                });\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_b) {\n                //note: if we're in this situation, we can assume we're not in strict mode,\n                //as the strict case was handled above\n                return {\n                    //again with the TS failures...\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            let childPointer = {\n                location,\n                start: startPosition,\n                length\n            };\n            return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);\n        case \"array\":\n            if (dataType.kind === \"static\") {\n                //static-length array\n                lengthAsBN = dataType.length;\n                //note we don't increment start position; static arrays don't\n                //include a length word!\n            }\n            else if (lengthOverride !== undefined) {\n                debug(\"override: %o\", lengthOverride);\n                //dynamic-length array, but with length override\n                lengthAsBN = lengthOverride;\n                //we don't increment start position; if a length override was\n                //given, that means the pointer skipped the length word!\n            }\n            else {\n                //dynamic-length array, read length from data\n                //initial word contains array length\n                try {\n                    rawLength = yield* read_1.default({\n                        location,\n                        start: startPosition,\n                        length: Evm.Utils.WORD_SIZE\n                    }, state);\n                }\n                catch (error) {\n                    return errors_1.handleDecodingError(dataType, error, strict);\n                }\n                lengthAsBN = Conversion.toBN(rawLength);\n                startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n                //to next word, as first word was used for length\n            }\n            if (strict && lengthAsBN.gtn(state[location].length)) {\n                //you may notice that the comparison is a bit crude; that's OK, this is\n                //just to prevent huge numbers from DOSing us, other errors will still\n                //be caught regardless\n                throw new errors_1.StopDecodingError({\n                    kind: \"OverlongArraysAndStringsNotImplementedError\",\n                    lengthAsBN,\n                    dataLength: state[location].length\n                });\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_c) {\n                //again, if we get here, we can assume we're not in strict mode\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            //note: I've written this fairly generically, but it is worth noting that\n            //since this array is of dynamic type, we know that if it's static length\n            //then size must be EVM.WORD_SIZE\n            let baseSize;\n            try {\n                baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;\n            }\n            catch (error) {\n                return errors_1.handleDecodingError(dataType, error, strict);\n            }\n            let decodedChildren = [];\n            for (let index = 0; index < length; index++) {\n                decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n                    location,\n                    start: startPosition + index * baseSize,\n                    length: baseSize\n                }, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))); //pointer base is always start of list, never the length\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        case \"struct\":\n            return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);\n        case \"tuple\":\n            return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);\n    }\n}\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\nfunction* decodeAbiReferenceStatic(dataType, pointer, info, options = {}) {\n    debug(\"static\");\n    debug(\"pointer %o\", pointer);\n    const location = pointer.location;\n    switch (dataType.typeClass) {\n        case \"array\":\n            //we're in the static case, so we know the array must be statically sized\n            const lengthAsBN = dataType.length;\n            let length;\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_a) {\n                //note: since this is the static case, we don't bother including the stronger\n                //strict-mode guard against getting DOSed by large array sizes, since in this\n                //case we're not reading the size from the input; if there's a huge static size\n                //array, well, we'll just have to deal with it\n                let error = {\n                    kind: \"OverlongArraysAndStringsNotImplementedError\",\n                    lengthAsBN\n                };\n                if (options.strictAbiMode) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            let baseSize;\n            try {\n                baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;\n            }\n            catch (error) {\n                return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);\n            }\n            let decodedChildren = [];\n            for (let index = 0; index < length; index++) {\n                decodedChildren.push(yield* decodeAbi(dataType.baseType, {\n                    location,\n                    start: pointer.start + index * baseSize,\n                    length: baseSize\n                }, info, options));\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        case \"struct\":\n            return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);\n        case \"tuple\":\n            return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);\n    }\n}\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic;\n//note that this function takes the start position as a *number*; it does not take a pointer\nfunction* decodeAbiStructByPosition(dataType, location, startPosition, info, options = {}) {\n    const { allocations: { abi: allocations } } = info;\n    const typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n    const typeId = dataType.id;\n    const structAllocation = allocations[typeId];\n    if (!structAllocation) {\n        let error = {\n            kind: \"UserDefinedTypeNotFoundError\",\n            type: dataType\n        };\n        if (options.strictAbiMode || options.allowRetry) {\n            throw new errors_1.StopDecodingError(error, true);\n            //note that we allow a retry if we couldn't locate the allocation!\n        }\n        return {\n            type: dataType,\n            kind: \"error\",\n            error\n        };\n    }\n    let decodedMembers = [];\n    for (let index = 0; index < structAllocation.members.length; index++) {\n        const memberAllocation = structAllocation.members[index];\n        const memberPointer = memberAllocation.pointer;\n        const childPointer = {\n            location,\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length\n        };\n        let memberName = memberAllocation.name;\n        let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n        decodedMembers.push({\n            name: memberName,\n            value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))\n            //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n        });\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedMembers\n    };\n}\n//note that this function takes the start position as a *number*; it does not take a pointer\nfunction* decodeAbiTupleByPosition(dataType, location, startPosition, info, options = {}) {\n    //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n    //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n    //However it may be worth revisiting this in the future if performance turns out to be a problem\n    //(changing this may be pretty hard though)\n    let decodedMembers = [];\n    let position = startPosition;\n    for (const { name, type: memberType } of dataType.memberTypes) {\n        const memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;\n        const childPointer = {\n            location,\n            start: position,\n            length: memberSize\n        };\n        decodedMembers.push({\n            name,\n            value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))\n            //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n        });\n        position += memberSize;\n    }\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedMembers\n    };\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}