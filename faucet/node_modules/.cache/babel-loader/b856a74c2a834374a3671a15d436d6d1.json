{"ast":null,"code":"\"use strict\";\n\nconst Blockchain = {\n  getBlockByNumber(blockNumber, provider, callback) {\n    const params = [blockNumber, true];\n    provider.send({\n      jsonrpc: \"2.0\",\n      method: \"eth_getBlockByNumber\",\n      params,\n      id: Date.now()\n    }, callback);\n  },\n\n  getBlockByHash(blockHash, provider, callback) {\n    const params = [blockHash, true];\n    provider.send({\n      jsonrpc: \"2.0\",\n      method: \"eth_getBlockByHash\",\n      params,\n      id: Date.now()\n    }, callback);\n  },\n\n  parse(uri) {\n    const parsed = {};\n    if (uri.indexOf(\"blockchain://\") !== 0) return parsed;\n    const cleanUri = uri.replace(\"blockchain://\", \"\");\n    const pieces = cleanUri.split(\"/block/\");\n    parsed.genesis_hash = `0x${pieces[0]}`;\n    parsed.block_hash = `0x${pieces[1]}`;\n    return parsed;\n  },\n\n  asURI(provider) {\n    return new Promise((resolve, reject) => {\n      let genesis, latest;\n      this.getBlockByNumber(\"0x0\", provider, (err, _ref) => {\n        let {\n          result\n        } = _ref;\n        if (err) return reject(err);\n        genesis = result;\n        this.getBlockByNumber(\"latest\", provider, (err, _ref2) => {\n          let {\n            result\n          } = _ref2;\n          if (err) return reject(err);\n          latest = result;\n          const url = `blockchain://${genesis.hash.replace(\"0x\", \"\")}/block/${latest.hash.replace(\"0x\", \"\")}`;\n          resolve(url);\n        });\n      });\n    });\n  },\n\n  matches(uri, provider) {\n    return new Promise((resolve, reject) => {\n      const parsedUri = this.parse(uri);\n      const expectedGenesis = parsedUri.genesis_hash;\n      const expectedBlock = parsedUri.block_hash;\n      this.getBlockByNumber(\"0x0\", provider, (err, _ref3) => {\n        let {\n          result\n        } = _ref3;\n        if (err) return reject(err);\n        const block = result;\n        if (block.hash !== expectedGenesis) return resolve(false);\n        this.getBlockByHash(expectedBlock, provider, (err, _ref4) => {\n          let {\n            result\n          } = _ref4;\n          // Treat an error as if the block didn't exist. This is because\n          // some clients respond differently.\n          const block = result;\n\n          if (err || block == null) {\n            return resolve(false);\n          }\n\n          resolve(true);\n        });\n      });\n    });\n  }\n\n};\nmodule.exports = Blockchain;","map":{"version":3,"sources":["../index.ts"],"names":[],"mappings":";;AAGA,MAAM,UAAU,GAAG;AACjB,EAAA,gBAAgB,CACd,WADc,EAEd,QAFc,EAGd,QAHc,EAGqB;AAEnC,UAAM,MAAM,GAAG,CAAC,WAAD,EAAc,IAAd,CAAf;AACA,IAAA,QAAQ,CAAC,IAAT,CACE;AACE,MAAA,OAAO,EAAE,KADX;AAEE,MAAA,MAAM,EAAE,sBAFV;AAGE,MAAA,MAHF;AAIE,MAAA,EAAE,EAAE,IAAI,CAAC,GAAL;AAJN,KADF,EAOE,QAPF;AASD,GAhBgB;;AAkBjB,EAAA,cAAc,CACZ,SADY,EAEZ,QAFY,EAGZ,QAHY,EAGuB;AAEnC,UAAM,MAAM,GAAG,CAAC,SAAD,EAAY,IAAZ,CAAf;AACA,IAAA,QAAQ,CAAC,IAAT,CACE;AACE,MAAA,OAAO,EAAE,KADX;AAEE,MAAA,MAAM,EAAE,oBAFV;AAGE,MAAA,MAHF;AAIE,MAAA,EAAE,EAAE,IAAI,CAAC,GAAL;AAJN,KADF,EAOE,QAPF;AASD,GAjCgB;;AAmCjB,EAAA,KAAK,CAAC,GAAD,EAAY;AACf,UAAM,MAAM,GAAoB,EAAhC;AACA,QAAI,GAAG,CAAC,OAAJ,CAAY,eAAZ,MAAiC,CAArC,EAAwC,OAAO,MAAP;AAExC,UAAM,QAAQ,GAAG,GAAG,CAAC,OAAJ,CAAY,eAAZ,EAA6B,EAA7B,CAAjB;AAEA,UAAM,MAAM,GAAG,QAAQ,CAAC,KAAT,CAAe,SAAf,CAAf;AAEA,IAAA,MAAM,CAAC,YAAP,GAAsB,KAAK,MAAM,CAAC,CAAD,CAAG,EAApC;AACA,IAAA,MAAM,CAAC,UAAP,GAAoB,KAAK,MAAM,CAAC,CAAD,CAAG,EAAlC;AAEA,WAAO,MAAP;AACD,GA/CgB;;AAiDjB,EAAA,KAAK,CAAC,QAAD,EAAmB;AACtB,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACrC,UAAI,OAAJ,EAAkB,MAAlB;AAEA,WAAK,gBAAL,CACE,KADF,EAEE,QAFF,EAGE,CAAC,GAAD,WAA4C;AAAA,YAA/B;AAAE,UAAA;AAAF,SAA+B;AAC1C,YAAI,GAAJ,EAAS,OAAO,MAAM,CAAC,GAAD,CAAb;AACT,QAAA,OAAO,GAAG,MAAV;AAEA,aAAK,gBAAL,CACE,QADF,EAEE,QAFF,EAGE,CAAC,GAAD,YAA4C;AAAA,cAA/B;AAAE,YAAA;AAAF,WAA+B;AAC1C,cAAI,GAAJ,EAAS,OAAO,MAAM,CAAC,GAAD,CAAb;AACT,UAAA,MAAM,GAAG,MAAT;AACA,gBAAM,GAAG,GAAG,gBAAgB,OAAO,CAAC,IAAR,CAAa,OAAb,CAC1B,IAD0B,EAE1B,EAF0B,CAG3B,UAAU,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAoB,IAApB,EAA0B,EAA1B,CAA6B,EAHxC;AAIA,UAAA,OAAO,CAAC,GAAD,CAAP;AACD,SAXH;AAaD,OApBH;AAsBD,KAzBM,CAAP;AA0BD,GA5EgB;;AA8EjB,EAAA,OAAO,CAAC,GAAD,EAAc,QAAd,EAAgC;AACrC,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACrC,YAAM,SAAS,GAAG,KAAK,KAAL,CAAW,GAAX,CAAlB;AAEA,YAAM,eAAe,GAAG,SAAS,CAAC,YAAlC;AACA,YAAM,aAAa,GAAG,SAAS,CAAC,UAAhC;AAEA,WAAK,gBAAL,CACE,KADF,EAEE,QAFF,EAGE,CAAC,GAAD,YAA4C;AAAA,YAA/B;AAAE,UAAA;AAAF,SAA+B;AAC1C,YAAI,GAAJ,EAAS,OAAO,MAAM,CAAC,GAAD,CAAb;AACT,cAAM,KAAK,GAAG,MAAd;AACA,YAAI,KAAK,CAAC,IAAN,KAAe,eAAnB,EAAoC,OAAO,OAAO,CAAC,KAAD,CAAd;AAEpC,aAAK,cAAL,CACE,aADF,EAEE,QAFF,EAGE,CAAC,GAAD,YAA4C;AAAA,cAA/B;AAAE,YAAA;AAAF,WAA+B;AAC1C;AACA;AACA,gBAAM,KAAK,GAAG,MAAd;;AACA,cAAI,GAAG,IAAI,KAAK,IAAI,IAApB,EAA0B;AACxB,mBAAO,OAAO,CAAC,KAAD,CAAd;AACD;;AAED,UAAA,OAAO,CAAC,IAAD,CAAP;AACD,SAZH;AAcD,OAtBH;AAwBD,KA9BM,CAAP;AA+BD;;AA9GgB,CAAnB;AAiHA,MAAA,CAAA,OAAA,GAAS,UAAT","sourceRoot":"","sourcesContent":["\"use strict\";\nconst Blockchain = {\n    getBlockByNumber(blockNumber, provider, callback) {\n        const params = [blockNumber, true];\n        provider.send({\n            jsonrpc: \"2.0\",\n            method: \"eth_getBlockByNumber\",\n            params,\n            id: Date.now()\n        }, callback);\n    },\n    getBlockByHash(blockHash, provider, callback) {\n        const params = [blockHash, true];\n        provider.send({\n            jsonrpc: \"2.0\",\n            method: \"eth_getBlockByHash\",\n            params,\n            id: Date.now()\n        }, callback);\n    },\n    parse(uri) {\n        const parsed = {};\n        if (uri.indexOf(\"blockchain://\") !== 0)\n            return parsed;\n        const cleanUri = uri.replace(\"blockchain://\", \"\");\n        const pieces = cleanUri.split(\"/block/\");\n        parsed.genesis_hash = `0x${pieces[0]}`;\n        parsed.block_hash = `0x${pieces[1]}`;\n        return parsed;\n    },\n    asURI(provider) {\n        return new Promise((resolve, reject) => {\n            let genesis, latest;\n            this.getBlockByNumber(\"0x0\", provider, (err, { result }) => {\n                if (err)\n                    return reject(err);\n                genesis = result;\n                this.getBlockByNumber(\"latest\", provider, (err, { result }) => {\n                    if (err)\n                        return reject(err);\n                    latest = result;\n                    const url = `blockchain://${genesis.hash.replace(\"0x\", \"\")}/block/${latest.hash.replace(\"0x\", \"\")}`;\n                    resolve(url);\n                });\n            });\n        });\n    },\n    matches(uri, provider) {\n        return new Promise((resolve, reject) => {\n            const parsedUri = this.parse(uri);\n            const expectedGenesis = parsedUri.genesis_hash;\n            const expectedBlock = parsedUri.block_hash;\n            this.getBlockByNumber(\"0x0\", provider, (err, { result }) => {\n                if (err)\n                    return reject(err);\n                const block = result;\n                if (block.hash !== expectedGenesis)\n                    return resolve(false);\n                this.getBlockByHash(expectedBlock, provider, (err, { result }) => {\n                    // Treat an error as if the block didn't exist. This is because\n                    // some clients respond differently.\n                    const block = result;\n                    if (err || block == null) {\n                        return resolve(false);\n                    }\n                    resolve(true);\n                });\n            });\n        });\n    }\n};\nmodule.exports = Blockchain;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}