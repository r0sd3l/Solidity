{"ast":null,"code":"/**\n * Methods to fetch and decode reason string from ganache when a tx errors.\n */\nconst reason = {\n  /**\n   * Extracts a reason string from `eth_call` response\n   * @param  {Object}           res  response from `eth_call` to extract reason\n   * @param  {Web3}             web3 a helpful friend\n   * @param  {InterfaceAdapter}      interfaceAdapter a new helpful friend\n   * @return {String|Undefined}      decoded reason string\n   */\n  _extract: function (res, web3, _interfaceAdapter) {\n    //I'm not sure why interfaceAdapter is here if it's not used,\n    //so I just put an underscore in front of its name for now...\n    if (!res || !res.error && !res.result) return;\n    const errorStringHash = \"0x08c379a0\";\n    const isObject = res && typeof res === \"object\" && res.error && res.error.data;\n    const isString = res && typeof res === \"object\" && typeof res.result === \"string\";\n\n    if (isObject) {\n      // NOTE that Ganache >=2 returns the reason string when\n      // vmErrorsOnRPCResponse === true, which this code could\n      // be updated to respect (instead of computing here)\n      const data = res.error.data;\n      let resData;\n\n      if (typeof data === \"string\") {\n        resData = data; // geth, Ganache >7.0.0\n      } else if (\"result\" in data) {\n        // there is a single result (Ganache 7.0.0)\n        resData = data.result;\n      } else {\n        // handle `evm_mine`, `miner_start`, batch payloads, and ganache 2.0\n        // NOTE this only works for a single failed transaction at a time.\n        const hash = Object.keys(data)[0];\n        const errorDetails = data[hash];\n        resData = errorDetails.return\n        /* ganache 2.0 */\n        ;\n      }\n\n      if (resData && resData.includes(errorStringHash)) {\n        try {\n          return web3.eth.abi.decodeParameter(\"string\", resData.slice(10));\n        } catch (_) {\n          return undefined;\n        }\n      }\n    } else if (isString && res.result.includes(errorStringHash)) {\n      try {\n        return web3.eth.abi.decodeParameter(\"string\", res.result.slice(10));\n      } catch (_) {\n        return undefined;\n      }\n    }\n  },\n\n  /**\n   * Runs tx via `eth_call` and resolves a reason string if it exists on the response.\n   * @param  {Object} web3\n   * @param  {Object} interfaceAdapter\n   * @return {String|Undefined}\n   */\n  get: function (params, web3, interfaceAdapter) {\n    const packet = {\n      jsonrpc: \"2.0\",\n      method: \"eth_call\",\n      params: [params, \"latest\"],\n      id: new Date().getTime()\n    };\n    return new Promise(resolve => {\n      web3.currentProvider.send(packet, (err, response) => {\n        const reasonString = reason._extract(response, web3, interfaceAdapter);\n\n        resolve(reasonString);\n      });\n    });\n  }\n};\nmodule.exports = reason;","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/@truffle/contract/lib/reason.js"],"names":["reason","_extract","res","web3","_interfaceAdapter","error","result","errorStringHash","isObject","data","isString","resData","hash","Object","keys","errorDetails","return","includes","eth","abi","decodeParameter","slice","_","undefined","get","params","interfaceAdapter","packet","jsonrpc","method","id","Date","getTime","Promise","resolve","currentProvider","send","err","response","reasonString","module","exports"],"mappings":"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","sourcesContent":["/**\n * Methods to fetch and decode reason string from ganache when a tx errors.\n */\n\nconst reason = {\n  /**\n   * Extracts a reason string from `eth_call` response\n   * @param  {Object}           res  response from `eth_call` to extract reason\n   * @param  {Web3}             web3 a helpful friend\n   * @param  {InterfaceAdapter}      interfaceAdapter a new helpful friend\n   * @return {String|Undefined}      decoded reason string\n   */\n  _extract: function (res, web3, _interfaceAdapter) {\n    //I'm not sure why interfaceAdapter is here if it's not used,\n    //so I just put an underscore in front of its name for now...\n    if (!res || (!res.error && !res.result)) return;\n\n    const errorStringHash = \"0x08c379a0\";\n\n    const isObject =\n      res && typeof res === \"object\" && res.error && res.error.data;\n    const isString =\n      res && typeof res === \"object\" && typeof res.result === \"string\";\n\n    if (isObject) {\n      // NOTE that Ganache >=2 returns the reason string when\n      // vmErrorsOnRPCResponse === true, which this code could\n      // be updated to respect (instead of computing here)\n      const data = res.error.data;\n      let resData;\n      if (typeof data === \"string\") {\n        resData = data; // geth, Ganache >7.0.0\n      } else if (\"result\" in data) {\n        // there is a single result (Ganache 7.0.0)\n        resData = data.result;\n      } else {\n        // handle `evm_mine`, `miner_start`, batch payloads, and ganache 2.0\n        // NOTE this only works for a single failed transaction at a time.\n        const hash = Object.keys(data)[0];\n        const errorDetails = data[hash];\n        resData = errorDetails.return /* ganache 2.0 */;\n      }\n\n      if (resData && resData.includes(errorStringHash)) {\n        try {\n          return web3.eth.abi.decodeParameter(\"string\", resData.slice(10));\n        } catch (_) {\n          return undefined;\n        }\n      }\n    } else if (isString && res.result.includes(errorStringHash)) {\n      try {\n        return web3.eth.abi.decodeParameter(\"string\", res.result.slice(10));\n      } catch (_) {\n        return undefined;\n      }\n    }\n  },\n\n  /**\n   * Runs tx via `eth_call` and resolves a reason string if it exists on the response.\n   * @param  {Object} web3\n   * @param  {Object} interfaceAdapter\n   * @return {String|Undefined}\n   */\n  get: function (params, web3, interfaceAdapter) {\n    const packet = {\n      jsonrpc: \"2.0\",\n      method: \"eth_call\",\n      params: [params, \"latest\"],\n      id: new Date().getTime()\n    };\n\n    return new Promise(resolve => {\n      web3.currentProvider.send(packet, (err, response) => {\n        const reasonString = reason._extract(response, web3, interfaceAdapter);\n        resolve(reasonString);\n      });\n    });\n  }\n};\n\nmodule.exports = reason;\n"]},"metadata":{},"sourceType":"script"}