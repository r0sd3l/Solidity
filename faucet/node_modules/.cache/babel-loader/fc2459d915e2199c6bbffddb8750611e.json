{"ast":null,"code":"export function indexToMappedConstantMapperFor(entries) {\n  return function indexToMappedConstantMapper(choiceIndex) {\n    let idx = -1;\n    let numSkips = 0;\n\n    while (choiceIndex >= numSkips) {\n      numSkips += entries[++idx].num;\n    }\n\n    return entries[idx].build(choiceIndex - numSkips + entries[idx].num);\n  };\n}\n\nfunction buildReverseMapping(entries) {\n  const reverseMapping = {\n    mapping: new Map(),\n    negativeZeroIndex: undefined\n  };\n  let choiceIndex = 0;\n\n  for (let entryIdx = 0; entryIdx !== entries.length; ++entryIdx) {\n    const entry = entries[entryIdx];\n\n    for (let idxInEntry = 0; idxInEntry !== entry.num; ++idxInEntry) {\n      const value = entry.build(idxInEntry);\n\n      if (value === 0 && 1 / value === Number.NEGATIVE_INFINITY) {\n        reverseMapping.negativeZeroIndex = choiceIndex;\n      } else {\n        reverseMapping.mapping.set(value, choiceIndex);\n      }\n\n      ++choiceIndex;\n    }\n  }\n\n  return reverseMapping;\n}\n\nexport function indexToMappedConstantUnmapperFor(entries) {\n  let reverseMapping = null;\n  return function indexToMappedConstantUnmapper(value) {\n    if (reverseMapping === null) {\n      reverseMapping = buildReverseMapping(entries);\n    }\n\n    const choiceIndex = Object.is(value, -0) ? reverseMapping.negativeZeroIndex : reverseMapping.mapping.get(value);\n\n    if (choiceIndex === undefined) {\n      throw new Error('Unknown value encountered cannot be built using this mapToConstant');\n    }\n\n    return choiceIndex;\n  };\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToMappedConstant.js"],"names":["indexToMappedConstantMapperFor","entries","indexToMappedConstantMapper","choiceIndex","idx","numSkips","num","build","buildReverseMapping","reverseMapping","mapping","Map","negativeZeroIndex","undefined","entryIdx","length","entry","idxInEntry","value","Number","NEGATIVE_INFINITY","set","indexToMappedConstantUnmapperFor","indexToMappedConstantUnmapper","Object","is","get","Error"],"mappings":"AAAA,OAAO,SAASA,8BAAT,CAAwCC,OAAxC,EAAiD;AACpD,SAAO,SAASC,2BAAT,CAAqCC,WAArC,EAAkD;AACrD,QAAIC,GAAG,GAAG,CAAC,CAAX;AACA,QAAIC,QAAQ,GAAG,CAAf;;AACA,WAAOF,WAAW,IAAIE,QAAtB,EAAgC;AAC5BA,MAAAA,QAAQ,IAAIJ,OAAO,CAAC,EAAEG,GAAH,CAAP,CAAeE,GAA3B;AACH;;AACD,WAAOL,OAAO,CAACG,GAAD,CAAP,CAAaG,KAAb,CAAmBJ,WAAW,GAAGE,QAAd,GAAyBJ,OAAO,CAACG,GAAD,CAAP,CAAaE,GAAzD,CAAP;AACH,GAPD;AAQH;;AACD,SAASE,mBAAT,CAA6BP,OAA7B,EAAsC;AAClC,QAAMQ,cAAc,GAAG;AAAEC,IAAAA,OAAO,EAAE,IAAIC,GAAJ,EAAX;AAAsBC,IAAAA,iBAAiB,EAAEC;AAAzC,GAAvB;AACA,MAAIV,WAAW,GAAG,CAAlB;;AACA,OAAK,IAAIW,QAAQ,GAAG,CAApB,EAAuBA,QAAQ,KAAKb,OAAO,CAACc,MAA5C,EAAoD,EAAED,QAAtD,EAAgE;AAC5D,UAAME,KAAK,GAAGf,OAAO,CAACa,QAAD,CAArB;;AACA,SAAK,IAAIG,UAAU,GAAG,CAAtB,EAAyBA,UAAU,KAAKD,KAAK,CAACV,GAA9C,EAAmD,EAAEW,UAArD,EAAiE;AAC7D,YAAMC,KAAK,GAAGF,KAAK,CAACT,KAAN,CAAYU,UAAZ,CAAd;;AACA,UAAIC,KAAK,KAAK,CAAV,IAAe,IAAIA,KAAJ,KAAcC,MAAM,CAACC,iBAAxC,EAA2D;AACvDX,QAAAA,cAAc,CAACG,iBAAf,GAAmCT,WAAnC;AACH,OAFD,MAGK;AACDM,QAAAA,cAAc,CAACC,OAAf,CAAuBW,GAAvB,CAA2BH,KAA3B,EAAkCf,WAAlC;AACH;;AACD,QAAEA,WAAF;AACH;AACJ;;AACD,SAAOM,cAAP;AACH;;AACD,OAAO,SAASa,gCAAT,CAA0CrB,OAA1C,EAAmD;AACtD,MAAIQ,cAAc,GAAG,IAArB;AACA,SAAO,SAASc,6BAAT,CAAuCL,KAAvC,EAA8C;AACjD,QAAIT,cAAc,KAAK,IAAvB,EAA6B;AACzBA,MAAAA,cAAc,GAAGD,mBAAmB,CAACP,OAAD,CAApC;AACH;;AACD,UAAME,WAAW,GAAGqB,MAAM,CAACC,EAAP,CAAUP,KAAV,EAAiB,CAAC,CAAlB,IAAuBT,cAAc,CAACG,iBAAtC,GAA0DH,cAAc,CAACC,OAAf,CAAuBgB,GAAvB,CAA2BR,KAA3B,CAA9E;;AACA,QAAIf,WAAW,KAAKU,SAApB,EAA+B;AAC3B,YAAM,IAAIc,KAAJ,CAAU,oEAAV,CAAN;AACH;;AACD,WAAOxB,WAAP;AACH,GATD;AAUH","sourcesContent":["export function indexToMappedConstantMapperFor(entries) {\n    return function indexToMappedConstantMapper(choiceIndex) {\n        let idx = -1;\n        let numSkips = 0;\n        while (choiceIndex >= numSkips) {\n            numSkips += entries[++idx].num;\n        }\n        return entries[idx].build(choiceIndex - numSkips + entries[idx].num);\n    };\n}\nfunction buildReverseMapping(entries) {\n    const reverseMapping = { mapping: new Map(), negativeZeroIndex: undefined };\n    let choiceIndex = 0;\n    for (let entryIdx = 0; entryIdx !== entries.length; ++entryIdx) {\n        const entry = entries[entryIdx];\n        for (let idxInEntry = 0; idxInEntry !== entry.num; ++idxInEntry) {\n            const value = entry.build(idxInEntry);\n            if (value === 0 && 1 / value === Number.NEGATIVE_INFINITY) {\n                reverseMapping.negativeZeroIndex = choiceIndex;\n            }\n            else {\n                reverseMapping.mapping.set(value, choiceIndex);\n            }\n            ++choiceIndex;\n        }\n    }\n    return reverseMapping;\n}\nexport function indexToMappedConstantUnmapperFor(entries) {\n    let reverseMapping = null;\n    return function indexToMappedConstantUnmapper(value) {\n        if (reverseMapping === null) {\n            reverseMapping = buildReverseMapping(entries);\n        }\n        const choiceIndex = Object.is(value, -0) ? reverseMapping.negativeZeroIndex : reverseMapping.mapping.get(value);\n        if (choiceIndex === undefined) {\n            throw new Error('Unknown value encountered cannot be built using this mapToConstant');\n        }\n        return choiceIndex;\n    };\n}\n"]},"metadata":{},"sourceType":"module"}