{"ast":null,"code":"const ansiRegex = require('ansi-regex');\n\nconst superSplit = require('super-split');\n\nconst arrayUniq = require('array-uniq');\n\nconst stripAnsi = require('strip-ansi');\n\nconst realignOutOfBoundsCoords = (text, opts) => {\n  const plain = stripAnsi(text);\n  const lines = plain.split('\\n');\n  const totalLines = lines.length; // 'End.line marker out of bounds (max).'\n\n  if (opts.end.line > totalLines) {\n    opts.end.line = totalLines;\n  } // 'Start.line marker out of bounds (min).'\n\n\n  if (opts.start.line < 1) {\n    opts.start.line = 1;\n  } // 'Start.column marker out of bounds (min).'\n\n\n  if (opts.start.column < 1) {\n    opts.start.column = 1;\n  } // 'End.column marker out of bounds (max).'\n\n\n  if (opts.end.column > lines[opts.end.line - 1].length) {\n    opts.end.column = lines[opts.end.line - 1].length;\n  }\n\n  if (opts.start.line > opts.end.line) {\n    throw new Error('Your start line is after your end line.');\n  }\n\n  if (opts.start.line === opts.end.line && opts.end.column < opts.start.column) {\n    throw new Error('Your end column is after your start column.');\n  }\n\n  return false;\n}; // Returns arys:\n// 1 - ANSI Escape sequences from section\n// 2 - Glyphs in section (ansi escape seq - or - ascii character)\n\n\nconst atomize = section => {\n  const ansies = arrayUniq(section.match(ansiRegex()));\n  const words = superSplit(section, ansies);\n  let glyphs = [];\n  words.forEach(word => {\n    if (ansies.includes(word) === false) {\n      glyphs = glyphs.concat(word.split(''));\n      return;\n    }\n\n    glyphs.push(word);\n  });\n  return {\n    ansies,\n    glyphs\n  };\n};\n\nconst markSection = (section, opts, linear) => {\n  const {\n    ansies,\n    glyphs\n  } = atomize(section);\n  let x = 0;\n  let y = 0;\n  let inPoint;\n  let outPoint;\n  let output = '';\n  const height = opts.end.line - opts.start.line;\n\n  const markNotBegun = () => {\n    return typeof inPoint !== 'number' && typeof outPoint !== 'number';\n  };\n\n  const markHasEnded = () => {\n    return typeof inPoint === 'number' && typeof outPoint === 'number';\n  };\n\n  const outsideOfMark = () => {\n    return markNotBegun() || markHasEnded();\n  };\n\n  glyphs.forEach(glyph => {\n    if (ansies.includes(glyph) === false) {\n      if (glyph === '\\n' && !linear) {\n        y += 1;\n        x = -1;\n      }\n\n      x += 1;\n\n      if (x === opts.start.column && y === 0) {\n        inPoint = output.length;\n      }\n\n      output += glyph;\n\n      if (x === opts.end.column && y === height) {\n        outPoint = output.length;\n      }\n\n      return;\n    }\n\n    if (outsideOfMark()) {\n      output += glyph;\n    } else if (!outsideOfMark() && !opts.resetColor) {\n      output += glyph;\n    }\n  });\n  const pre = output.substr(0, inPoint);\n  const mark = opts.color(output.substr(inPoint, outPoint - inPoint));\n  const post = output.substr(outPoint);\n  const sectionMarked = pre + mark + post;\n  return sectionMarked;\n};\n\nconst mark2d = (text, opts) => {\n  realignOutOfBoundsCoords(text, opts);\n  const lines = text.split('\\n'); // Minus 1: because line and column numbers start at 1\n\n  const startLine = opts.start.line - 1;\n  const endLine = opts.end.line - 1; // Plus 1: because slice does not include the end indice\n\n  const unmarkedSection = lines.slice(startLine, endLine + 1).join('\\n');\n  const preSection = lines.slice(0, startLine);\n  const markedSection = markSection(unmarkedSection, opts);\n  const postSection = lines.slice(endLine + 1);\n  const result = preSection.concat([markedSection]).concat(postSection).join('\\n');\n  return result;\n};\n\nconst mark1d = (text, opts, linear) => {\n  const markedSection = markSection(text, opts, linear);\n  return markedSection;\n};\n\nconst mark = (text, opts, linear) => {\n  return linear ? mark1d(text, opts, linear) : mark2d(text, opts);\n};\n\nconst validMarkersNumbers = opts => {\n  return typeof opts.start === 'number' && typeof opts.end === 'number';\n};\n\nconst validMarkersObject = opts => {\n  return typeof opts.start === 'object' && typeof opts.end === 'object' && typeof opts.start.line === 'number' && typeof opts.start.column === 'number' && typeof opts.end.line === 'number' && typeof opts.end.column === 'number';\n};\n\nconst ansiMark = (text, opts) => {\n  if (validMarkersObject(opts)) {\n    return mark(text, opts);\n  }\n\n  if (validMarkersNumbers(opts)) {\n    opts.start = {\n      line: 1,\n      column: opts.start\n    };\n    opts.end = {\n      line: 1,\n      column: opts.end\n    };\n    const linear = true;\n    return mark(text, opts, linear);\n  }\n\n  throw new Error('Invalid marker definition.');\n};\n\nmodule.exports = ansiMark;","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/ansi-mark/index.js"],"names":["ansiRegex","require","superSplit","arrayUniq","stripAnsi","realignOutOfBoundsCoords","text","opts","plain","lines","split","totalLines","length","end","line","start","column","Error","atomize","section","ansies","match","words","glyphs","forEach","word","includes","concat","push","markSection","linear","x","y","inPoint","outPoint","output","height","markNotBegun","markHasEnded","outsideOfMark","glyph","resetColor","pre","substr","mark","color","post","sectionMarked","mark2d","startLine","endLine","unmarkedSection","slice","join","preSection","markedSection","postSection","result","mark1d","validMarkersNumbers","validMarkersObject","ansiMark","module","exports"],"mappings":"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","sourcesContent":["const ansiRegex = require('ansi-regex')\nconst superSplit = require('super-split')\nconst arrayUniq = require('array-uniq')\nconst stripAnsi = require('strip-ansi')\n\nconst realignOutOfBoundsCoords = (text, opts) => {\n\tconst plain = stripAnsi(text)\n\tconst lines = plain.split('\\n')\n\tconst totalLines = lines.length\n\n\t// 'End.line marker out of bounds (max).'\n\tif (opts.end.line > totalLines) {\n\t\topts.end.line = totalLines\n\t}\n\n\t// 'Start.line marker out of bounds (min).'\n\tif (opts.start.line < 1) {\n\t\topts.start.line = 1\n\t}\n\n\t// 'Start.column marker out of bounds (min).'\n\tif (opts.start.column < 1) {\n\t\topts.start.column = 1\n\t}\n\n\t// 'End.column marker out of bounds (max).'\n\tif (opts.end.column > lines[opts.end.line - 1].length) {\n\t\topts.end.column = lines[opts.end.line - 1].length\n\t}\n\n\tif (opts.start.line > opts.end.line) {\n\t\tthrow new Error('Your start line is after your end line.')\n\t}\n\n\tif (opts.start.line === opts.end.line &&\n\t\topts.end.column < opts.start.column) {\n\t\tthrow new Error('Your end column is after your start column.')\n\t}\n\n\treturn false\n}\n\n// Returns arys:\n// 1 - ANSI Escape sequences from section\n// 2 - Glyphs in section (ansi escape seq - or - ascii character)\nconst atomize = section => {\n\tconst ansies = arrayUniq(section.match(ansiRegex()))\n\tconst words = superSplit(section, ansies)\n\n\tlet glyphs = []\n\twords.forEach(word => {\n\t\tif (ansies.includes(word) === false) {\n\t\t\tglyphs = glyphs.concat(word.split(''))\n\t\t\treturn\n\t\t}\n\t\tglyphs.push(word)\n\t})\n\n\treturn {ansies, glyphs}\n}\n\nconst markSection = (section, opts, linear) => {\n\tconst {ansies, glyphs} = atomize(section)\n\n\tlet x = 0\n\tlet y = 0\n\tlet inPoint\n\tlet outPoint\n\tlet output = ''\n\tconst height = opts.end.line - opts.start.line\n\n\tconst markNotBegun = () => {\n\t\treturn typeof inPoint !== 'number' &&\n\t\t\ttypeof outPoint !== 'number'\n\t}\n\n\tconst markHasEnded = () => {\n\t\treturn typeof inPoint === 'number' &&\n\t\t\ttypeof outPoint === 'number'\n\t}\n\n\tconst outsideOfMark = () => {\n\t\treturn markNotBegun() || markHasEnded()\n\t}\n\n\tglyphs.forEach(glyph => {\n\t\tif (ansies.includes(glyph) === false) {\n\t\t\tif (glyph === '\\n' && !linear) {\n\t\t\t\ty += 1\n\t\t\t\tx = -1\n\t\t\t}\n\n\t\t\tx += 1\n\n\t\t\tif (x === opts.start.column && y === 0) {\n\t\t\t\tinPoint = output.length\n\t\t\t}\n\n\t\t\toutput += glyph\n\n\t\t\tif (x === opts.end.column && y === height) {\n\t\t\t\toutPoint = output.length\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif (outsideOfMark()) {\n\t\t\toutput += glyph\n\t\t} else if (!outsideOfMark() && !opts.resetColor) {\n\t\t\toutput += glyph\n\t\t}\n\t})\n\n\tconst pre = output.substr(0, inPoint)\n\tconst mark = opts.color(output.substr(inPoint, outPoint - inPoint))\n\tconst post = output.substr(outPoint)\n\tconst sectionMarked = pre + mark + post\n\n\treturn sectionMarked\n}\n\nconst mark2d = (text, opts) => {\n\trealignOutOfBoundsCoords(text, opts)\n\n\tconst lines = text.split('\\n')\n\n\t// Minus 1: because line and column numbers start at 1\n\tconst startLine = opts.start.line - 1\n\tconst endLine = opts.end.line - 1\n\n\t// Plus 1: because slice does not include the end indice\n\tconst unmarkedSection = lines.slice(startLine, endLine + 1).join('\\n')\n\n\tconst preSection = lines.slice(0, startLine)\n\tconst markedSection = markSection(unmarkedSection, opts)\n\tconst postSection = lines.slice(endLine + 1)\n\n\tconst result = preSection.concat([markedSection]).concat(postSection).join('\\n')\n\treturn result\n}\n\nconst mark1d = (text, opts, linear) => {\n\tconst markedSection = markSection(text, opts, linear)\n\treturn markedSection\n}\n\nconst mark = (text, opts, linear) => {\n\treturn linear ? mark1d(text, opts, linear) : mark2d(text, opts)\n}\n\nconst validMarkersNumbers = opts => {\n\treturn typeof opts.start === 'number' &&\n\t\ttypeof opts.end === 'number'\n}\n\nconst validMarkersObject = opts => {\n\treturn typeof opts.start === 'object' &&\n\t\ttypeof opts.end === 'object' &&\n\t\ttypeof opts.start.line === 'number' &&\n\t\ttypeof opts.start.column === 'number' &&\n\t\ttypeof opts.end.line === 'number' &&\n\t\ttypeof opts.end.column === 'number'\n}\n\nconst ansiMark = (text, opts) => {\n\tif (validMarkersObject(opts)) {\n\t\treturn mark(text, opts)\n\t}\n\n\tif (validMarkersNumbers(opts)) {\n\t\topts.start = {line: 1, column: opts.start}\n\t\topts.end = {line: 1, column: opts.end}\n\t\tconst linear = true\n\t\treturn mark(text, opts, linear)\n\t}\n\n\tthrow new Error('Invalid marker definition.')\n}\n\nmodule.exports = ansiMark\n"]},"metadata":{},"sourceType":"script"}