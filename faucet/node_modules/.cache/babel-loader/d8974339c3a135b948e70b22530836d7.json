{"ast":null,"code":"const debug = require(\"debug\")(\"contract:manual-send\");\n\nconst ethers = require(\"ethers\");\n\nconst Utils = require(\"./utils\");\n\nconst {\n  formatters\n} = require(\"web3-core-helpers\"); //used for reproducing web3's behavior\n//this is less manual now, it uses ethers, whew\n//(it's still more manual than using web3)\n\n\nasync function sendTransactionManual(web3, params, promiEvent) {\n  debug(\"executing manually!\"); //set up ethers provider\n\n  const ethersProvider = new ethers.providers.Web3Provider(web3.currentProvider); //let's clone params and set it up properly\n\n  const {\n    transaction,\n    from\n  } = setUpParameters(params, web3); //now: if the from address is in the wallet, web3 will sign the transaction before\n  //sending, so we have to account for that\n\n  const account = web3.eth.accounts.wallet[from];\n  const ethersSigner = account ? new ethers.Wallet(account.privateKey, ethersProvider) : ethersProvider.getSigner(from);\n  debug(\"got signer\");\n  let txHash, receipt, ethersResponse;\n\n  try {\n    //note: the following code won't work with ethers v5.\n    //wth ethers v5, in the getSigner() case, you'll need to\n    //use sendUncheckedTransaction instead of sendTransaction.\n    //I don't know why.\n    ethersResponse = await ethersSigner.sendTransaction(transaction);\n    txHash = ethersResponse.hash;\n    receipt = await ethersProvider.waitForTransaction(txHash);\n    debug(\"no error\");\n  } catch (error) {\n    ({\n      txHash,\n      receipt\n    } = handleError(error));\n\n    if (!receipt) {\n      receipt = await ethersProvider.waitForTransaction(txHash);\n    }\n  }\n\n  debug(\"txHash: %s\", txHash);\n  receipt = translateReceipt(receipt);\n  promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@\n\n  return await handleResult(receipt, transaction.to == null);\n}\n\nfunction handleError(error) {\n  debug(\"error: %O\", error);\n\n  if (error.data && error.data.hash) {\n    //ganache v7.x\n    return {\n      txHash: error.data.hash\n    };\n  } else if (error.data && Object.keys(error.data).length === 3) {\n    //ganache v2.x\n    //error.data will have 3 keys: stack, name, and the txHash\n    const transactionHash = Object.keys(error.data).find(key => key !== \"stack\" && key !== \"name\");\n    return {\n      txHash: transactionHash\n    };\n  } else if (error.transactionHash && error.receipt) {\n    return {\n      txHash: error.transactionHash,\n      receipt: error.receipt\n    };\n  } else {\n    throw error; //rethrow unexpected errors\n  }\n}\n\nasync function handleResult(receipt, isDeployment) {\n  const deploymentFailedMessage = \"The contract code couldn't be stored, please check your gas limit.\";\n\n  if (receipt.status) {\n    if (isDeployment) {\n      //in the deployment case, web3 might error even when technically successful @_@\n      if ((await web3.eth.getCode(receipt.contractAddress)) === \"0x\") {\n        throw new Error(deploymentFailedMessage);\n      }\n    }\n\n    return receipt;\n  } else {\n    //otherwise: we have to mimic web3's errors @_@\n    if (isDeployment) {\n      //deployment case\n      throw new Error(deploymentFailedMessage);\n    }\n\n    throw new Error(\"Transaction has been reverted by the EVM:\" + \"\\n\" + JSON.stringify(receipt));\n  }\n}\n\nfunction setUpParameters(params, web3) {\n  let transaction = Object.assign({}, params);\n  transaction.from = transaction.from != undefined ? transaction.from : web3.eth.defaultAccount; //now let's have web3 check our inputs\n\n  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn\n  //...but ethers uses gasLimit instead of gas like web3\n\n  transaction.gasLimit = transaction.gas;\n  delete transaction.gas; //also, it insists \"from\" be kept separate\n\n  const {\n    from\n  } = transaction;\n  delete transaction.from;\n  return {\n    transaction,\n    from\n  };\n} //translate the receipt to web3 format by converting BigNumbers\n//(note: these are *ethers* BigNumbers) to numbers\n\n\nfunction translateReceipt(receipt) {\n  return Object.assign({}, ...Object.entries(receipt).map(_ref => {\n    let [key, value] = _ref;\n    return {\n      [key]: Utils.is_big_number(value) ? value.toNumber() : value\n    };\n  }));\n}\n\nmodule.exports = {\n  sendTransactionManual\n};","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/@truffle/contract/lib/manual-send.js"],"names":["debug","require","ethers","Utils","formatters","sendTransactionManual","web3","params","promiEvent","ethersProvider","providers","Web3Provider","currentProvider","transaction","from","setUpParameters","account","eth","accounts","wallet","ethersSigner","Wallet","privateKey","getSigner","txHash","receipt","ethersResponse","sendTransaction","hash","waitForTransaction","error","handleError","translateReceipt","setTransactionHash","handleResult","to","data","Object","keys","length","transactionHash","find","key","isDeployment","deploymentFailedMessage","status","getCode","contractAddress","Error","JSON","stringify","assign","undefined","defaultAccount","inputTransactionFormatter","gasLimit","gas","entries","map","value","is_big_number","toNumber","module","exports"],"mappings":"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","sourcesContent":["const debug = require(\"debug\")(\"contract:manual-send\");\nconst ethers = require(\"ethers\");\nconst Utils = require (\"./utils\");\nconst { formatters } = require(\"web3-core-helpers\"); //used for reproducing web3's behavior\n\n//this is less manual now, it uses ethers, whew\n//(it's still more manual than using web3)\nasync function sendTransactionManual(web3, params, promiEvent) {\n  debug(\"executing manually!\");\n  //set up ethers provider\n  const ethersProvider = new ethers.providers.Web3Provider(\n    web3.currentProvider\n  );\n  //let's clone params and set it up properly\n  const { transaction, from } = setUpParameters(params, web3);\n  //now: if the from address is in the wallet, web3 will sign the transaction before\n  //sending, so we have to account for that\n  const account = web3.eth.accounts.wallet[from];\n  const ethersSigner = account\n    ? new ethers.Wallet(account.privateKey, ethersProvider)\n    : ethersProvider.getSigner(from);\n  debug(\"got signer\");\n  let txHash, receipt, ethersResponse;\n  try {\n    //note: the following code won't work with ethers v5.\n    //wth ethers v5, in the getSigner() case, you'll need to\n    //use sendUncheckedTransaction instead of sendTransaction.\n    //I don't know why.\n    ethersResponse = await ethersSigner.sendTransaction(transaction);\n    txHash = ethersResponse.hash;\n    receipt = await ethersProvider.waitForTransaction(txHash);\n    debug(\"no error\");\n  } catch (error) {\n    ({ txHash, receipt } = handleError(error));\n    if (!receipt) {\n      receipt = await ethersProvider.waitForTransaction(txHash);\n    }\n  }\n  debug(\"txHash: %s\", txHash);\n  receipt = translateReceipt(receipt);\n  promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@\n  return await handleResult(receipt, transaction.to == null);\n}\n\nfunction handleError(error) {\n  debug(\"error: %O\", error);\n  if (error.data && error.data.hash) {\n    //ganache v7.x\n    return { txHash: error.data.hash };\n  } else if (error.data && Object.keys(error.data).length === 3) {\n    //ganache v2.x\n    //error.data will have 3 keys: stack, name, and the txHash\n    const transactionHash = Object.keys(error.data).find(\n      key => key !== \"stack\" && key !== \"name\"\n    );\n    return { txHash: transactionHash };\n  } else if (error.transactionHash && error.receipt) {\n    return {\n      txHash: error.transactionHash,\n      receipt: error.receipt\n    };\n  } else {\n    throw error; //rethrow unexpected errors\n  }\n}\n\nasync function handleResult(receipt, isDeployment) {\n  const deploymentFailedMessage = \"The contract code couldn't be stored, please check your gas limit.\";\n  if (receipt.status) {\n    if (isDeployment) {\n      //in the deployment case, web3 might error even when technically successful @_@\n      if ((await web3.eth.getCode(receipt.contractAddress)) === \"0x\") {\n        throw new Error(deploymentFailedMessage);\n      }\n    }\n    return receipt;\n  } else {\n    //otherwise: we have to mimic web3's errors @_@\n    if (isDeployment) {\n      //deployment case\n      throw new Error(deploymentFailedMessage);\n    }\n    throw new Error(\n      \"Transaction has been reverted by the EVM:\" +\n        \"\\n\" +\n        JSON.stringify(receipt)\n    );\n  }\n}\n\nfunction setUpParameters(params, web3) {\n  let transaction = Object.assign({}, params);\n  transaction.from =\n    transaction.from != undefined\n      ? transaction.from\n      : web3.eth.defaultAccount;\n  //now let's have web3 check our inputs\n  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn\n  //...but ethers uses gasLimit instead of gas like web3\n  transaction.gasLimit = transaction.gas;\n  delete transaction.gas;\n  //also, it insists \"from\" be kept separate\n  const { from } = transaction;\n  delete transaction.from;\n  return { transaction, from }\n}\n\n//translate the receipt to web3 format by converting BigNumbers\n//(note: these are *ethers* BigNumbers) to numbers\nfunction translateReceipt(receipt) {\n  return Object.assign({},\n    ...Object.entries(receipt).map(([key, value]) => ({\n      [key]: Utils.is_big_number(value)\n        ? value.toNumber()\n        : value\n    }))\n  );\n}\n\nmodule.exports = {\n  sendTransactionManual\n}\n"]},"metadata":{},"sourceType":"script"}