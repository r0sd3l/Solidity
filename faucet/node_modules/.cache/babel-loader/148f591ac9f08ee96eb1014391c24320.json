{"ast":null,"code":"export function buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue) {\n  return function valuesAndSeparateKeysToObjectMapper(gs) {\n    const obj = {};\n\n    for (let idx = 0; idx !== keys.length; ++idx) {\n      const valueWrapper = gs[idx];\n\n      if (valueWrapper !== noKeyValue) {\n        obj[keys[idx]] = valueWrapper;\n      }\n    }\n\n    return obj;\n  };\n}\nexport function buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue) {\n  return function valuesAndSeparateKeysToObjectUnmapper(value) {\n    if (typeof value !== 'object' || value === null) {\n      throw new Error('Incompatible instance received: should be a non-null object');\n    }\n\n    if (!('constructor' in value) || value.constructor !== Object) {\n      throw new Error('Incompatible instance received: should be of exact type Object');\n    }\n\n    let extractedPropertiesCount = 0;\n    const extractedValues = [];\n\n    for (let idx = 0; idx !== keys.length; ++idx) {\n      const descriptor = Object.getOwnPropertyDescriptor(value, keys[idx]);\n\n      if (descriptor !== undefined) {\n        if (!descriptor.configurable || !descriptor.enumerable || !descriptor.writable) {\n          throw new Error('Incompatible instance received: should contain only c/e/w properties');\n        }\n\n        if (descriptor.get !== undefined || descriptor.set !== undefined) {\n          throw new Error('Incompatible instance received: should contain only no get/set properties');\n        }\n\n        ++extractedPropertiesCount;\n        extractedValues.push(descriptor.value);\n      } else {\n        extractedValues.push(noKeyValue);\n      }\n    }\n\n    const namePropertiesCount = Object.getOwnPropertyNames(value).length;\n    const symbolPropertiesCount = Object.getOwnPropertySymbols(value).length;\n\n    if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) {\n      throw new Error('Incompatible instance received: should not contain extra properties');\n    }\n\n    return extractedValues;\n  };\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js"],"names":["buildValuesAndSeparateKeysToObjectMapper","keys","noKeyValue","valuesAndSeparateKeysToObjectMapper","gs","obj","idx","length","valueWrapper","buildValuesAndSeparateKeysToObjectUnmapper","valuesAndSeparateKeysToObjectUnmapper","value","Error","constructor","Object","extractedPropertiesCount","extractedValues","descriptor","getOwnPropertyDescriptor","undefined","configurable","enumerable","writable","get","set","push","namePropertiesCount","getOwnPropertyNames","symbolPropertiesCount","getOwnPropertySymbols"],"mappings":"AAAA,OAAO,SAASA,wCAAT,CAAkDC,IAAlD,EAAwDC,UAAxD,EAAoE;AACvE,SAAO,SAASC,mCAAT,CAA6CC,EAA7C,EAAiD;AACpD,UAAMC,GAAG,GAAG,EAAZ;;AACA,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,KAAKL,IAAI,CAACM,MAA/B,EAAuC,EAAED,GAAzC,EAA8C;AAC1C,YAAME,YAAY,GAAGJ,EAAE,CAACE,GAAD,CAAvB;;AACA,UAAIE,YAAY,KAAKN,UAArB,EAAiC;AAC7BG,QAAAA,GAAG,CAACJ,IAAI,CAACK,GAAD,CAAL,CAAH,GAAiBE,YAAjB;AACH;AACJ;;AACD,WAAOH,GAAP;AACH,GATD;AAUH;AACD,OAAO,SAASI,0CAAT,CAAoDR,IAApD,EAA0DC,UAA1D,EAAsE;AACzE,SAAO,SAASQ,qCAAT,CAA+CC,KAA/C,EAAsD;AACzD,QAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;AAC7C,YAAM,IAAIC,KAAJ,CAAU,6DAAV,CAAN;AACH;;AACD,QAAI,EAAE,iBAAiBD,KAAnB,KAA6BA,KAAK,CAACE,WAAN,KAAsBC,MAAvD,EAA+D;AAC3D,YAAM,IAAIF,KAAJ,CAAU,gEAAV,CAAN;AACH;;AACD,QAAIG,wBAAwB,GAAG,CAA/B;AACA,UAAMC,eAAe,GAAG,EAAxB;;AACA,SAAK,IAAIV,GAAG,GAAG,CAAf,EAAkBA,GAAG,KAAKL,IAAI,CAACM,MAA/B,EAAuC,EAAED,GAAzC,EAA8C;AAC1C,YAAMW,UAAU,GAAGH,MAAM,CAACI,wBAAP,CAAgCP,KAAhC,EAAuCV,IAAI,CAACK,GAAD,CAA3C,CAAnB;;AACA,UAAIW,UAAU,KAAKE,SAAnB,EAA8B;AAC1B,YAAI,CAACF,UAAU,CAACG,YAAZ,IAA4B,CAACH,UAAU,CAACI,UAAxC,IAAsD,CAACJ,UAAU,CAACK,QAAtE,EAAgF;AAC5E,gBAAM,IAAIV,KAAJ,CAAU,sEAAV,CAAN;AACH;;AACD,YAAIK,UAAU,CAACM,GAAX,KAAmBJ,SAAnB,IAAgCF,UAAU,CAACO,GAAX,KAAmBL,SAAvD,EAAkE;AAC9D,gBAAM,IAAIP,KAAJ,CAAU,2EAAV,CAAN;AACH;;AACD,UAAEG,wBAAF;AACAC,QAAAA,eAAe,CAACS,IAAhB,CAAqBR,UAAU,CAACN,KAAhC;AACH,OATD,MAUK;AACDK,QAAAA,eAAe,CAACS,IAAhB,CAAqBvB,UAArB;AACH;AACJ;;AACD,UAAMwB,mBAAmB,GAAGZ,MAAM,CAACa,mBAAP,CAA2BhB,KAA3B,EAAkCJ,MAA9D;AACA,UAAMqB,qBAAqB,GAAGd,MAAM,CAACe,qBAAP,CAA6BlB,KAA7B,EAAoCJ,MAAlE;;AACA,QAAIQ,wBAAwB,KAAKW,mBAAmB,GAAGE,qBAAvD,EAA8E;AAC1E,YAAM,IAAIhB,KAAJ,CAAU,qEAAV,CAAN;AACH;;AACD,WAAOI,eAAP;AACH,GA/BD;AAgCH","sourcesContent":["export function buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue) {\n    return function valuesAndSeparateKeysToObjectMapper(gs) {\n        const obj = {};\n        for (let idx = 0; idx !== keys.length; ++idx) {\n            const valueWrapper = gs[idx];\n            if (valueWrapper !== noKeyValue) {\n                obj[keys[idx]] = valueWrapper;\n            }\n        }\n        return obj;\n    };\n}\nexport function buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue) {\n    return function valuesAndSeparateKeysToObjectUnmapper(value) {\n        if (typeof value !== 'object' || value === null) {\n            throw new Error('Incompatible instance received: should be a non-null object');\n        }\n        if (!('constructor' in value) || value.constructor !== Object) {\n            throw new Error('Incompatible instance received: should be of exact type Object');\n        }\n        let extractedPropertiesCount = 0;\n        const extractedValues = [];\n        for (let idx = 0; idx !== keys.length; ++idx) {\n            const descriptor = Object.getOwnPropertyDescriptor(value, keys[idx]);\n            if (descriptor !== undefined) {\n                if (!descriptor.configurable || !descriptor.enumerable || !descriptor.writable) {\n                    throw new Error('Incompatible instance received: should contain only c/e/w properties');\n                }\n                if (descriptor.get !== undefined || descriptor.set !== undefined) {\n                    throw new Error('Incompatible instance received: should contain only no get/set properties');\n                }\n                ++extractedPropertiesCount;\n                extractedValues.push(descriptor.value);\n            }\n            else {\n                extractedValues.push(noKeyValue);\n            }\n        }\n        const namePropertiesCount = Object.getOwnPropertyNames(value).length;\n        const symbolPropertiesCount = Object.getOwnPropertySymbols(value).length;\n        if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) {\n            throw new Error('Incompatible instance received: should not contain extra properties');\n        }\n        return extractedValues;\n    };\n}\n"]},"metadata":{},"sourceType":"module"}