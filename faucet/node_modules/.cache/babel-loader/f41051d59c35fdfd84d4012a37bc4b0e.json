{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nativizeEventArgs = exports.nativizeReturn = exports.nativize = exports.unsafeNativize = exports.ResultInspector = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:export\");\n\nconst Conversion = __importStar(require(\"./conversion\"));\n\nconst inspect_1 = require(\"./format/utils/inspect\");\n\nObject.defineProperty(exports, \"ResultInspector\", {\n  enumerable: true,\n  get: function () {\n    return inspect_1.ResultInspector;\n  }\n});\nObject.defineProperty(exports, \"unsafeNativize\", {\n  enumerable: true,\n  get: function () {\n    return inspect_1.unsafeNativize;\n  }\n});\n/**\n * This function is similar to\n * [[Format.Utils.Inspect.unsafeNativize|unsafeNativize]], but is intended to\n * be safe, and also allows for different output formats.  The only currently\n * supported format is \"ethers\", which is intended to match the way that\n * Truffle Contract currently returns values (based on the Ethers decoder).  As\n * such, it only handles ABI types, and in addition does not handle the types\n * fixed, ufixed, or function.  Note that in these cases it returns `undefined`\n * rather than throwing, as we want this function to be used in contexts where\n * it had better not throw.  It also does not handle circularities, for similar\n * reasons.\n *\n * To handle numeric types, this function takes an optional numberFormatter\n * option that tells it how to handle numbers; this function should take a\n * BigInt as input.  By default, this function will be the identity, and so\n * numbers will be represented as BigInts.\n *\n * Note that this function begins by calling abify, so out-of-range enums (that\n * aren't so out-of-range as to be padding errors) will not return `undefined`.\n * Out-of-range booleans similarly will return true rather than `undefined`.\n * However, other range errors may return `undefined`; this may technically be a\n * slight incompatibility with existing behavior, but should not be relevant\n * except in quite unusual cases.\n *\n * In order to match the behavior for tuples, tuples will be transformed into\n * arrays, but named entries will additionally be keyed by name.  Moreover,\n * indexed variables of reference type will be nativized to an undecoded hex\n * string.\n */\n\nfunction nativize(result) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativize(result, numberFormatter);\n  }\n}\n\nexports.nativize = nativize;\n\nfunction ethersCompatibleNativize(result) {\n  let numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n\n  //note: the original version of this function began by calling abify,\n  //but we don't do that here because abify requires a userDefinedTypes\n  //parameter and we don't want that.\n  //However, it only needs that to handle getting the types right.  Since\n  //we don't care about that here, we instead do away with abify and handle\n  //such matters ourselves (which is less convenient, yeah).\n  switch (result.kind) {\n    case \"error\":\n      switch (result.error.kind) {\n        case \"IndexedReferenceTypeError\":\n          //strictly speaking for arrays ethers will fail to decode\n          //rather than do this, but, eh\n          return result.error.raw;\n\n        case \"EnumOutOfRangeError\":\n          return numberFormatter(Conversion.toBigInt(result.error.rawAsBN));\n\n        default:\n          return undefined;\n      }\n\n    case \"value\":\n      switch (result.type.typeClass) {\n        case \"uint\":\n        case \"int\":\n          const asBN = result.value.asBN;\n          return numberFormatter(Conversion.toBigInt(asBN));\n\n        case \"enum\":\n          const numericAsBN = result.value.numericAsBN;\n          return numberFormatter(Conversion.toBigInt(numericAsBN));\n\n        case \"bool\":\n          return result.value.asBoolean;\n\n        case \"bytes\":\n          const asHex = result.value.asHex;\n          return asHex !== \"0x\" ? asHex : null;\n\n        case \"address\":\n          return result.value.asAddress;\n\n        case \"contract\":\n          return result.value.address;\n\n        case \"string\":\n          {\n            const coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"valid\":\n                return coercedResult.value.asString;\n\n              case \"malformed\":\n                // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n                // note we need to cut off the 0x prefix\n                return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n            }\n          }\n\n        case \"userDefinedValueType\":\n          return ethersCompatibleNativize(result.value, numberFormatter);\n\n        case \"array\":\n          return result.value.map(value => ethersCompatibleNativize(value, numberFormatter));\n\n        case \"tuple\":\n        case \"struct\":\n          //in this case, we need the result to be an array, but also\n          //to have the field names (where extant) as keys\n          const nativized = [];\n          const pairs = result.value;\n\n          for (const {\n            name,\n            value\n          } of pairs) {\n            const nativizedValue = ethersCompatibleNativize(value, numberFormatter);\n            nativized.push(nativizedValue);\n\n            if (name) {\n              nativized[name] = nativizedValue;\n            }\n          }\n\n          return nativized;\n\n        case \"function\":\n          switch (result.type.visibility) {\n            case \"external\":\n              const coercedResult = result; //ethers per se doesn't handle this, but web3's hacked version will\n              //sometimes decode these as just a bytes24, so let's do that\n\n              return coercedResult.value.contract.address.toLowerCase() + coercedResult.value.selector.slice(2);\n\n            case \"internal\":\n              return undefined;\n          }\n\n        case \"fixed\":\n        case \"ufixed\":\n        default:\n          return undefined;\n      }\n\n  }\n}\n/**\n * This function is similar to [[nativize]], but takes\n * a [[ReturndataDecoding]].  If there's only one returned value, it\n * will be run through compatibleNativize but otherwise unaltered;\n * otherwise the results will be put in an object.\n *\n * Note that if the ReturndataDecoding is not a [[ReturnDecoding]],\n * this will just return `undefined`.\n */\n\n\nfunction nativizeReturn(decoding) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativizeReturn(decoding, numberFormatter);\n  }\n}\n\nexports.nativizeReturn = nativizeReturn;\n\nfunction ethersCompatibleNativizeReturn(decoding) {\n  let numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n\n  if (decoding.kind !== \"return\") {\n    return undefined;\n  }\n\n  if (decoding.arguments.length === 1) {\n    return ethersCompatibleNativize(decoding.arguments[0].value, numberFormatter);\n  }\n\n  const result = {};\n\n  for (let i = 0; i < decoding.arguments.length; i++) {\n    const {\n      name,\n      value\n    } = decoding.arguments[i];\n    const nativized = ethersCompatibleNativize(value, numberFormatter);\n    result[i] = nativized;\n\n    if (name) {\n      result[name] = nativized;\n    }\n  }\n\n  return result;\n}\n/**\n * This function is similar to [[compatibleNativize]], but takes\n * a [[LogDecoding]], and puts the results in an object.  Note\n * that this does not return the entire event info, but just the\n * `args` for the event.\n */\n\n\nfunction nativizeEventArgs(decoding) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativizeEventArgs(decoding, numberFormatter);\n  }\n}\n\nexports.nativizeEventArgs = nativizeEventArgs;\n\nfunction ethersCompatibleNativizeEventArgs(decoding) {\n  let numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n  const result = {};\n\n  for (let i = 0; i < decoding.arguments.length; i++) {\n    const {\n      name,\n      value\n    } = decoding.arguments[i];\n    const nativized = ethersCompatibleNativize(value, numberFormatter);\n    result[i] = nativized;\n\n    if (name) {\n      result[name] = nativized;\n    }\n  } //note: if you have an argument named __length__, what ethers\n  //actually does is... weird.  we're just going to do this instead,\n  //which is simpler and probably more useful, even if it's not strictly\n  //the same (I *seriously* doubt anyone was relying on the old behavior,\n  //because it's, uh, not very useful)\n\n\n  result.__length__ = decoding.arguments.length;\n  return result;\n}","map":{"version":3,"sources":["../../lib/export.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.nativizeEventArgs = exports.nativizeReturn = exports.nativize = exports.unsafeNativize = exports.ResultInspector = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:export\");\nconst Conversion = __importStar(require(\"./conversion\"));\nconst inspect_1 = require(\"./format/utils/inspect\");\nObject.defineProperty(exports, \"ResultInspector\", { enumerable: true, get: function () { return inspect_1.ResultInspector; } });\nObject.defineProperty(exports, \"unsafeNativize\", { enumerable: true, get: function () { return inspect_1.unsafeNativize; } });\n/**\n * This function is similar to\n * [[Format.Utils.Inspect.unsafeNativize|unsafeNativize]], but is intended to\n * be safe, and also allows for different output formats.  The only currently\n * supported format is \"ethers\", which is intended to match the way that\n * Truffle Contract currently returns values (based on the Ethers decoder).  As\n * such, it only handles ABI types, and in addition does not handle the types\n * fixed, ufixed, or function.  Note that in these cases it returns `undefined`\n * rather than throwing, as we want this function to be used in contexts where\n * it had better not throw.  It also does not handle circularities, for similar\n * reasons.\n *\n * To handle numeric types, this function takes an optional numberFormatter\n * option that tells it how to handle numbers; this function should take a\n * BigInt as input.  By default, this function will be the identity, and so\n * numbers will be represented as BigInts.\n *\n * Note that this function begins by calling abify, so out-of-range enums (that\n * aren't so out-of-range as to be padding errors) will not return `undefined`.\n * Out-of-range booleans similarly will return true rather than `undefined`.\n * However, other range errors may return `undefined`; this may technically be a\n * slight incompatibility with existing behavior, but should not be relevant\n * except in quite unusual cases.\n *\n * In order to match the behavior for tuples, tuples will be transformed into\n * arrays, but named entries will additionally be keyed by name.  Moreover,\n * indexed variables of reference type will be nativized to an undecoded hex\n * string.\n */\nfunction nativize(result, options = {}) {\n    const numberFormatter = options.numberFormatter || (x => x);\n    const format = options.format || \"ethers\";\n    switch (format) {\n        case \"ethers\":\n            return ethersCompatibleNativize(result, numberFormatter);\n    }\n}\nexports.nativize = nativize;\nfunction ethersCompatibleNativize(result, numberFormatter = x => x) {\n    //note: the original version of this function began by calling abify,\n    //but we don't do that here because abify requires a userDefinedTypes\n    //parameter and we don't want that.\n    //However, it only needs that to handle getting the types right.  Since\n    //we don't care about that here, we instead do away with abify and handle\n    //such matters ourselves (which is less convenient, yeah).\n    switch (result.kind) {\n        case \"error\":\n            switch (result.error.kind) {\n                case \"IndexedReferenceTypeError\":\n                    //strictly speaking for arrays ethers will fail to decode\n                    //rather than do this, but, eh\n                    return result.error.raw;\n                case \"EnumOutOfRangeError\":\n                    return numberFormatter(Conversion.toBigInt(result.error.rawAsBN));\n                default:\n                    return undefined;\n            }\n        case \"value\":\n            switch (result.type.typeClass) {\n                case \"uint\":\n                case \"int\":\n                    const asBN = (result).value.asBN;\n                    return numberFormatter(Conversion.toBigInt(asBN));\n                case \"enum\":\n                    const numericAsBN = (result).value.numericAsBN;\n                    return numberFormatter(Conversion.toBigInt(numericAsBN));\n                case \"bool\":\n                    return result.value.asBoolean;\n                case \"bytes\":\n                    const asHex = result.value.asHex;\n                    return asHex !== \"0x\" ? asHex : null;\n                case \"address\":\n                    return result.value.asAddress;\n                case \"contract\":\n                    return result.value.address;\n                case \"string\": {\n                    const coercedResult = result;\n                    switch (coercedResult.value.kind) {\n                        case \"valid\":\n                            return coercedResult.value.asString;\n                        case \"malformed\":\n                            // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n                            // note we need to cut off the 0x prefix\n                            return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n                    }\n                }\n                case \"userDefinedValueType\":\n                    return ethersCompatibleNativize(result.value, numberFormatter);\n                case \"array\":\n                    return result.value.map(value => ethersCompatibleNativize(value, numberFormatter));\n                case \"tuple\":\n                case \"struct\":\n                    //in this case, we need the result to be an array, but also\n                    //to have the field names (where extant) as keys\n                    const nativized = [];\n                    const pairs = result.value;\n                    for (const { name, value } of pairs) {\n                        const nativizedValue = ethersCompatibleNativize(value, numberFormatter);\n                        nativized.push(nativizedValue);\n                        if (name) {\n                            nativized[name] = nativizedValue;\n                        }\n                    }\n                    return nativized;\n                case \"function\":\n                    switch (result.type.visibility) {\n                        case \"external\":\n                            const coercedResult = result;\n                            //ethers per se doesn't handle this, but web3's hacked version will\n                            //sometimes decode these as just a bytes24, so let's do that\n                            return coercedResult.value.contract.address.toLowerCase() +\n                                coercedResult.value.selector.slice(2);\n                        case \"internal\":\n                            return undefined;\n                    }\n                case \"fixed\":\n                case \"ufixed\":\n                default:\n                    return undefined;\n            }\n    }\n}\n/**\n * This function is similar to [[nativize]], but takes\n * a [[ReturndataDecoding]].  If there's only one returned value, it\n * will be run through compatibleNativize but otherwise unaltered;\n * otherwise the results will be put in an object.\n *\n * Note that if the ReturndataDecoding is not a [[ReturnDecoding]],\n * this will just return `undefined`.\n */\nfunction nativizeReturn(decoding, options = {}) {\n    const numberFormatter = options.numberFormatter || (x => x);\n    const format = options.format || \"ethers\";\n    switch (format) {\n        case \"ethers\":\n            return ethersCompatibleNativizeReturn(decoding, numberFormatter);\n    }\n}\nexports.nativizeReturn = nativizeReturn;\nfunction ethersCompatibleNativizeReturn(decoding, numberFormatter = x => x) {\n    if (decoding.kind !== \"return\") {\n        return undefined;\n    }\n    if (decoding.arguments.length === 1) {\n        return ethersCompatibleNativize(decoding.arguments[0].value, numberFormatter);\n    }\n    const result = {};\n    for (let i = 0; i < decoding.arguments.length; i++) {\n        const { name, value } = decoding.arguments[i];\n        const nativized = ethersCompatibleNativize(value, numberFormatter);\n        result[i] = nativized;\n        if (name) {\n            result[name] = nativized;\n        }\n    }\n    return result;\n}\n/**\n * This function is similar to [[compatibleNativize]], but takes\n * a [[LogDecoding]], and puts the results in an object.  Note\n * that this does not return the entire event info, but just the\n * `args` for the event.\n */\nfunction nativizeEventArgs(decoding, options = {}) {\n    const numberFormatter = options.numberFormatter || (x => x);\n    const format = options.format || \"ethers\";\n    switch (format) {\n        case \"ethers\":\n            return ethersCompatibleNativizeEventArgs(decoding, numberFormatter);\n    }\n}\nexports.nativizeEventArgs = nativizeEventArgs;\nfunction ethersCompatibleNativizeEventArgs(decoding, numberFormatter = x => x) {\n    const result = {};\n    for (let i = 0; i < decoding.arguments.length; i++) {\n        const { name, value } = decoding.arguments[i];\n        const nativized = ethersCompatibleNativize(value, numberFormatter);\n        result[i] = nativized;\n        if (name) {\n            result[name] = nativized;\n        }\n    }\n    //note: if you have an argument named __length__, what ethers\n    //actually does is... weird.  we're just going to do this instead,\n    //which is simpler and probably more useful, even if it's not strictly\n    //the same (I *seriously* doubt anyone was relying on the old behavior,\n    //because it's, uh, not very useful)\n    result.__length__ = decoding.arguments.length;\n    return result;\n}\n//# sourceMappingURL=export.js.map"]},"metadata":{},"sourceType":"script"}