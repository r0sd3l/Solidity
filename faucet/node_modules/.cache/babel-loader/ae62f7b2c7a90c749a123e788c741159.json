{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:core\");\n\nconst Ast = __importStar(require(\"./ast\"));\n\nconst AbiData = __importStar(require(\"./abi-data\"));\n\nconst Topic = __importStar(require(\"./topic\"));\n\nconst Evm = __importStar(require(\"./evm\"));\n\nconst Contexts = __importStar(require(\"./contexts\"));\n\nconst abify_1 = require(\"./abify\");\n\nconst Conversion = __importStar(require(\"./conversion\"));\n\nconst errors_1 = require(\"./errors\");\n\nconst read_1 = __importDefault(require(\"./read\"));\n\nconst decode_1 = __importDefault(require(\"./decode\")); // untyped import since no @types/web3-utils exists\n\n\nconst Web3Utils = require(\"web3-utils\");\n/**\n * @Category Decoding\n */\n\n\nfunction* decodeVariable(definition, pointer, info, compilationId) {\n  let compiler = info.currentContext.compiler;\n  let dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n  return yield* decode_1.default(dataType, pointer, info); //no need to pass an offset\n}\n\nexports.decodeVariable = decodeVariable;\n/**\n * @Category Decoding\n */\n\nfunction* decodeCalldata(info, isConstructor //ignored if context! trust context instead if have\n) {\n  const context = info.currentContext;\n\n  if (context === null) {\n    //if we don't know the contract ID, we can't decode\n    if (isConstructor) {\n      return {\n        kind: \"create\",\n        decodingMode: \"full\",\n        bytecode: Conversion.toHexString(info.state.calldata)\n      };\n    } else {\n      return {\n        kind: \"unknown\",\n        decodingMode: \"full\",\n        data: Conversion.toHexString(info.state.calldata)\n      };\n    }\n  }\n\n  const contextHash = context.context;\n  const contractType = Contexts.Import.contextToType(context);\n  isConstructor = context.isConstructor;\n  const allocations = info.allocations.calldata;\n  let allocation;\n  let selector; //first: is this a creation call?\n\n  if (isConstructor) {\n    allocation = (allocations.constructorAllocations[contextHash] || {\n      input: undefined\n    }).input;\n  } else {\n    //skipping any error-handling on this read, as a calldata read can't throw anyway\n    let rawSelector = yield* read_1.default({\n      location: \"calldata\",\n      start: 0,\n      length: Evm.Utils.SELECTOR_SIZE\n    }, info.state);\n    selector = Conversion.toHexString(rawSelector);\n    allocation = ((allocations.functionAllocations[contextHash] || {})[selector] || {\n      input: undefined\n    }).input;\n  }\n\n  if (allocation === undefined) {\n    let abiEntry = null;\n\n    if (info.state.calldata.length === 0) {\n      //to hell with reads, let's just be direct\n      abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;\n    } else {\n      abiEntry = context.fallbackAbi.fallback;\n    }\n\n    return {\n      kind: \"message\",\n      class: contractType,\n      abi: abiEntry,\n      data: Conversion.toHexString(info.state.calldata),\n      decodingMode: \"full\"\n    };\n  }\n\n  let decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary\n\n  debug(\"calldata decoding mode: %s\", decodingMode); //you can't map with a generator, so we have to do this map manually\n\n  let decodedArguments = [];\n\n  for (const argumentAllocation of allocation.arguments) {\n    let value;\n    let dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n\n    try {\n      value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n        abiPointerBase: allocation.offset,\n        allowRetry: decodingMode === \"full\"\n      });\n    } catch (error) {\n      if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n        debug(\"problem! retrying as ABI\");\n        debug(\"error: %O\", error); //if a retry happens, we've got to do several things in order to switch to ABI mode:\n        //1. mark that we're switching to ABI mode;\n\n        decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n        decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n          value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n        })); //3. retry this particular decode in ABI mode.\n        //(no try/catch on this one because we can't actually handle errors here!\n        //not that they should be occurring)\n\n        value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n        argumentAllocation.pointer, info, {\n          abiPointerBase: allocation.offset\n        }); //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n        //so we don't need to do anything special there.\n      } else {\n        //we shouldn't be getting other exceptions, but if we do, we don't know\n        //how to handle them, so uhhhh just rethrow I guess??\n        throw error;\n      }\n    }\n\n    const name = argumentAllocation.name;\n    decodedArguments.push(name //deliberate general falsiness test\n    ? {\n      name,\n      value\n    } : {\n      value\n    });\n  }\n\n  if (isConstructor) {\n    return {\n      kind: \"constructor\",\n      class: contractType,\n      arguments: decodedArguments,\n      abi: allocation.abi,\n      bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),\n      decodingMode\n    };\n  } else {\n    return {\n      kind: \"function\",\n      class: contractType,\n      abi: allocation.abi,\n      arguments: decodedArguments,\n      selector,\n      decodingMode\n    };\n  }\n}\n\nexports.decodeCalldata = decodeCalldata;\n/**\n * @Category Decoding\n */\n\nfunction* decodeEvent(info, address) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const allocations = info.allocations.event;\n  const extras = options.extras || \"off\";\n  let rawSelector;\n  let selector;\n  let contractAllocations; //for non-anonymous events\n\n  let libraryAllocations; //similar\n\n  let contractAnonymousAllocations;\n  let libraryAnonymousAllocations;\n  const topicsCount = info.state.eventtopics.length; //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?\n\n  if (allocations[topicsCount]) {\n    if (topicsCount > 0) {\n      rawSelector = yield* read_1.default({\n        location: \"eventtopic\",\n        topic: 0\n      }, info.state);\n      selector = Conversion.toHexString(rawSelector);\n\n      if (allocations[topicsCount].bySelector[selector]) {\n        ({\n          contract: contractAllocations,\n          library: libraryAllocations\n        } = allocations[topicsCount].bySelector[selector]);\n      } else {\n        debug(\"no allocations for that selector!\");\n        contractAllocations = {};\n        libraryAllocations = {};\n      }\n    } else {\n      //if we don't have a selector, it means we don't have any non-anonymous events\n      contractAllocations = {};\n      libraryAllocations = {};\n    } //now: let's get our allocations for anonymous events\n\n\n    ({\n      contract: contractAnonymousAllocations,\n      library: libraryAnonymousAllocations\n    } = allocations[topicsCount].anonymous);\n  } else {\n    //if there's not even an allocation for the topics count, we can't\n    //decode; we could do this the honest way of setting all four allocation\n    //objects to {}, but let's just short circuit\n    debug(\"no allocations for that topic count!\");\n    return [];\n  } //now: what contract are we (probably) dealing with? let's get its code to find out\n\n\n  const codeBytes = yield {\n    type: \"code\",\n    address\n  };\n  const codeAsHex = Conversion.toHexString(codeBytes);\n  const contractContext = Contexts.Utils.findContext(info.contexts, codeAsHex);\n  let possibleContractAllocations; //excludes anonymous events\n\n  let possibleContractAnonymousAllocations;\n  let possibleExtraAllocations; //excludes anonymous events\n\n  let possibleExtraAnonymousAllocations;\n  const emittingContextHash = (contractContext || {\n    context: undefined\n  }).context;\n\n  if (emittingContextHash) {\n    //if we found the contract, maybe it's from that contract\n    const contractAllocation = contractAllocations[emittingContextHash];\n    const contractAnonymousAllocation = contractAnonymousAllocations[emittingContextHash];\n    possibleContractAllocations = contractAllocation || [];\n    possibleContractAnonymousAllocations = contractAnonymousAllocation || []; //also, we need to set up the extras (everything that's from a\n    //non-library contract but *not* this one)\n\n    possibleExtraAllocations = [].concat(...Object.entries(contractAllocations).filter(_ref => {\n      let [key, _] = _ref;\n      return key !== emittingContextHash;\n    }).map(_ref2 => {\n      let [_, value] = _ref2;\n      return value;\n    }));\n    possibleExtraAnonymousAllocations = [].concat(...Object.entries(contractAnonymousAllocations).filter(_ref3 => {\n      let [key, _] = _ref3;\n      return key !== emittingContextHash;\n    }).map(_ref4 => {\n      let [_, value] = _ref4;\n      return value;\n    }));\n  } else {\n    //if we couldn't determine the contract, well, we have to assume it's from a library\n    debug(\"couldn't find context\");\n    possibleContractAllocations = [];\n    possibleContractAnonymousAllocations = []; //or it's an extra, which could be any of the contracts\n\n    possibleExtraAllocations = [].concat(...Object.values(contractAllocations));\n    possibleExtraAnonymousAllocations = [].concat(...Object.values(contractAnonymousAllocations));\n  } //now we get all the library allocations!\n\n\n  const possibleLibraryAllocations = [].concat(...Object.values(libraryAllocations));\n  const possibleLibraryAnonymousAllocations = [].concat(...Object.values(libraryAnonymousAllocations)); //now we put it all together!\n\n  const possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);\n  const possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);\n  const possibleAllocationsTotalMinusExtras = possibleAllocations.concat(possibleAnonymousAllocations); //...and also there's the extras\n\n  const possibleExtraAllocationsTotal = possibleExtraAllocations.concat(possibleExtraAnonymousAllocations);\n  const possibleAllocationsTotal = possibleAllocationsTotalMinusExtras.concat([null], //HACK: add sentinel value before the extras\n  possibleExtraAllocationsTotal); //whew!\n\n  let decodings = [];\n\n  allocationAttempts: for (const allocation of possibleAllocationsTotal) {\n    debug(\"trying allocation: %O\", allocation); //first: check for our sentinel value for extras (yeah, kind of HACKy)\n\n    if (allocation === null) {\n      switch (extras) {\n        case \"on\":\n          continue allocationAttempts;\n        //ignore the sentinel and continue\n\n        case \"off\":\n          break allocationAttempts;\n        //don't include extras; stop here\n\n        case \"necessary\":\n          //stop on the sentinel and exclude extras *unless* there are no decodings yet\n          if (decodings.length > 0) {\n            break allocationAttempts;\n          } else {\n            continue allocationAttempts;\n          }\n\n      }\n    } //second: do a name check so we can skip decoding if name is wrong\n    //(this will likely be a more detailed check in the future)\n\n\n    if (options.name !== undefined && allocation.abi.name !== options.name) {\n      continue;\n    } //now: the main part!\n\n\n    let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n\n    const contextHash = allocation.contextHash;\n    const attemptContext = info.contexts[contextHash];\n    const emittingContractType = Contexts.Import.contextToType(attemptContext);\n    const contractType = allocation.definedIn; //you can't map with a generator, so we have to do this map manually\n\n    let decodedArguments = [];\n\n    for (const argumentAllocation of allocation.arguments) {\n      let value; //if in full mode, use the allocation's listed data type.\n      //if in ABI mode, abify it before use.\n\n      let dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n\n      try {\n        value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n          strictAbiMode: true,\n          allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n\n        });\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n          //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n            value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n          })); //3. retry this particular decode in ABI mode.\n\n          try {\n            value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n            argumentAllocation.pointer, info, {\n              strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n              //retries no longer allowed, not that this has an effect\n\n            });\n          } catch (_) {\n            //if an error occurred on the retry, this isn't a valid decoding!\n            debug(\"rejected due to exception on retry\");\n            continue allocationAttempts;\n          } //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n          //so we don't need to do anything special there.\n\n        } else {\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", error);\n          continue allocationAttempts;\n        }\n      }\n\n      const name = argumentAllocation.name;\n      const indexed = argumentAllocation.pointer.location === \"eventtopic\";\n      decodedArguments.push(name //deliberate general falsiness test\n      ? {\n        name,\n        indexed,\n        value\n      } : {\n        indexed,\n        value\n      });\n    } //OK, so, having decoded the result, the question is: does it reencode to the original?\n    //first, we have to filter out the indexed arguments, and also get rid of the name information\n\n\n    const nonIndexedValues = decodedArguments.filter(argument => !argument.indexed).map(argument => argument.value); //now, we can encode!\n\n    const reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);\n    const encodedData = info.state.eventdata; //again, not great to read this directly, but oh well\n    //are they equal?\n\n    if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n      //if not, this allocation doesn't work\n      debug(\"rejected due to [non-indexed] mismatch\");\n      continue;\n    } //one last check -- let's check that the indexed arguments match up, too\n\n\n    const indexedValues = decodedArguments.filter(argument => argument.indexed).map(argument => argument.value);\n    const reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);\n    const encodedTopics = info.state.eventtopics; //now: do *these* match?\n\n    const selectorAdjustment = allocation.anonymous ? 0 : 1;\n\n    for (let i = 0; i < reEncodedTopics.length; i++) {\n      if (!Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {\n        debug(\"rejected due to indexed mismatch\");\n        continue allocationAttempts;\n      }\n    } //if we've made it here, the allocation works!  hooray!\n\n\n    debug(\"allocation accepted!\");\n    let decoding;\n\n    if (allocation.abi.anonymous) {\n      decoding = {\n        kind: \"anonymous\",\n        definedIn: contractType,\n        class: emittingContractType,\n        abi: allocation.abi,\n        arguments: decodedArguments,\n        decodingMode\n      };\n    } else {\n      decoding = {\n        kind: \"event\",\n        definedIn: contractType,\n        class: emittingContractType,\n        abi: allocation.abi,\n        arguments: decodedArguments,\n        selector,\n        decodingMode\n      };\n    }\n\n    decodings.push(decoding); //if we've made this far (so this allocation works), and we were passed an\n    //ID, and it matches this ID, bail out & return this as the *only* decoding\n\n    if (options.id && allocation.id === options.id) {\n      return [decoding];\n    }\n  }\n\n  return decodings;\n}\n\nexports.decodeEvent = decodeEvent;\nconst errorSelector = Conversion.toBytes(Web3Utils.soliditySha3({\n  type: \"string\",\n  value: \"Error(string)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst panicSelector = Conversion.toBytes(Web3Utils.soliditySha3({\n  type: \"string\",\n  value: \"Panic(uint256)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst defaultRevertAllocations = [{\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: errorSelector,\n  abi: {\n    name: \"Error\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"string\",\n      internalType: \"string\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: errorSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"string\",\n      typeHint: \"string\"\n    }\n  }]\n}, {\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: panicSelector,\n  abi: {\n    name: \"Panic\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"uint256\",\n      internalType: \"uint256\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: panicSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"uint\",\n      bits: Evm.Utils.WORD_SIZE * 8,\n      typeHint: \"uint256\"\n    }\n  }]\n}];\nconst defaultEmptyAllocations = [{\n  kind: \"failure\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}, {\n  kind: \"selfdestruct\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}];\n/**\n * If there are multiple possibilities, they're always returned in\n * the order: return, revert, returnmessage, failure, empty, bytecode, unknownbytecode\n * Moreover, within \"revert\", builtin ones are put above custom ones\n * @Category Decoding\n */\n\nfunction* decodeReturndata(info, successAllocation, //null here must be explicit\nstatus, //you can pass this to indicate that you know the status,\nid //useful when status = false\n) {\n  let possibleAllocations;\n  const selector = Conversion.toHexString(info.state.returndata.slice(0, 4));\n  const contextHash = (info.currentContext || {\n    context: \"\"\n  }).context; //HACK: \"\" is used to represent no context\n\n  const customRevertAllocations = ((info.allocations.returndata || {\n    [contextHash]: {}\n  })[contextHash] || {\n    [selector]: []\n  })[selector] || [];\n\n  if (successAllocation === null) {\n    possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations];\n  } else {\n    switch (successAllocation.kind) {\n      case \"return\":\n        possibleAllocations = [successAllocation, ...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations];\n        break;\n\n      case \"bytecode\":\n        possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations, successAllocation];\n        break;\n\n      case \"returnmessage\":\n        possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, successAllocation, ...defaultEmptyAllocations];\n        break;\n      //Other cases shouldn't happen so I'm leaving them to cause errors!\n    }\n  }\n\n  let decodings = [];\n\n  allocationAttempts: for (const allocation of possibleAllocations) {\n    debug(\"trying allocation: %O\", allocation); //before we attempt to use this allocation, we check: does the selector match?\n\n    let encodedData = info.state.returndata; //again, not great to read this directly, but oh well\n\n    const encodedPrefix = encodedData.subarray(0, allocation.selector.length);\n\n    if (!Evm.Utils.equalData(encodedPrefix, allocation.selector)) {\n      continue;\n    }\n\n    encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later\n    //also we check, does the status match?\n\n    if (status !== undefined) {\n      const successKinds = [\"return\", \"selfdestruct\", \"bytecode\", \"returnmessage\"];\n      const failKinds = [\"failure\", \"revert\"];\n\n      if (status) {\n        if (!successKinds.includes(allocation.kind)) {\n          continue;\n        }\n      } else {\n        if (!failKinds.includes(allocation.kind)) {\n          continue;\n        }\n      }\n    }\n\n    if (allocation.kind === \"bytecode\") {\n      //bytecode is special and can't really be integrated with the other cases.\n      //so it gets its own function.\n      const decoding = yield* decodeBytecode(info);\n\n      if (decoding) {\n        decodings.push(decoding);\n      }\n\n      continue;\n    }\n\n    if (allocation.kind === \"returnmessage\") {\n      //this kind is also special, though thankfully it's easier\n      const decoding = {\n        kind: \"returnmessage\",\n        status: true,\n        data: Conversion.toHexString(info.state.returndata),\n        decodingMode: allocation.allocationMode\n      };\n      decodings.push(decoding);\n      continue;\n    }\n\n    let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n    //you can't map with a generator, so we have to do this map manually\n\n    let decodedArguments = [];\n\n    for (const argumentAllocation of allocation.arguments) {\n      let value; //if in full mode, use the allocation's listed data type.\n      //if in ABI mode, abify it before use.\n\n      let dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes); //now, let's decode!\n\n      try {\n        value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n          abiPointerBase: allocation.selector.length,\n          strictAbiMode: true,\n          allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n\n        });\n        debug(\"value on first try: %O\", value);\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n          debug(\"retry!\"); //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n            value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n          })); //3. retry this particular decode in ABI mode.\n\n          try {\n            value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n            argumentAllocation.pointer, info, {\n              abiPointerBase: allocation.selector.length,\n              strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n              //retries no longer allowed, not that this has an effect\n\n            });\n            debug(\"value on retry: %O\", value);\n          } catch (_) {\n            //if an error occurred on the retry, this isn't a valid decoding!\n            debug(\"rejected due to exception on retry\");\n            continue allocationAttempts;\n          } //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n          //so we don't need to do anything special there.\n\n        } else {\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", error);\n          continue allocationAttempts;\n        }\n      }\n\n      const name = argumentAllocation.name;\n      decodedArguments.push(name //deliberate general falsiness test\n      ? {\n        name,\n        value\n      } : {\n        value\n      });\n    } //OK, so, having decoded the result, the question is: does it reencode to the original?\n    //first, we have to filter out the indexed arguments, and also get rid of the name information\n\n\n    debug(\"decodedArguments: %O\", decodedArguments);\n    const decodedArgumentValues = decodedArguments.map(argument => argument.value);\n    const reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi); //are they equal? note the selector has been stripped off encodedData!\n\n    if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n      //if not, this allocation doesn't work\n      debug(\"rejected due to mismatch\");\n      continue;\n    } //if we've made it here, the allocation works!  hooray!\n\n\n    debug(\"allocation accepted!\");\n    let decoding;\n\n    switch (allocation.kind) {\n      case \"return\":\n        decoding = {\n          kind: \"return\",\n          status: true,\n          arguments: decodedArguments,\n          decodingMode\n        };\n        break;\n\n      case \"revert\":\n        decoding = {\n          kind: \"revert\",\n          abi: allocation.abi,\n          definedIn: allocation.definedIn,\n          status: false,\n          arguments: decodedArguments,\n          decodingMode\n        };\n        break;\n\n      case \"selfdestruct\":\n        decoding = {\n          kind: \"selfdestruct\",\n          status: true,\n          decodingMode\n        };\n        break;\n\n      case \"failure\":\n        decoding = {\n          kind: \"failure\",\n          status: false,\n          decodingMode\n        };\n        break;\n    }\n\n    decodings.push(decoding); //if we've made this far (so this allocation works), and we were passed an\n    //ID, and it matches this ID, bail out & return this as the *only* decoding\n\n    if (id && allocation.kind === \"revert\" && allocation.id === id) {\n      return [decoding];\n    }\n  }\n\n  return decodings;\n}\n\nexports.decodeReturndata = decodeReturndata; //note: requires the bytecode to be in returndata, not code\n\nfunction* decodeBytecode(info) {\n  let decodingMode = \"full\"; //as always, degrade as necessary\n\n  const bytecode = Conversion.toHexString(info.state.returndata);\n  const context = Contexts.Utils.findContext(info.contexts, bytecode);\n\n  if (!context) {\n    return {\n      kind: \"unknownbytecode\",\n      status: true,\n      decodingMode: \"full\",\n      bytecode\n    };\n  }\n\n  const contractType = Contexts.Import.contextToType(context); //now: ignore original allocation (which we didn't even pass :) )\n  //and lookup allocation by context\n\n  const allocation = info.allocations.calldata.constructorAllocations[context.context].output;\n  debug(\"bytecode allocation: %O\", allocation); //now: add immutables if applicable\n\n  let immutables;\n\n  if (allocation.immutables) {\n    immutables = []; //NOTE: if we're in here, we can assume decodingMode === \"full\"\n\n    for (const variable of allocation.immutables) {\n      const dataType = variable.type; //we don't conditioning on decodingMode here because we know it\n\n      let value;\n\n      try {\n        value = yield* decode_1.default(dataType, variable.pointer, info, {\n          allowRetry: true,\n          strictAbiMode: true,\n          paddingMode: \"defaultOrZero\"\n        });\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry) {\n          //we \"retry\" by... not bothering with immutables :P\n          //(but we do set the mode to ABI)\n          decodingMode = \"abi\";\n          immutables = undefined;\n          break;\n        } else {\n          //otherwise, this isn't a valid decoding I guess\n          return null;\n        }\n      }\n\n      immutables.push({\n        name: variable.name,\n        class: variable.definedIn,\n        value\n      });\n    }\n  }\n\n  let decoding = {\n    kind: \"bytecode\",\n    status: true,\n    decodingMode,\n    bytecode,\n    immutables,\n    class: contractType\n  }; //finally: add address if applicable\n\n  if (allocation.delegatecallGuard) {\n    decoding.address = Web3Utils.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = \"0x73\".length\n    );\n  }\n\n  return decoding;\n}\n/**\n * Decodes the return data from a failed call.\n *\n * @param returndata The returned data, as a Uint8Array.\n * @return An array of possible decodings.  At the moment it's\n *   impossible for there to be more than one.  (If the call didn't actually\n *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)\n *\n *   Decodings can either be decodings of revert messages, or decodings\n *   indicating that there was no revert message.  If somehow both were to be\n *   possible, they'd go in that order, although as mentioned, there (at least\n *   currently) isn't any way for that to occur.\n * @Category Decoding convenience\n */\n\n\nfunction decodeRevert(returndata) {\n  //coercing because TS doesn't know it'll finish in one go\n  return decodeReturndata({\n    allocations: {},\n    state: {\n      storage: {},\n      returndata\n    }\n  }, null, false).next().value;\n}\n\nexports.decodeRevert = decodeRevert;","map":{"version":3,"sources":["../../lib/core.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:core\");\nconst Ast = __importStar(require(\"./ast\"));\nconst AbiData = __importStar(require(\"./abi-data\"));\nconst Topic = __importStar(require(\"./topic\"));\nconst Evm = __importStar(require(\"./evm\"));\nconst Contexts = __importStar(require(\"./contexts\"));\nconst abify_1 = require(\"./abify\");\nconst Conversion = __importStar(require(\"./conversion\"));\nconst errors_1 = require(\"./errors\");\nconst read_1 = __importDefault(require(\"./read\"));\nconst decode_1 = __importDefault(require(\"./decode\"));\n// untyped import since no @types/web3-utils exists\nconst Web3Utils = require(\"web3-utils\");\n/**\n * @Category Decoding\n */\nfunction* decodeVariable(definition, pointer, info, compilationId) {\n    let compiler = info.currentContext.compiler;\n    let dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n    return yield* decode_1.default(dataType, pointer, info); //no need to pass an offset\n}\nexports.decodeVariable = decodeVariable;\n/**\n * @Category Decoding\n */\nfunction* decodeCalldata(info, isConstructor //ignored if context! trust context instead if have\n) {\n    const context = info.currentContext;\n    if (context === null) {\n        //if we don't know the contract ID, we can't decode\n        if (isConstructor) {\n            return {\n                kind: \"create\",\n                decodingMode: \"full\",\n                bytecode: Conversion.toHexString(info.state.calldata)\n            };\n        }\n        else {\n            return {\n                kind: \"unknown\",\n                decodingMode: \"full\",\n                data: Conversion.toHexString(info.state.calldata)\n            };\n        }\n    }\n    const contextHash = context.context;\n    const contractType = Contexts.Import.contextToType(context);\n    isConstructor = context.isConstructor;\n    const allocations = info.allocations.calldata;\n    let allocation;\n    let selector;\n    //first: is this a creation call?\n    if (isConstructor) {\n        allocation = (allocations.constructorAllocations[contextHash] || { input: undefined }).input;\n    }\n    else {\n        //skipping any error-handling on this read, as a calldata read can't throw anyway\n        let rawSelector = yield* read_1.default({\n            location: \"calldata\",\n            start: 0,\n            length: Evm.Utils.SELECTOR_SIZE\n        }, info.state);\n        selector = Conversion.toHexString(rawSelector);\n        allocation = ((allocations.functionAllocations[contextHash] || {})[selector] || {\n            input: undefined\n        }).input;\n    }\n    if (allocation === undefined) {\n        let abiEntry = null;\n        if (info.state.calldata.length === 0) {\n            //to hell with reads, let's just be direct\n            abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;\n        }\n        else {\n            abiEntry = context.fallbackAbi.fallback;\n        }\n        return {\n            kind: \"message\",\n            class: contractType,\n            abi: abiEntry,\n            data: Conversion.toHexString(info.state.calldata),\n            decodingMode: \"full\"\n        };\n    }\n    let decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary\n    debug(\"calldata decoding mode: %s\", decodingMode);\n    //you can't map with a generator, so we have to do this map manually\n    let decodedArguments = [];\n    for (const argumentAllocation of allocation.arguments) {\n        let value;\n        let dataType = decodingMode === \"full\"\n            ? argumentAllocation.type\n            : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n        try {\n            value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n                abiPointerBase: allocation.offset,\n                allowRetry: decodingMode === \"full\"\n            });\n        }\n        catch (error) {\n            if (error instanceof errors_1.StopDecodingError &&\n                error.allowRetry &&\n                decodingMode === \"full\") {\n                debug(\"problem! retrying as ABI\");\n                debug(\"error: %O\", error);\n                //if a retry happens, we've got to do several things in order to switch to ABI mode:\n                //1. mark that we're switching to ABI mode;\n                decodingMode = \"abi\";\n                //2. abify all previously decoded values;\n                decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes) })));\n                //3. retry this particular decode in ABI mode.\n                //(no try/catch on this one because we can't actually handle errors here!\n                //not that they should be occurring)\n                value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n                argumentAllocation.pointer, info, {\n                    abiPointerBase: allocation.offset\n                });\n                //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n                //so we don't need to do anything special there.\n            }\n            else {\n                //we shouldn't be getting other exceptions, but if we do, we don't know\n                //how to handle them, so uhhhh just rethrow I guess??\n                throw error;\n            }\n        }\n        const name = argumentAllocation.name;\n        decodedArguments.push(name //deliberate general falsiness test\n            ? { name, value }\n            : { value });\n    }\n    if (isConstructor) {\n        return {\n            kind: \"constructor\",\n            class: contractType,\n            arguments: decodedArguments,\n            abi: allocation.abi,\n            bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),\n            decodingMode\n        };\n    }\n    else {\n        return {\n            kind: \"function\",\n            class: contractType,\n            abi: allocation.abi,\n            arguments: decodedArguments,\n            selector,\n            decodingMode\n        };\n    }\n}\nexports.decodeCalldata = decodeCalldata;\n/**\n * @Category Decoding\n */\nfunction* decodeEvent(info, address, options = {}) {\n    const allocations = info.allocations.event;\n    const extras = options.extras || \"off\";\n    let rawSelector;\n    let selector;\n    let contractAllocations; //for non-anonymous events\n    let libraryAllocations; //similar\n    let contractAnonymousAllocations;\n    let libraryAnonymousAllocations;\n    const topicsCount = info.state.eventtopics.length;\n    //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?\n    if (allocations[topicsCount]) {\n        if (topicsCount > 0) {\n            rawSelector = yield* read_1.default({\n                location: \"eventtopic\",\n                topic: 0\n            }, info.state);\n            selector = Conversion.toHexString(rawSelector);\n            if (allocations[topicsCount].bySelector[selector]) {\n                ({\n                    contract: contractAllocations,\n                    library: libraryAllocations\n                } = allocations[topicsCount].bySelector[selector]);\n            }\n            else {\n                debug(\"no allocations for that selector!\");\n                contractAllocations = {};\n                libraryAllocations = {};\n            }\n        }\n        else {\n            //if we don't have a selector, it means we don't have any non-anonymous events\n            contractAllocations = {};\n            libraryAllocations = {};\n        }\n        //now: let's get our allocations for anonymous events\n        ({\n            contract: contractAnonymousAllocations,\n            library: libraryAnonymousAllocations\n        } = allocations[topicsCount].anonymous);\n    }\n    else {\n        //if there's not even an allocation for the topics count, we can't\n        //decode; we could do this the honest way of setting all four allocation\n        //objects to {}, but let's just short circuit\n        debug(\"no allocations for that topic count!\");\n        return [];\n    }\n    //now: what contract are we (probably) dealing with? let's get its code to find out\n    const codeBytes = yield {\n        type: \"code\",\n        address\n    };\n    const codeAsHex = Conversion.toHexString(codeBytes);\n    const contractContext = Contexts.Utils.findContext(info.contexts, codeAsHex);\n    let possibleContractAllocations; //excludes anonymous events\n    let possibleContractAnonymousAllocations;\n    let possibleExtraAllocations; //excludes anonymous events\n    let possibleExtraAnonymousAllocations;\n    const emittingContextHash = (contractContext || { context: undefined })\n        .context;\n    if (emittingContextHash) {\n        //if we found the contract, maybe it's from that contract\n        const contractAllocation = contractAllocations[emittingContextHash];\n        const contractAnonymousAllocation = contractAnonymousAllocations[emittingContextHash];\n        possibleContractAllocations = contractAllocation || [];\n        possibleContractAnonymousAllocations = contractAnonymousAllocation || [];\n        //also, we need to set up the extras (everything that's from a\n        //non-library contract but *not* this one)\n        possibleExtraAllocations = [].concat(...Object.entries(contractAllocations)\n            .filter(([key, _]) => key !== emittingContextHash)\n            .map(([_, value]) => value));\n        possibleExtraAnonymousAllocations = [].concat(...Object.entries(contractAnonymousAllocations)\n            .filter(([key, _]) => key !== emittingContextHash)\n            .map(([_, value]) => value));\n    }\n    else {\n        //if we couldn't determine the contract, well, we have to assume it's from a library\n        debug(\"couldn't find context\");\n        possibleContractAllocations = [];\n        possibleContractAnonymousAllocations = [];\n        //or it's an extra, which could be any of the contracts\n        possibleExtraAllocations = [].concat(...Object.values(contractAllocations));\n        possibleExtraAnonymousAllocations = [].concat(...Object.values(contractAnonymousAllocations));\n    }\n    //now we get all the library allocations!\n    const possibleLibraryAllocations = [].concat(...Object.values(libraryAllocations));\n    const possibleLibraryAnonymousAllocations = [].concat(...Object.values(libraryAnonymousAllocations));\n    //now we put it all together!\n    const possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);\n    const possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);\n    const possibleAllocationsTotalMinusExtras = possibleAllocations.concat(possibleAnonymousAllocations);\n    //...and also there's the extras\n    const possibleExtraAllocationsTotal = possibleExtraAllocations.concat(possibleExtraAnonymousAllocations);\n    const possibleAllocationsTotal = possibleAllocationsTotalMinusExtras.concat([null], //HACK: add sentinel value before the extras\n    possibleExtraAllocationsTotal);\n    //whew!\n    let decodings = [];\n    allocationAttempts: for (const allocation of possibleAllocationsTotal) {\n        debug(\"trying allocation: %O\", allocation);\n        //first: check for our sentinel value for extras (yeah, kind of HACKy)\n        if (allocation === null) {\n            switch (extras) {\n                case \"on\":\n                    continue allocationAttempts; //ignore the sentinel and continue\n                case \"off\":\n                    break allocationAttempts; //don't include extras; stop here\n                case \"necessary\":\n                    //stop on the sentinel and exclude extras *unless* there are no decodings yet\n                    if (decodings.length > 0) {\n                        break allocationAttempts;\n                    }\n                    else {\n                        continue allocationAttempts;\n                    }\n            }\n        }\n        //second: do a name check so we can skip decoding if name is wrong\n        //(this will likely be a more detailed check in the future)\n        if (options.name !== undefined && allocation.abi.name !== options.name) {\n            continue;\n        }\n        //now: the main part!\n        let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n        const contextHash = allocation.contextHash;\n        const attemptContext = info.contexts[contextHash];\n        const emittingContractType = Contexts.Import.contextToType(attemptContext);\n        const contractType = allocation.definedIn;\n        //you can't map with a generator, so we have to do this map manually\n        let decodedArguments = [];\n        for (const argumentAllocation of allocation.arguments) {\n            let value;\n            //if in full mode, use the allocation's listed data type.\n            //if in ABI mode, abify it before use.\n            let dataType = decodingMode === \"full\"\n                ? argumentAllocation.type\n                : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n            try {\n                value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n                    strictAbiMode: true,\n                    allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n                });\n            }\n            catch (error) {\n                if (error instanceof errors_1.StopDecodingError &&\n                    error.allowRetry &&\n                    decodingMode === \"full\") {\n                    //if a retry happens, we've got to do several things in order to switch to ABI mode:\n                    //1. mark that we're switching to ABI mode;\n                    decodingMode = \"abi\";\n                    //2. abify all previously decoded values;\n                    decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes) })));\n                    //3. retry this particular decode in ABI mode.\n                    try {\n                        value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n                        argumentAllocation.pointer, info, {\n                            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n                            //retries no longer allowed, not that this has an effect\n                        });\n                    }\n                    catch (_) {\n                        //if an error occurred on the retry, this isn't a valid decoding!\n                        debug(\"rejected due to exception on retry\");\n                        continue allocationAttempts;\n                    }\n                    //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n                    //so we don't need to do anything special there.\n                }\n                else {\n                    //if any other sort of error occurred, this isn't a valid decoding!\n                    debug(\"rejected due to exception on first try: %O\", error);\n                    continue allocationAttempts;\n                }\n            }\n            const name = argumentAllocation.name;\n            const indexed = argumentAllocation.pointer.location === \"eventtopic\";\n            decodedArguments.push(name //deliberate general falsiness test\n                ? { name, indexed, value }\n                : { indexed, value });\n        }\n        //OK, so, having decoded the result, the question is: does it reencode to the original?\n        //first, we have to filter out the indexed arguments, and also get rid of the name information\n        const nonIndexedValues = decodedArguments\n            .filter(argument => !argument.indexed)\n            .map(argument => argument.value);\n        //now, we can encode!\n        const reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);\n        const encodedData = info.state.eventdata; //again, not great to read this directly, but oh well\n        //are they equal?\n        if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n            //if not, this allocation doesn't work\n            debug(\"rejected due to [non-indexed] mismatch\");\n            continue;\n        }\n        //one last check -- let's check that the indexed arguments match up, too\n        const indexedValues = decodedArguments\n            .filter(argument => argument.indexed)\n            .map(argument => argument.value);\n        const reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);\n        const encodedTopics = info.state.eventtopics;\n        //now: do *these* match?\n        const selectorAdjustment = allocation.anonymous ? 0 : 1;\n        for (let i = 0; i < reEncodedTopics.length; i++) {\n            if (!Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {\n                debug(\"rejected due to indexed mismatch\");\n                continue allocationAttempts;\n            }\n        }\n        //if we've made it here, the allocation works!  hooray!\n        debug(\"allocation accepted!\");\n        let decoding;\n        if (allocation.abi.anonymous) {\n            decoding = {\n                kind: \"anonymous\",\n                definedIn: contractType,\n                class: emittingContractType,\n                abi: allocation.abi,\n                arguments: decodedArguments,\n                decodingMode\n            };\n        }\n        else {\n            decoding = {\n                kind: \"event\",\n                definedIn: contractType,\n                class: emittingContractType,\n                abi: allocation.abi,\n                arguments: decodedArguments,\n                selector,\n                decodingMode\n            };\n        }\n        decodings.push(decoding);\n        //if we've made this far (so this allocation works), and we were passed an\n        //ID, and it matches this ID, bail out & return this as the *only* decoding\n        if (options.id && allocation.id === options.id) {\n            return [decoding];\n        }\n    }\n    return decodings;\n}\nexports.decodeEvent = decodeEvent;\nconst errorSelector = Conversion.toBytes(Web3Utils.soliditySha3({\n    type: \"string\",\n    value: \"Error(string)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst panicSelector = Conversion.toBytes(Web3Utils.soliditySha3({\n    type: \"string\",\n    value: \"Panic(uint256)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst defaultRevertAllocations = [\n    {\n        kind: \"revert\",\n        allocationMode: \"full\",\n        selector: errorSelector,\n        abi: {\n            name: \"Error\",\n            type: \"error\",\n            inputs: [\n                {\n                    name: \"\",\n                    type: \"string\",\n                    internalType: \"string\"\n                }\n            ]\n        },\n        definedIn: null,\n        arguments: [\n            {\n                name: \"\",\n                pointer: {\n                    location: \"returndata\",\n                    start: errorSelector.length,\n                    length: Evm.Utils.WORD_SIZE\n                },\n                type: {\n                    typeClass: \"string\",\n                    typeHint: \"string\"\n                }\n            }\n        ]\n    },\n    {\n        kind: \"revert\",\n        allocationMode: \"full\",\n        selector: panicSelector,\n        abi: {\n            name: \"Panic\",\n            type: \"error\",\n            inputs: [\n                {\n                    name: \"\",\n                    type: \"uint256\",\n                    internalType: \"uint256\"\n                }\n            ]\n        },\n        definedIn: null,\n        arguments: [\n            {\n                name: \"\",\n                pointer: {\n                    location: \"returndata\",\n                    start: panicSelector.length,\n                    length: Evm.Utils.WORD_SIZE\n                },\n                type: {\n                    typeClass: \"uint\",\n                    bits: Evm.Utils.WORD_SIZE * 8,\n                    typeHint: \"uint256\"\n                }\n            }\n        ]\n    }\n];\nconst defaultEmptyAllocations = [\n    {\n        kind: \"failure\",\n        allocationMode: \"full\",\n        selector: new Uint8Array(),\n        arguments: []\n    },\n    {\n        kind: \"selfdestruct\",\n        allocationMode: \"full\",\n        selector: new Uint8Array(),\n        arguments: []\n    }\n];\n/**\n * If there are multiple possibilities, they're always returned in\n * the order: return, revert, returnmessage, failure, empty, bytecode, unknownbytecode\n * Moreover, within \"revert\", builtin ones are put above custom ones\n * @Category Decoding\n */\nfunction* decodeReturndata(info, successAllocation, //null here must be explicit\nstatus, //you can pass this to indicate that you know the status,\nid //useful when status = false\n) {\n    let possibleAllocations;\n    const selector = Conversion.toHexString(info.state.returndata.slice(0, 4));\n    const contextHash = (info.currentContext || { context: \"\" }).context; //HACK: \"\" is used to represent no context\n    const customRevertAllocations = (((info.allocations.returndata || { [contextHash]: {} })[contextHash]) || { [selector]: [] })[selector] || [];\n    if (successAllocation === null) {\n        possibleAllocations = [\n            ...defaultRevertAllocations,\n            ...customRevertAllocations,\n            ...defaultEmptyAllocations\n        ];\n    }\n    else {\n        switch (successAllocation.kind) {\n            case \"return\":\n                possibleAllocations = [\n                    successAllocation,\n                    ...defaultRevertAllocations,\n                    ...customRevertAllocations,\n                    ...defaultEmptyAllocations\n                ];\n                break;\n            case \"bytecode\":\n                possibleAllocations = [\n                    ...defaultRevertAllocations,\n                    ...customRevertAllocations,\n                    ...defaultEmptyAllocations,\n                    successAllocation\n                ];\n                break;\n            case \"returnmessage\":\n                possibleAllocations = [\n                    ...defaultRevertAllocations,\n                    ...customRevertAllocations,\n                    successAllocation,\n                    ...defaultEmptyAllocations\n                ];\n                break;\n            //Other cases shouldn't happen so I'm leaving them to cause errors!\n        }\n    }\n    let decodings = [];\n    allocationAttempts: for (const allocation of possibleAllocations) {\n        debug(\"trying allocation: %O\", allocation);\n        //before we attempt to use this allocation, we check: does the selector match?\n        let encodedData = info.state.returndata; //again, not great to read this directly, but oh well\n        const encodedPrefix = encodedData.subarray(0, allocation.selector.length);\n        if (!Evm.Utils.equalData(encodedPrefix, allocation.selector)) {\n            continue;\n        }\n        encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later\n        //also we check, does the status match?\n        if (status !== undefined) {\n            const successKinds = [\n                \"return\",\n                \"selfdestruct\",\n                \"bytecode\",\n                \"returnmessage\"\n            ];\n            const failKinds = [\"failure\", \"revert\"];\n            if (status) {\n                if (!successKinds.includes(allocation.kind)) {\n                    continue;\n                }\n            }\n            else {\n                if (!failKinds.includes(allocation.kind)) {\n                    continue;\n                }\n            }\n        }\n        if (allocation.kind === \"bytecode\") {\n            //bytecode is special and can't really be integrated with the other cases.\n            //so it gets its own function.\n            const decoding = yield* decodeBytecode(info);\n            if (decoding) {\n                decodings.push(decoding);\n            }\n            continue;\n        }\n        if (allocation.kind === \"returnmessage\") {\n            //this kind is also special, though thankfully it's easier\n            const decoding = {\n                kind: \"returnmessage\",\n                status: true,\n                data: Conversion.toHexString(info.state.returndata),\n                decodingMode: allocation.allocationMode\n            };\n            decodings.push(decoding);\n            continue;\n        }\n        let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n        //you can't map with a generator, so we have to do this map manually\n        let decodedArguments = [];\n        for (const argumentAllocation of allocation.arguments) {\n            let value;\n            //if in full mode, use the allocation's listed data type.\n            //if in ABI mode, abify it before use.\n            let dataType = decodingMode === \"full\"\n                ? argumentAllocation.type\n                : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n            //now, let's decode!\n            try {\n                value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n                    abiPointerBase: allocation.selector.length,\n                    strictAbiMode: true,\n                    allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n                });\n                debug(\"value on first try: %O\", value);\n            }\n            catch (error) {\n                if (error instanceof errors_1.StopDecodingError &&\n                    error.allowRetry &&\n                    decodingMode === \"full\") {\n                    debug(\"retry!\");\n                    //if a retry happens, we've got to do several things in order to switch to ABI mode:\n                    //1. mark that we're switching to ABI mode;\n                    decodingMode = \"abi\";\n                    //2. abify all previously decoded values;\n                    decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes) })));\n                    //3. retry this particular decode in ABI mode.\n                    try {\n                        value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n                        argumentAllocation.pointer, info, {\n                            abiPointerBase: allocation.selector.length,\n                            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n                            //retries no longer allowed, not that this has an effect\n                        });\n                        debug(\"value on retry: %O\", value);\n                    }\n                    catch (_) {\n                        //if an error occurred on the retry, this isn't a valid decoding!\n                        debug(\"rejected due to exception on retry\");\n                        continue allocationAttempts;\n                    }\n                    //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n                    //so we don't need to do anything special there.\n                }\n                else {\n                    //if any other sort of error occurred, this isn't a valid decoding!\n                    debug(\"rejected due to exception on first try: %O\", error);\n                    continue allocationAttempts;\n                }\n            }\n            const name = argumentAllocation.name;\n            decodedArguments.push(name //deliberate general falsiness test\n                ? { name, value }\n                : { value });\n        }\n        //OK, so, having decoded the result, the question is: does it reencode to the original?\n        //first, we have to filter out the indexed arguments, and also get rid of the name information\n        debug(\"decodedArguments: %O\", decodedArguments);\n        const decodedArgumentValues = decodedArguments.map(argument => argument.value);\n        const reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi);\n        //are they equal? note the selector has been stripped off encodedData!\n        if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n            //if not, this allocation doesn't work\n            debug(\"rejected due to mismatch\");\n            continue;\n        }\n        //if we've made it here, the allocation works!  hooray!\n        debug(\"allocation accepted!\");\n        let decoding;\n        switch (allocation.kind) {\n            case \"return\":\n                decoding = {\n                    kind: \"return\",\n                    status: true,\n                    arguments: decodedArguments,\n                    decodingMode\n                };\n                break;\n            case \"revert\":\n                decoding = {\n                    kind: \"revert\",\n                    abi: allocation.abi,\n                    definedIn: allocation.definedIn,\n                    status: false,\n                    arguments: decodedArguments,\n                    decodingMode\n                };\n                break;\n            case \"selfdestruct\":\n                decoding = {\n                    kind: \"selfdestruct\",\n                    status: true,\n                    decodingMode\n                };\n                break;\n            case \"failure\":\n                decoding = {\n                    kind: \"failure\",\n                    status: false,\n                    decodingMode\n                };\n                break;\n        }\n        decodings.push(decoding);\n        //if we've made this far (so this allocation works), and we were passed an\n        //ID, and it matches this ID, bail out & return this as the *only* decoding\n        if (id && allocation.kind === \"revert\" && allocation.id === id) {\n            return [decoding];\n        }\n    }\n    return decodings;\n}\nexports.decodeReturndata = decodeReturndata;\n//note: requires the bytecode to be in returndata, not code\nfunction* decodeBytecode(info) {\n    let decodingMode = \"full\"; //as always, degrade as necessary\n    const bytecode = Conversion.toHexString(info.state.returndata);\n    const context = Contexts.Utils.findContext(info.contexts, bytecode);\n    if (!context) {\n        return {\n            kind: \"unknownbytecode\",\n            status: true,\n            decodingMode: \"full\",\n            bytecode\n        };\n    }\n    const contractType = Contexts.Import.contextToType(context);\n    //now: ignore original allocation (which we didn't even pass :) )\n    //and lookup allocation by context\n    const allocation = info.allocations.calldata.constructorAllocations[context.context].output;\n    debug(\"bytecode allocation: %O\", allocation);\n    //now: add immutables if applicable\n    let immutables;\n    if (allocation.immutables) {\n        immutables = [];\n        //NOTE: if we're in here, we can assume decodingMode === \"full\"\n        for (const variable of allocation.immutables) {\n            const dataType = variable.type; //we don't conditioning on decodingMode here because we know it\n            let value;\n            try {\n                value = yield* decode_1.default(dataType, variable.pointer, info, {\n                    allowRetry: true,\n                    strictAbiMode: true,\n                    paddingMode: \"defaultOrZero\"\n                });\n            }\n            catch (error) {\n                if (error instanceof errors_1.StopDecodingError && error.allowRetry) {\n                    //we \"retry\" by... not bothering with immutables :P\n                    //(but we do set the mode to ABI)\n                    decodingMode = \"abi\";\n                    immutables = undefined;\n                    break;\n                }\n                else {\n                    //otherwise, this isn't a valid decoding I guess\n                    return null;\n                }\n            }\n            immutables.push({\n                name: variable.name,\n                class: variable.definedIn,\n                value\n            });\n        }\n    }\n    let decoding = {\n        kind: \"bytecode\",\n        status: true,\n        decodingMode,\n        bytecode,\n        immutables,\n        class: contractType\n    };\n    //finally: add address if applicable\n    if (allocation.delegatecallGuard) {\n        decoding.address = Web3Utils.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = \"0x73\".length\n        );\n    }\n    return decoding;\n}\n/**\n * Decodes the return data from a failed call.\n *\n * @param returndata The returned data, as a Uint8Array.\n * @return An array of possible decodings.  At the moment it's\n *   impossible for there to be more than one.  (If the call didn't actually\n *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)\n *\n *   Decodings can either be decodings of revert messages, or decodings\n *   indicating that there was no revert message.  If somehow both were to be\n *   possible, they'd go in that order, although as mentioned, there (at least\n *   currently) isn't any way for that to occur.\n * @Category Decoding convenience\n */\nfunction decodeRevert(returndata) {\n    //coercing because TS doesn't know it'll finish in one go\n    return decodeReturndata({\n        allocations: {},\n        state: {\n            storage: {},\n            returndata\n        }\n    }, null, false).next().value;\n}\nexports.decodeRevert = decodeRevert;\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"script"}