{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readStorage = exports.readSlot = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:storage:read\");\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* readSlot(storage, slot) {\n  const address = Utils.slotAddress(slot); // debug(\"reading slot: %o\", Conversion.toHexString(address));\n\n  const hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);\n  let word = storage[hexAddress]; //if we can't find the word in the map, we place a request to the invoker to supply it\n  //(contract-decoder will look it up from the blockchain, while the debugger will just\n  //say 0)\n\n  if (word === undefined) {\n    word = yield {\n      type: \"storage\",\n      slot: address\n    };\n  }\n\n  return word;\n}\n\nexports.readSlot = readSlot;\n\nfunction* readStorage(pointer, state) {\n  const {\n    storage\n  } = state;\n  const {\n    range\n  } = pointer;\n  debug(\"readRange %o\", range);\n  let {\n    from,\n    to,\n    length\n  } = range;\n  from = {\n    slot: from.slot,\n    index: from.index || 0\n  };\n\n  if (length !== undefined) {\n    to = {\n      slot: {\n        path: from.slot.path || undefined,\n        offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))\n      },\n      index: (from.index + length - 1) % Evm.Utils.WORD_SIZE\n    };\n  }\n\n  debug(\"normalized readRange %o\", {\n    from,\n    to\n  });\n  let totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);\n  let totalWords;\n\n  try {\n    totalWords = totalWordsAsBN.toNumber();\n  } catch (_) {\n    throw new errors_1.DecodingError({\n      kind: \"ReadErrorStorage\",\n      range\n    });\n  }\n\n  let data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);\n\n  for (let i = 0; i < totalWords; i++) {\n    let offset = from.slot.offset.addn(i);\n    const word = yield* readSlot(storage, Object.assign(Object.assign({}, from.slot), {\n      offset\n    }));\n\n    if (typeof word !== \"undefined\") {\n      data.set(word, i * Evm.Utils.WORD_SIZE);\n    }\n  }\n\n  debug(\"words %o\", data);\n  data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);\n  debug(\"data: %o\", data);\n  return data;\n}\n\nexports.readStorage = readStorage;","map":{"version":3,"sources":["../../../../lib/storage/read/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readStorage = exports.readSlot = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:storage:read\");\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction* readSlot(storage, slot) {\n    const address = Utils.slotAddress(slot);\n    // debug(\"reading slot: %o\", Conversion.toHexString(address));\n    const hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);\n    let word = storage[hexAddress];\n    //if we can't find the word in the map, we place a request to the invoker to supply it\n    //(contract-decoder will look it up from the blockchain, while the debugger will just\n    //say 0)\n    if (word === undefined) {\n        word = yield {\n            type: \"storage\",\n            slot: address\n        };\n    }\n    return word;\n}\nexports.readSlot = readSlot;\nfunction* readStorage(pointer, state) {\n    const { storage } = state;\n    const { range } = pointer;\n    debug(\"readRange %o\", range);\n    let { from, to, length } = range;\n    from = {\n        slot: from.slot,\n        index: from.index || 0\n    };\n    if (length !== undefined) {\n        to = {\n            slot: {\n                path: from.slot.path || undefined,\n                offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))\n            },\n            index: (from.index + length - 1) % Evm.Utils.WORD_SIZE\n        };\n    }\n    debug(\"normalized readRange %o\", { from, to });\n    let totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);\n    let totalWords;\n    try {\n        totalWords = totalWordsAsBN.toNumber();\n    }\n    catch (_) {\n        throw new errors_1.DecodingError({\n            kind: \"ReadErrorStorage\",\n            range\n        });\n    }\n    let data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);\n    for (let i = 0; i < totalWords; i++) {\n        let offset = from.slot.offset.addn(i);\n        const word = yield* readSlot(storage, Object.assign(Object.assign({}, from.slot), { offset }));\n        if (typeof word !== \"undefined\") {\n            data.set(word, i * Evm.Utils.WORD_SIZE);\n        }\n    }\n    debug(\"words %o\", data);\n    data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);\n    debug(\"data: %o\", data);\n    return data;\n}\nexports.readStorage = readStorage;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}