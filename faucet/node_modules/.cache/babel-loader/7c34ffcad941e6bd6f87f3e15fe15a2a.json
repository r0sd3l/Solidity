{"ast":null,"code":"var _a;\n\nimport { ArbitraryWithContextualShrink } from './ArbitraryWithContextualShrink.js';\nimport { ConverterToNext } from './ConverterToNext.js';\nimport { Shrinkable } from './Shrinkable.js';\nconst identifier = '__ConverterFromNext__';\n\nfunction fromNextValueToShrinkableFor(arb) {\n  return function fromNextValueToShrinkable(v) {\n    const value_ = v.value_;\n\n    const shrinker = () => arb.shrink(value_, v.context).map(fromNextValueToShrinkable);\n\n    if (!v.hasToBeCloned) {\n      return new Shrinkable(value_, shrinker);\n    }\n\n    return new Shrinkable(value_, shrinker, () => v.value);\n  };\n}\n\nexport class ConverterFromNext extends ArbitraryWithContextualShrink {\n  constructor(arb, legacyShrunkOnceContext) {\n    let biasFactor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    super();\n    this.arb = arb;\n    this.legacyShrunkOnceContext = legacyShrunkOnceContext;\n    this.biasFactor = biasFactor;\n    this[_a] = true;\n    this.toShrinkable = fromNextValueToShrinkableFor(arb);\n  }\n\n  static isConverterFromNext(arb) {\n    return identifier in arb;\n  }\n\n  static convertIfNeeded(arb) {\n    if (ConverterToNext.isConverterToNext(arb)) return arb.arb;else return new ConverterFromNext(arb);\n  }\n\n  generate(mrng) {\n    const g = this.arb.generate(mrng, this.biasFactor);\n    return this.toShrinkable(g);\n  }\n\n  contextualShrink(value, context) {\n    return this.arb.shrink(value, context).map(v => [v.value_, v.context]);\n  }\n\n  shrunkOnceContext() {\n    return this.legacyShrunkOnceContext;\n  }\n\n  filter(refinement) {\n    return ConverterFromNext.convertIfNeeded(this.arb.filter(refinement));\n  }\n\n  map(mapper) {\n    return ConverterFromNext.convertIfNeeded(this.arb.map(mapper));\n  }\n\n  chain(fmapper) {\n    return ConverterFromNext.convertIfNeeded(this.arb.chain(t => {\n      const fmapped = fmapper(t);\n      if (ConverterFromNext.isConverterFromNext(fmapped)) return fmapped.arb;else return new ConverterToNext(fmapped);\n    }));\n  }\n\n  noShrink() {\n    return ConverterFromNext.convertIfNeeded(this.arb.noShrink());\n  }\n\n  withBias(freq) {\n    return new ConverterFromNext(this.arb, this.legacyShrunkOnceContext, freq);\n  }\n\n  noBias() {\n    return ConverterFromNext.convertIfNeeded(this.arb.noBias());\n  }\n\n}\n_a = identifier;","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/check/arbitrary/definition/ConverterFromNext.js"],"names":["_a","ArbitraryWithContextualShrink","ConverterToNext","Shrinkable","identifier","fromNextValueToShrinkableFor","arb","fromNextValueToShrinkable","v","value_","shrinker","shrink","context","map","hasToBeCloned","value","ConverterFromNext","constructor","legacyShrunkOnceContext","biasFactor","undefined","toShrinkable","isConverterFromNext","convertIfNeeded","isConverterToNext","generate","mrng","g","contextualShrink","shrunkOnceContext","filter","refinement","mapper","chain","fmapper","t","fmapped","noShrink","withBias","freq","noBias"],"mappings":"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","sourcesContent":["var _a;\nimport { ArbitraryWithContextualShrink } from './ArbitraryWithContextualShrink.js';\nimport { ConverterToNext } from './ConverterToNext.js';\nimport { Shrinkable } from './Shrinkable.js';\nconst identifier = '__ConverterFromNext__';\nfunction fromNextValueToShrinkableFor(arb) {\n    return function fromNextValueToShrinkable(v) {\n        const value_ = v.value_;\n        const shrinker = () => arb.shrink(value_, v.context).map(fromNextValueToShrinkable);\n        if (!v.hasToBeCloned) {\n            return new Shrinkable(value_, shrinker);\n        }\n        return new Shrinkable(value_, shrinker, () => v.value);\n    };\n}\nexport class ConverterFromNext extends ArbitraryWithContextualShrink {\n    constructor(arb, legacyShrunkOnceContext, biasFactor = undefined) {\n        super();\n        this.arb = arb;\n        this.legacyShrunkOnceContext = legacyShrunkOnceContext;\n        this.biasFactor = biasFactor;\n        this[_a] = true;\n        this.toShrinkable = fromNextValueToShrinkableFor(arb);\n    }\n    static isConverterFromNext(arb) {\n        return identifier in arb;\n    }\n    static convertIfNeeded(arb) {\n        if (ConverterToNext.isConverterToNext(arb))\n            return arb.arb;\n        else\n            return new ConverterFromNext(arb);\n    }\n    generate(mrng) {\n        const g = this.arb.generate(mrng, this.biasFactor);\n        return this.toShrinkable(g);\n    }\n    contextualShrink(value, context) {\n        return this.arb.shrink(value, context).map((v) => [v.value_, v.context]);\n    }\n    shrunkOnceContext() {\n        return this.legacyShrunkOnceContext;\n    }\n    filter(refinement) {\n        return ConverterFromNext.convertIfNeeded(this.arb.filter(refinement));\n    }\n    map(mapper) {\n        return ConverterFromNext.convertIfNeeded(this.arb.map(mapper));\n    }\n    chain(fmapper) {\n        return ConverterFromNext.convertIfNeeded(this.arb.chain((t) => {\n            const fmapped = fmapper(t);\n            if (ConverterFromNext.isConverterFromNext(fmapped))\n                return fmapped.arb;\n            else\n                return new ConverterToNext(fmapped);\n        }));\n    }\n    noShrink() {\n        return ConverterFromNext.convertIfNeeded(this.arb.noShrink());\n    }\n    withBias(freq) {\n        return new ConverterFromNext(this.arb, this.legacyShrunkOnceContext, freq);\n    }\n    noBias() {\n        return ConverterFromNext.convertIfNeeded(this.arb.noBias());\n    }\n}\n_a = identifier;\n"]},"metadata":{},"sourceType":"module"}