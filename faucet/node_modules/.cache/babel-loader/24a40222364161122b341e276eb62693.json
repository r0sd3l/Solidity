{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Abi = exports.ConstructorEntry = exports.FallbackEntry = exports.ReceiveEntry = exports.FunctionEntry = exports.ErrorEntry = exports.EventEntry = exports.EventParameter = exports.Parameter = void 0;\n\nconst fc = __importStar(require(\"fast-check\"));\n\nconst faker_1 = __importDefault(require(\"faker\"));\n\nconst change_case_1 = require(\"change-case\");\n\nconst Parameter = () => fc.tuple(fc.record({\n  name: ParameterName()\n}), TypeRecord()).map(_ref => {\n  let [{\n    name\n  }, type] = _ref;\n  return Object.assign({\n    name\n  }, type);\n});\n\nexports.Parameter = Parameter;\n\nconst EventParameter = () => fc.tuple(fc.record({\n  name: ParameterName(),\n  indexed: fc.boolean()\n}), TypeRecord()).map(_ref2 => {\n  let [{\n    name,\n    indexed\n  }, type] = _ref2;\n  return Object.assign({\n    name,\n    indexed\n  }, type);\n});\n\nexports.EventParameter = EventParameter;\n\nconst EventEntry = () => fc.record({\n  type: fc.constant(\"event\"),\n  name: EventName(),\n  inputs: fc.array(exports.EventParameter(), {\n    maxLength: 10\n  }).filter(inputs => {\n    if (inputs.filter(_ref3 => {\n      let {\n        indexed\n      } = _ref3;\n      return indexed;\n    }).length > 3) {\n      // only up to 3 params can be indexed\n      return false;\n    } // names that are not blank should be unique\n\n\n    const names = inputs.map(_ref4 => {\n      let {\n        name\n      } = _ref4;\n      return name;\n    }).filter(name => name !== \"\");\n    return names.length === new Set(names).size;\n  }),\n  anonymous: fc.boolean()\n});\n\nexports.EventEntry = EventEntry;\n\nconst ErrorEntry = () => fc.record({\n  type: fc.constant(\"error\"),\n  name: ErrorName(),\n  inputs: fc.array(exports.Parameter(), {\n    maxLength: 10\n  }).filter(inputs => {\n    // names that are not blank should be unique\n    const names = inputs.map(_ref5 => {\n      let {\n        name\n      } = _ref5;\n      return name;\n    }).filter(name => name !== \"\");\n    return names.length === new Set(names).size;\n  })\n});\n\nexports.ErrorEntry = ErrorEntry;\n\nconst FunctionEntry = () => fc.tuple(fc.record({\n  type: fc.constant(\"function\")\n}, {\n  withDeletedKeys: true\n}), fc.record({\n  name: FunctionName(),\n  inputs: fc.array(exports.Parameter(), {\n    maxLength: 10\n  })\n}), fc.record({\n  outputs: fc.array(exports.Parameter(), {\n    maxLength: 10\n  })\n}, {\n  withDeletedKeys: true\n}), fc.tuple(fc.oneof(fc.constant(\"pure\"), fc.constant(\"view\"), fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean()).map(_ref6 => {\n  let [stateMutability, includeLegacy, includeModern] = _ref6;\n  const payable = stateMutability === \"payable\";\n  const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n  const modern = {\n    stateMutability\n  };\n  const legacy = {\n    payable,\n    constant\n  };\n  return includeLegacy && includeModern ? Object.assign(Object.assign({}, modern), legacy) : includeModern ? modern : legacy;\n})).map(records => records.reduce((a, b) => Object.assign(Object.assign({}, a), b), {})).filter(entry => {\n  const {\n    inputs,\n    outputs = []\n  } = entry; // names that are not blank should be unique\n\n  const names = [...inputs, ...outputs].map(_ref7 => {\n    let {\n      name\n    } = _ref7;\n    return name;\n  }).filter(name => name !== \"\");\n  return names.length === new Set(names).size;\n});\n\nexports.FunctionEntry = FunctionEntry;\n\nconst ReceiveEntry = () => fc.record({\n  type: fc.constant(\"receive\"),\n  stateMutability: fc.constant(\"payable\")\n});\n\nexports.ReceiveEntry = ReceiveEntry;\n\nconst FallbackEntry = () => fc.tuple(fc.record({\n  type: fc.constant(\"fallback\")\n}), fc.tuple(fc.oneof(fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean()).map(_ref8 => {\n  let [stateMutability, includeLegacy, includeModern] = _ref8;\n  const payable = stateMutability === \"payable\";\n  const modern = {\n    stateMutability\n  };\n  const legacy = {\n    payable\n  };\n  return includeLegacy && includeModern ? Object.assign(Object.assign({}, modern), legacy) : includeModern ? modern : legacy;\n})).map(_ref9 => {\n  let [{\n    type\n  }, mutabilityFields] = _ref9;\n  return Object.assign({\n    type\n  }, mutabilityFields);\n});\n\nexports.FallbackEntry = FallbackEntry;\n\nconst ConstructorEntry = () => fc.tuple(fc.record({\n  type: fc.constant(\"constructor\"),\n  inputs: fc.array(exports.Parameter(), {\n    maxLength: 10\n  }).filter(inputs => {\n    // names that are not blank should be unique\n    const names = inputs.map(_ref10 => {\n      let {\n        name\n      } = _ref10;\n      return name;\n    }).filter(name => name !== \"\");\n    return names.length === new Set(names).size;\n  })\n}), fc.tuple(fc.oneof(fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean()).map(_ref11 => {\n  let [stateMutability, includeLegacy, includeModern] = _ref11;\n  const payable = stateMutability === \"payable\";\n  const modern = {\n    stateMutability\n  };\n  const legacy = {\n    payable\n  };\n  return includeLegacy && includeModern ? Object.assign(Object.assign({}, modern), legacy) : includeModern ? modern : legacy;\n})).map(_ref12 => {\n  let [{\n    type,\n    inputs\n  }, mutabilityFields] = _ref12;\n  return Object.assign({\n    type,\n    inputs\n  }, mutabilityFields);\n});\n\nexports.ConstructorEntry = ConstructorEntry;\n\nconst Abi = () => fc.tuple(exports.ConstructorEntry(), exports.FallbackEntry(), exports.ReceiveEntry(), fc.array(fc.oneof(exports.FunctionEntry(), exports.EventEntry(), exports.ErrorEntry()))).chain(_ref13 => {\n  let [constructor, fallback, receive, entries] = _ref13;\n  return fc.shuffledSubarray([constructor, fallback, receive, ...entries]);\n});\n\nexports.Abi = Abi;\nvar Numerics;\n\n(function (Numerics) {\n  // 0 < n <= 32\n  // use subtraction so that fast-check treats 32 as simpler than 1\n  Numerics.Bytes = () => fc.nat(31).map(k => 32 - k); // 0 < n <= 256, 8 | n\n\n\n  Numerics.Bits = () => Numerics.Bytes().map(k => 8 * k); // 0 < n <= 80\n  // use fancy math so that fast-check treats 18 as the simplest case\n  //\n  //     0 ----------------- 79\n  //     lines up as:\n  //     18 ------ 80, 0 --- 17\n\n\n  Numerics.DecimalPlaces = () => fc.nat(79).map(k => (k + 17) % 80 + 1);\n\n  Numerics.Precision = () => fc.tuple(Numerics.Bits(), Numerics.DecimalPlaces());\n})(Numerics || (Numerics = {}));\n\nvar Primitives;\n\n(function (Primitives) {\n  Primitives.Uint = () => Numerics.Bits().map(m => `uint${m}`);\n\n  Primitives.Int = () => Numerics.Bits().map(m => `int${m}`);\n\n  Primitives.Address = () => fc.constant(\"address\");\n\n  Primitives.Bool = () => fc.constant(\"bool\");\n\n  Primitives.Fixed = () => Numerics.Precision().map(_ref14 => {\n    let [m, n] = _ref14;\n    return `fixed${m}x${n}`;\n  });\n\n  Primitives.Ufixed = () => Numerics.Precision().map(_ref15 => {\n    let [m, n] = _ref15;\n    return `ufixed${m}x${n}`;\n  });\n\n  Primitives.BytesM = () => Numerics.Bytes().map(m => `bytes${m}`);\n\n  Primitives.Function = () => fc.constant(\"function\");\n\n  Primitives.Bytes = () => fc.constant(\"bytes\");\n\n  Primitives.String = () => fc.constant(\"string\");\n\n  Primitives.Tuple = () => fc.constant(\"tuple\");\n})(Primitives || (Primitives = {}));\n\nconst Primitive = () => fc.oneof(Primitives.Uint(), Primitives.Int(), Primitives.Address(), Primitives.Bool(), Primitives.Fixed(), Primitives.Ufixed(), Primitives.BytesM(), Primitives.Function(), Primitives.Bytes(), Primitives.String(), Primitives.Tuple());\n\nconst Type = fc.memo(n => n === 0 ? Primitive() : // we cap this at 3 so that fast-check doesn't blow the stack\nfc.oneof(Primitive(), ArrayFixed(n > 3 ? 3 : n), ArrayDynamic(n)));\nconst ArrayFixed = fc.memo(n => fc.tuple(Type(n - 1), fc.integer(1, 256)).map(_ref16 => {\n  let [type, length] = _ref16;\n  return `${type}[${length}]`;\n}));\nconst ArrayDynamic = fc.memo(n => Type(n - 1).map(type => `${type}[]`));\nconst reservedWords = new Set([\"Error\", \"Panic\", \"_\", \"abi\", \"abstract\", \"addmod\", \"address\", \"after\", \"alias\", \"anonymous\", \"apply\", \"as\", \"assembly\", \"assert\", \"auto\", \"block\", \"blockhash\", \"bool\", \"break\", \"byte\", \"bytes\", \"calldata\", \"case\", \"catch\", \"constant\", \"constructor\", \"continue\", \"contract\", \"copyof\", \"days\", \"default\", \"define\", \"delete\", \"ecrecover\", \"else\", \"emit\", \"enum\", \"error\", \"ether\", \"event\", \"external\", \"fallback\", \"false\", \"final\", \"finney\", \"fixed\", \"for\", \"from\", \"function\", \"gasleft\", \"gwei\", \"hours\", \"if\", \"immutable\", \"implements\", \"import\", \"in\", \"indexed\", \"inline\", \"int\", \"interface\", \"internal\", \"is\", \"keccak256\", \"let\", \"library\", \"log0\", \"log1\", \"log2\", \"log3\", \"log4\", \"macro\", \"mapping\", \"match\", \"memory\", \"minutes\", \"modifier\", \"msg\", \"mulmod\", \"mutable\", \"new\", \"now\", \"null\", \"of\", \"override\", \"partial\", \"payable\", \"pragma\", \"private\", \"promise\", \"public\", \"pure\", \"receive\", \"reference\", \"relocatable\", \"require\", \"return\", \"returns\", \"revert\", \"ripemd160\", \"sealed\", \"seconds\", \"selfdestruct\", \"sha256\", \"sha3\", \"sizeof\", \"static\", \"storage\", \"string\", \"struct\", \"suicide\", \"super\", \"supports\", \"switch\", \"szabo\", \"this\", \"throw\", \"true\", \"try\", \"tx\", \"type\", \"typedef\", \"typeof\", \"ufixed\", \"uint\", \"unchecked\", \"using\", \"var\", \"view\", \"virtual\", \"weeks\", \"wei\", \"while\", \"years\"]); // borrowed from https://runkit.com/dubzzz/faker-to-fast-check\n\nconst fakerToArb = function (template) {\n  let transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : change_case_1.camelCase;\n  return fc.integer().noBias().noShrink().map(seed => {\n    faker_1.default.seed(seed);\n    return transform(faker_1.default.fake(template));\n  }).filter(word => !reservedWords.has(word));\n};\n\nconst ParameterName = () => fc.frequency({\n  arbitrary: fakerToArb(\"{{hacker.noun}}\"),\n  weight: 9\n}, {\n  arbitrary: fc.constant(\"\"),\n  weight: 1\n});\n\nconst EventName = () => fakerToArb(\"{{hacker.verb}} {{hacker.noun}}\", change_case_1.pascalCase);\n\nconst ErrorName = () => fakerToArb(\"{{hacker.noun}} {{hacker.noun}}\", change_case_1.pascalCase);\n\nconst FunctionName = () => fakerToArb(\"{{hacker.verb}} {{hacker.noun}}\");\n\nconst TypeRecord = () => Type().chain(type => type.startsWith(\"tuple\") ? fc.record({\n  type: fc.constant(type),\n  components: fc.array(exports.Parameter().filter(_ref17 => {\n    let {\n      name\n    } = _ref17;\n    return name !== \"\";\n  }), {\n    minLength: 1,\n    maxLength: 5\n  }).filter(items => {\n    const names = items.map(_ref18 => {\n      let {\n        name\n      } = _ref18;\n      return name;\n    }).filter(name => name !== \"\");\n    return names.length === new Set(names).size;\n  })\n}) : fc.record({\n  type: fc.constant(type)\n}));","map":{"version":3,"sources":["../../lib/arbitrary.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Abi = exports.ConstructorEntry = exports.FallbackEntry = exports.ReceiveEntry = exports.FunctionEntry = exports.ErrorEntry = exports.EventEntry = exports.EventParameter = exports.Parameter = void 0;\nconst fc = __importStar(require(\"fast-check\"));\nconst faker_1 = __importDefault(require(\"faker\"));\nconst change_case_1 = require(\"change-case\");\nconst Parameter = () => fc\n    .tuple(fc.record({\n    name: ParameterName()\n}), TypeRecord())\n    .map(([{ name }, type]) => (Object.assign({ name }, type)));\nexports.Parameter = Parameter;\nconst EventParameter = () => fc\n    .tuple(fc.record({\n    name: ParameterName(),\n    indexed: fc.boolean()\n}), TypeRecord())\n    .map(([{ name, indexed }, type]) => (Object.assign({ name, indexed }, type)));\nexports.EventParameter = EventParameter;\nconst EventEntry = () => fc.record({\n    type: fc.constant(\"event\"),\n    name: EventName(),\n    inputs: fc.array(exports.EventParameter(), { maxLength: 10 }).filter(inputs => {\n        if (inputs.filter(({ indexed }) => indexed).length > 3) {\n            // only up to 3 params can be indexed\n            return false;\n        }\n        // names that are not blank should be unique\n        const names = inputs.map(({ name }) => name).filter(name => name !== \"\");\n        return names.length === new Set(names).size;\n    }),\n    anonymous: fc.boolean()\n});\nexports.EventEntry = EventEntry;\nconst ErrorEntry = () => fc.record({\n    type: fc.constant(\"error\"),\n    name: ErrorName(),\n    inputs: fc.array(exports.Parameter(), { maxLength: 10 }).filter(inputs => {\n        // names that are not blank should be unique\n        const names = inputs.map(({ name }) => name).filter(name => name !== \"\");\n        return names.length === new Set(names).size;\n    })\n});\nexports.ErrorEntry = ErrorEntry;\nconst FunctionEntry = () => fc\n    .tuple(fc.record({\n    type: fc.constant(\"function\")\n}, { withDeletedKeys: true }), fc.record({\n    name: FunctionName(),\n    inputs: fc.array(exports.Parameter(), { maxLength: 10 })\n}), fc.record({\n    outputs: fc.array(exports.Parameter(), { maxLength: 10 })\n}, { withDeletedKeys: true }), fc\n    .tuple(fc.oneof(fc.constant(\"pure\"), fc.constant(\"view\"), fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean())\n    .map(([stateMutability, includeLegacy, includeModern]) => {\n    const payable = stateMutability === \"payable\";\n    const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n    const modern = { stateMutability };\n    const legacy = { payable, constant };\n    return includeLegacy && includeModern\n        ? Object.assign(Object.assign({}, modern), legacy) : includeModern\n        ? modern\n        : legacy;\n}))\n    .map(records => records.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}))\n    .filter(entry => {\n    const { inputs, outputs = [] } = entry;\n    // names that are not blank should be unique\n    const names = [...inputs, ...outputs]\n        .map(({ name }) => name)\n        .filter(name => name !== \"\");\n    return names.length === new Set(names).size;\n});\nexports.FunctionEntry = FunctionEntry;\nconst ReceiveEntry = () => fc.record({\n    type: fc.constant(\"receive\"),\n    stateMutability: fc.constant(\"payable\")\n});\nexports.ReceiveEntry = ReceiveEntry;\nconst FallbackEntry = () => fc\n    .tuple(fc.record({\n    type: fc.constant(\"fallback\")\n}), fc\n    .tuple(fc.oneof(fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean())\n    .map(([stateMutability, includeLegacy, includeModern]) => {\n    const payable = stateMutability === \"payable\";\n    const modern = { stateMutability };\n    const legacy = { payable };\n    return includeLegacy && includeModern\n        ? Object.assign(Object.assign({}, modern), legacy) : includeModern\n        ? modern\n        : legacy;\n}))\n    .map(([{ type }, mutabilityFields]) => (Object.assign({ type }, mutabilityFields)));\nexports.FallbackEntry = FallbackEntry;\nconst ConstructorEntry = () => fc\n    .tuple(fc.record({\n    type: fc.constant(\"constructor\"),\n    inputs: fc.array(exports.Parameter(), { maxLength: 10 }).filter(inputs => {\n        // names that are not blank should be unique\n        const names = inputs.map(({ name }) => name).filter(name => name !== \"\");\n        return names.length === new Set(names).size;\n    })\n}), fc\n    .tuple(fc.oneof(fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean())\n    .map(([stateMutability, includeLegacy, includeModern]) => {\n    const payable = stateMutability === \"payable\";\n    const modern = { stateMutability };\n    const legacy = { payable };\n    return includeLegacy && includeModern\n        ? Object.assign(Object.assign({}, modern), legacy) : includeModern\n        ? modern\n        : legacy;\n}))\n    .map(([{ type, inputs }, mutabilityFields]) => (Object.assign({ type,\n    inputs }, mutabilityFields)));\nexports.ConstructorEntry = ConstructorEntry;\nconst Abi = () => fc\n    .tuple(exports.ConstructorEntry(), exports.FallbackEntry(), exports.ReceiveEntry(), fc.array(fc.oneof(exports.FunctionEntry(), exports.EventEntry(), exports.ErrorEntry())))\n    .chain(([constructor, fallback, receive, entries]) => fc.shuffledSubarray([constructor, fallback, receive, ...entries]));\nexports.Abi = Abi;\nvar Numerics;\n(function (Numerics) {\n    // 0 < n <= 32\n    // use subtraction so that fast-check treats 32 as simpler than 1\n    Numerics.Bytes = () => fc.nat(31).map(k => 32 - k);\n    // 0 < n <= 256, 8 | n\n    Numerics.Bits = () => Numerics.Bytes().map(k => 8 * k);\n    // 0 < n <= 80\n    // use fancy math so that fast-check treats 18 as the simplest case\n    //\n    //     0 ----------------- 79\n    //     lines up as:\n    //     18 ------ 80, 0 --- 17\n    Numerics.DecimalPlaces = () => fc.nat(79).map(k => ((k + 17) % 80) + 1);\n    Numerics.Precision = () => fc.tuple(Numerics.Bits(), Numerics.DecimalPlaces());\n})(Numerics || (Numerics = {}));\nvar Primitives;\n(function (Primitives) {\n    Primitives.Uint = () => Numerics.Bits().map(m => `uint${m}`);\n    Primitives.Int = () => Numerics.Bits().map(m => `int${m}`);\n    Primitives.Address = () => fc.constant(\"address\");\n    Primitives.Bool = () => fc.constant(\"bool\");\n    Primitives.Fixed = () => Numerics.Precision().map(([m, n]) => `fixed${m}x${n}`);\n    Primitives.Ufixed = () => Numerics.Precision().map(([m, n]) => `ufixed${m}x${n}`);\n    Primitives.BytesM = () => Numerics.Bytes().map(m => `bytes${m}`);\n    Primitives.Function = () => fc.constant(\"function\");\n    Primitives.Bytes = () => fc.constant(\"bytes\");\n    Primitives.String = () => fc.constant(\"string\");\n    Primitives.Tuple = () => fc.constant(\"tuple\");\n})(Primitives || (Primitives = {}));\nconst Primitive = () => fc.oneof(Primitives.Uint(), Primitives.Int(), Primitives.Address(), Primitives.Bool(), Primitives.Fixed(), Primitives.Ufixed(), Primitives.BytesM(), Primitives.Function(), Primitives.Bytes(), Primitives.String(), Primitives.Tuple());\nconst Type = fc.memo(n => n === 0\n    ? Primitive()\n    : // we cap this at 3 so that fast-check doesn't blow the stack\n        fc.oneof(Primitive(), ArrayFixed(n > 3 ? 3 : n), ArrayDynamic(n)));\nconst ArrayFixed = fc.memo(n => fc\n    .tuple(Type(n - 1), fc.integer(1, 256))\n    .map(([type, length]) => `${type}[${length}]`));\nconst ArrayDynamic = fc.memo(n => Type(n - 1).map(type => `${type}[]`));\nconst reservedWords = new Set([\n    \"Error\",\n    \"Panic\",\n    \"_\",\n    \"abi\",\n    \"abstract\",\n    \"addmod\",\n    \"address\",\n    \"after\",\n    \"alias\",\n    \"anonymous\",\n    \"apply\",\n    \"as\",\n    \"assembly\",\n    \"assert\",\n    \"auto\",\n    \"block\",\n    \"blockhash\",\n    \"bool\",\n    \"break\",\n    \"byte\",\n    \"bytes\",\n    \"calldata\",\n    \"case\",\n    \"catch\",\n    \"constant\",\n    \"constructor\",\n    \"continue\",\n    \"contract\",\n    \"copyof\",\n    \"days\",\n    \"default\",\n    \"define\",\n    \"delete\",\n    \"ecrecover\",\n    \"else\",\n    \"emit\",\n    \"enum\",\n    \"error\",\n    \"ether\",\n    \"event\",\n    \"external\",\n    \"fallback\",\n    \"false\",\n    \"final\",\n    \"finney\",\n    \"fixed\",\n    \"for\",\n    \"from\",\n    \"function\",\n    \"gasleft\",\n    \"gwei\",\n    \"hours\",\n    \"if\",\n    \"immutable\",\n    \"implements\",\n    \"import\",\n    \"in\",\n    \"indexed\",\n    \"inline\",\n    \"int\",\n    \"interface\",\n    \"internal\",\n    \"is\",\n    \"keccak256\",\n    \"let\",\n    \"library\",\n    \"log0\",\n    \"log1\",\n    \"log2\",\n    \"log3\",\n    \"log4\",\n    \"macro\",\n    \"mapping\",\n    \"match\",\n    \"memory\",\n    \"minutes\",\n    \"modifier\",\n    \"msg\",\n    \"mulmod\",\n    \"mutable\",\n    \"new\",\n    \"now\",\n    \"null\",\n    \"of\",\n    \"override\",\n    \"partial\",\n    \"payable\",\n    \"pragma\",\n    \"private\",\n    \"promise\",\n    \"public\",\n    \"pure\",\n    \"receive\",\n    \"reference\",\n    \"relocatable\",\n    \"require\",\n    \"return\",\n    \"returns\",\n    \"revert\",\n    \"ripemd160\",\n    \"sealed\",\n    \"seconds\",\n    \"selfdestruct\",\n    \"sha256\",\n    \"sha3\",\n    \"sizeof\",\n    \"static\",\n    \"storage\",\n    \"string\",\n    \"struct\",\n    \"suicide\",\n    \"super\",\n    \"supports\",\n    \"switch\",\n    \"szabo\",\n    \"this\",\n    \"throw\",\n    \"true\",\n    \"try\",\n    \"tx\",\n    \"type\",\n    \"typedef\",\n    \"typeof\",\n    \"ufixed\",\n    \"uint\",\n    \"unchecked\",\n    \"using\",\n    \"var\",\n    \"view\",\n    \"virtual\",\n    \"weeks\",\n    \"wei\",\n    \"while\",\n    \"years\"\n]);\n// borrowed from https://runkit.com/dubzzz/faker-to-fast-check\nconst fakerToArb = (template, transform = change_case_1.camelCase) => {\n    return fc\n        .integer()\n        .noBias()\n        .noShrink()\n        .map(seed => {\n        faker_1.default.seed(seed);\n        return transform(faker_1.default.fake(template));\n    })\n        .filter(word => !reservedWords.has(word));\n};\nconst ParameterName = () => fc.frequency({ arbitrary: fakerToArb(\"{{hacker.noun}}\"), weight: 9 }, { arbitrary: fc.constant(\"\"), weight: 1 });\nconst EventName = () => fakerToArb(\"{{hacker.verb}} {{hacker.noun}}\", change_case_1.pascalCase);\nconst ErrorName = () => fakerToArb(\"{{hacker.noun}} {{hacker.noun}}\", change_case_1.pascalCase);\nconst FunctionName = () => fakerToArb(\"{{hacker.verb}} {{hacker.noun}}\");\nconst TypeRecord = () => Type().chain(type => type.startsWith(\"tuple\")\n    ? fc.record({\n        type: fc.constant(type),\n        components: fc\n            .array(exports.Parameter().filter(({ name }) => name !== \"\"), { minLength: 1, maxLength: 5 })\n            .filter(items => {\n            const names = items\n                .map(({ name }) => name)\n                .filter(name => name !== \"\");\n            return names.length === new Set(names).size;\n        })\n    })\n    : fc.record({\n        type: fc.constant(type)\n    }));\n//# sourceMappingURL=arbitrary.js.map"]},"metadata":{},"sourceType":"script"}