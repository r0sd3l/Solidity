{"ast":null,"code":"import { Stream } from '../../stream/Stream.js';\nimport { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nexport class TupleArbitrary extends NextArbitrary {\n  constructor(arbs) {\n    super();\n    this.arbs = arbs;\n\n    for (let idx = 0; idx !== arbs.length; ++idx) {\n      const arb = arbs[idx];\n      if (arb == null || arb.generate == null) throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);\n    }\n  }\n\n  static makeItCloneable(vs, values) {\n    return Object.defineProperty(vs, cloneMethod, {\n      value: () => {\n        const cloned = [];\n\n        for (let idx = 0; idx !== values.length; ++idx) {\n          cloned.push(values[idx].value);\n        }\n\n        TupleArbitrary.makeItCloneable(cloned, values);\n        return cloned;\n      }\n    });\n  }\n\n  static wrapper(values) {\n    let cloneable = false;\n    const vs = [];\n    const ctxs = [];\n\n    for (let idx = 0; idx !== values.length; ++idx) {\n      const v = values[idx];\n      cloneable = cloneable || v.hasToBeCloned;\n      vs.push(v.value);\n      ctxs.push(v.context);\n    }\n\n    if (cloneable) {\n      TupleArbitrary.makeItCloneable(vs, values);\n    }\n\n    return new NextValue(vs, ctxs);\n  }\n\n  generate(mrng, biasFactor) {\n    return TupleArbitrary.wrapper(this.arbs.map(a => a.generate(mrng, biasFactor)));\n  }\n\n  canShrinkWithoutContext(value) {\n    if (!Array.isArray(value) || value.length !== this.arbs.length) {\n      return false;\n    }\n\n    for (let index = 0; index !== this.arbs.length; ++index) {\n      if (!this.arbs[index].canShrinkWithoutContext(value[index])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  shrink(value, context) {\n    let s = Stream.nil();\n    const safeContext = Array.isArray(context) ? context : [];\n\n    for (let idx = 0; idx !== this.arbs.length; ++idx) {\n      const shrinksForIndex = this.arbs[idx].shrink(value[idx], safeContext[idx]).map(v => {\n        const nextValues = value.map((v, idx) => new NextValue(cloneIfNeeded(v), safeContext[idx]));\n        return nextValues.slice(0, idx).concat([v]).concat(nextValues.slice(idx + 1));\n      }).map(values => TupleArbitrary.wrapper(values));\n      s = s.join(shrinksForIndex);\n    }\n\n    return s;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js"],"names":["Stream","cloneIfNeeded","cloneMethod","NextArbitrary","NextValue","TupleArbitrary","constructor","arbs","idx","length","arb","generate","Error","makeItCloneable","vs","values","Object","defineProperty","value","cloned","push","wrapper","cloneable","ctxs","v","hasToBeCloned","context","mrng","biasFactor","map","a","canShrinkWithoutContext","Array","isArray","index","shrink","s","nil","safeContext","shrinksForIndex","nextValues","slice","concat","join"],"mappings":"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","sourcesContent":["import { Stream } from '../../stream/Stream.js';\nimport { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nexport class TupleArbitrary extends NextArbitrary {\n    constructor(arbs) {\n        super();\n        this.arbs = arbs;\n        for (let idx = 0; idx !== arbs.length; ++idx) {\n            const arb = arbs[idx];\n            if (arb == null || arb.generate == null)\n                throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);\n        }\n    }\n    static makeItCloneable(vs, values) {\n        return Object.defineProperty(vs, cloneMethod, {\n            value: () => {\n                const cloned = [];\n                for (let idx = 0; idx !== values.length; ++idx) {\n                    cloned.push(values[idx].value);\n                }\n                TupleArbitrary.makeItCloneable(cloned, values);\n                return cloned;\n            },\n        });\n    }\n    static wrapper(values) {\n        let cloneable = false;\n        const vs = [];\n        const ctxs = [];\n        for (let idx = 0; idx !== values.length; ++idx) {\n            const v = values[idx];\n            cloneable = cloneable || v.hasToBeCloned;\n            vs.push(v.value);\n            ctxs.push(v.context);\n        }\n        if (cloneable) {\n            TupleArbitrary.makeItCloneable(vs, values);\n        }\n        return new NextValue(vs, ctxs);\n    }\n    generate(mrng, biasFactor) {\n        return TupleArbitrary.wrapper(this.arbs.map((a) => a.generate(mrng, biasFactor)));\n    }\n    canShrinkWithoutContext(value) {\n        if (!Array.isArray(value) || value.length !== this.arbs.length) {\n            return false;\n        }\n        for (let index = 0; index !== this.arbs.length; ++index) {\n            if (!this.arbs[index].canShrinkWithoutContext(value[index])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    shrink(value, context) {\n        let s = Stream.nil();\n        const safeContext = Array.isArray(context) ? context : [];\n        for (let idx = 0; idx !== this.arbs.length; ++idx) {\n            const shrinksForIndex = this.arbs[idx]\n                .shrink(value[idx], safeContext[idx])\n                .map((v) => {\n                const nextValues = value.map((v, idx) => new NextValue(cloneIfNeeded(v), safeContext[idx]));\n                return nextValues\n                    .slice(0, idx)\n                    .concat([v])\n                    .concat(nextValues.slice(idx + 1));\n            })\n                .map((values) => TupleArbitrary.wrapper(values));\n            s = s.join(shrinksForIndex);\n        }\n        return s;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}