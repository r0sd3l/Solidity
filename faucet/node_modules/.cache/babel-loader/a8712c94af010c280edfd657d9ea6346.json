{"ast":null,"code":"\"use strict\";\n/**\n * Contains the types for type objects, and some\n * functions for working with them.\n *\n * @category Main Format\n *\n * @packageDocumentation\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = exports.forgetCompilations = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:format:types\");\n\nfunction forgetCompilations(typesByCompilation) {\n  return Object.assign({}, ...Object.values(typesByCompilation).map(_ref => {\n    let {\n      types\n    } = _ref;\n    return types;\n  }));\n}\n\nexports.forgetCompilations = forgetCompilations;\n\nfunction isUserDefinedType(anyType) {\n  const userDefinedTypes = [\"contract\", \"enum\", \"struct\", \"userDefinedValueType\"];\n  return userDefinedTypes.includes(anyType.typeClass);\n}\n\nfunction isReferenceType(anyType) {\n  const alwaysReferenceTypes = [\"array\", \"mapping\", \"struct\", \"string\"];\n\n  if (alwaysReferenceTypes.includes(anyType.typeClass)) {\n    return true;\n  } else if (anyType.typeClass === \"bytes\") {\n    return anyType.kind === \"dynamic\";\n  } else {\n    return false;\n  }\n}\n\nexports.isReferenceType = isReferenceType; //one could define a counterpart function that stripped all unnecessary information\n//from the type object, but at the moment I see no need for that\n\nfunction fullType(basicType, userDefinedTypes) {\n  if (!isUserDefinedType(basicType)) {\n    return basicType;\n  }\n\n  let id = basicType.id;\n  let storedType = userDefinedTypes[id];\n\n  if (!storedType) {\n    return basicType;\n  }\n\n  let returnType = Object.assign(Object.assign({}, basicType), storedType);\n\n  if (isReferenceType(basicType) && basicType.location !== undefined) {\n    returnType = specifyLocation(returnType, basicType.location);\n  }\n\n  return returnType;\n}\n\nexports.fullType = fullType; //the location argument here always forces, so passing undefined *will* force undefined\n\nfunction specifyLocation(dataType, location) {\n  if (isReferenceType(dataType)) {\n    switch (dataType.typeClass) {\n      case \"string\":\n      case \"bytes\":\n        return Object.assign(Object.assign({}, dataType), {\n          location\n        });\n\n      case \"array\":\n        return Object.assign(Object.assign({}, dataType), {\n          location,\n          baseType: specifyLocation(dataType.baseType, location)\n        });\n\n      case \"mapping\":\n        let newLocation = location === \"storage\" ? \"storage\" : undefined;\n        return Object.assign(Object.assign({}, dataType), {\n          location: newLocation,\n          valueType: specifyLocation(dataType.valueType, newLocation)\n        });\n\n      case \"struct\":\n        let returnType = Object.assign(Object.assign({}, dataType), {\n          location\n        });\n\n        if (returnType.memberTypes) {\n          returnType.memberTypes = returnType.memberTypes.map(_ref2 => {\n            let {\n              name: memberName,\n              type: memberType\n            } = _ref2;\n            return {\n              name: memberName,\n              type: specifyLocation(memberType, location)\n            };\n          });\n        }\n\n        return returnType;\n    }\n  } else {\n    return dataType;\n  }\n}\n\nexports.specifyLocation = specifyLocation; //NOTE: the following two functions might not be exactly right for weird internal stuff,\n//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things\n//are pointers or not??  we don't track that so we can't recreate that)\n//But what can you do.\n\nfunction typeString(dataType) {\n  let baseString = typeStringWithoutLocation(dataType);\n\n  if (isReferenceType(dataType) && dataType.location) {\n    return baseString + \" \" + dataType.location;\n  } else {\n    return baseString;\n  }\n}\n\nexports.typeString = typeString;\n\nfunction typeStringWithoutLocation(dataType) {\n  switch (dataType.typeClass) {\n    case \"uint\":\n      return dataType.typeHint || `uint${dataType.bits}`;\n\n    case \"int\":\n      return dataType.typeHint || `int${dataType.bits}`;\n\n    case \"bool\":\n      return dataType.typeHint || \"bool\";\n\n    case \"bytes\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return \"bytes\";\n\n        case \"static\":\n          return `bytes${dataType.length}`;\n      }\n\n    case \"address\":\n      switch (dataType.kind) {\n        case \"general\":\n          return dataType.typeHint || \"address\";\n        //I guess?\n\n        case \"specific\":\n          return dataType.payable ? \"address payable\" : \"address\";\n      }\n\n    case \"string\":\n      return dataType.typeHint || \"string\";\n\n    case \"fixed\":\n      return dataType.typeHint || `fixed${dataType.bits}x${dataType.places}`;\n\n    case \"ufixed\":\n      return dataType.typeHint || `ufixed${dataType.bits}x${dataType.places}`;\n\n    case \"array\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return `${typeStringWithoutLocation(dataType.baseType)}[]`;\n\n        case \"static\":\n          return `${typeStringWithoutLocation(dataType.baseType)}[${dataType.length}]`;\n      }\n\n    case \"mapping\":\n      return `mapping(${typeStringWithoutLocation(dataType.keyType)} => ${typeStringWithoutLocation(dataType.valueType)})`;\n\n    case \"struct\":\n    case \"enum\":\n      //combining these cases for simplicity\n      switch (dataType.kind) {\n        case \"local\":\n          return `${dataType.typeClass} ${dataType.definingContractName}.${dataType.typeName}`;\n\n        case \"global\":\n          return `${dataType.typeClass} ${dataType.typeName}`;\n      }\n\n      break;\n    //to satisfy TS :P\n\n    case \"userDefinedValueType\":\n      //differs from struct & enum in that typeClass is omitted\n      switch (dataType.kind) {\n        case \"local\":\n          return `${dataType.definingContractName}.${dataType.typeName}`;\n\n        case \"global\":\n          return `${dataType.typeName}`;\n      }\n\n      break;\n    //to satisfy TS :P\n\n    case \"tuple\":\n      return dataType.typeHint || \"tuple(\" + dataType.memberTypes.map(memberType => typeString(memberType.type)).join(\",\") + \")\";\n    //note that we do include location and do not put spaces\n\n    case \"contract\":\n      return dataType.contractKind + \" \" + dataType.typeName;\n\n    case \"magic\":\n      //no, this is not transposed!\n      const variableNames = {\n        message: \"msg\",\n        transaction: \"tx\",\n        block: \"block\"\n      };\n      return variableNames[dataType.variable];\n\n    case \"type\":\n      return `type(${typeString(dataType.type)})`;\n\n    case \"function\":\n      let visibilityString;\n\n      switch (dataType.visibility) {\n        case \"external\":\n          if (dataType.kind === \"general\") {\n            if (dataType.typeHint) {\n              return dataType.typeHint;\n            } else {\n              return \"function external\"; //I guess???\n            }\n          }\n\n          visibilityString = \" external\"; //note the deliberate space!\n\n          break;\n\n        case \"internal\":\n          visibilityString = \"\";\n          break;\n      }\n\n      let mutabilityString = dataType.mutability === \"nonpayable\" ? \"\" : \" \" + dataType.mutability; //again, note the deliberate space\n\n      let inputList = dataType.inputParameterTypes.map(typeString).join(\",\"); //note that we do include location, and do not put spaces\n\n      let outputList = dataType.outputParameterTypes.map(typeString).join(\",\");\n      let inputString = `function(${inputList})`;\n      let outputString = outputList === \"\" ? \"\" : ` returns (${outputList})`; //again, note the deliberate space\n\n      return inputString + mutabilityString + visibilityString + outputString;\n  }\n}\n\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\n\nfunction isContractDefinedType(anyType) {\n  const contractDefinedTypes = [\"enum\", \"struct\", \"userDefinedValueType\"];\n  return contractDefinedTypes.includes(anyType.typeClass) && anyType.kind === \"local\";\n}\n\nexports.isContractDefinedType = isContractDefinedType;","map":{"version":3,"sources":["../../../lib/format/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Contains the types for type objects, and some\n * functions for working with them.\n *\n * @category Main Format\n *\n * @packageDocumentation\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = exports.forgetCompilations = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:format:types\");\nfunction forgetCompilations(typesByCompilation) {\n    return Object.assign({}, ...Object.values(typesByCompilation).map(({ types }) => types));\n}\nexports.forgetCompilations = forgetCompilations;\nfunction isUserDefinedType(anyType) {\n    const userDefinedTypes = [\"contract\", \"enum\", \"struct\", \"userDefinedValueType\"];\n    return userDefinedTypes.includes(anyType.typeClass);\n}\nfunction isReferenceType(anyType) {\n    const alwaysReferenceTypes = [\"array\", \"mapping\", \"struct\", \"string\"];\n    if (alwaysReferenceTypes.includes(anyType.typeClass)) {\n        return true;\n    }\n    else if (anyType.typeClass === \"bytes\") {\n        return anyType.kind === \"dynamic\";\n    }\n    else {\n        return false;\n    }\n}\nexports.isReferenceType = isReferenceType;\n//one could define a counterpart function that stripped all unnecessary information\n//from the type object, but at the moment I see no need for that\nfunction fullType(basicType, userDefinedTypes) {\n    if (!isUserDefinedType(basicType)) {\n        return basicType;\n    }\n    let id = basicType.id;\n    let storedType = userDefinedTypes[id];\n    if (!storedType) {\n        return basicType;\n    }\n    let returnType = Object.assign(Object.assign({}, basicType), storedType);\n    if (isReferenceType(basicType) && basicType.location !== undefined) {\n        returnType = specifyLocation(returnType, basicType.location);\n    }\n    return returnType;\n}\nexports.fullType = fullType;\n//the location argument here always forces, so passing undefined *will* force undefined\nfunction specifyLocation(dataType, location) {\n    if (isReferenceType(dataType)) {\n        switch (dataType.typeClass) {\n            case \"string\":\n            case \"bytes\":\n                return Object.assign(Object.assign({}, dataType), { location });\n            case \"array\":\n                return Object.assign(Object.assign({}, dataType), { location, baseType: specifyLocation(dataType.baseType, location) });\n            case \"mapping\":\n                let newLocation = location === \"storage\" ? \"storage\" : undefined;\n                return Object.assign(Object.assign({}, dataType), { location: newLocation, valueType: specifyLocation(dataType.valueType, newLocation) });\n            case \"struct\":\n                let returnType = Object.assign(Object.assign({}, dataType), { location });\n                if (returnType.memberTypes) {\n                    returnType.memberTypes = returnType.memberTypes.map(({ name: memberName, type: memberType }) => ({\n                        name: memberName,\n                        type: specifyLocation(memberType, location)\n                    }));\n                }\n                return returnType;\n        }\n    }\n    else {\n        return dataType;\n    }\n}\nexports.specifyLocation = specifyLocation;\n//NOTE: the following two functions might not be exactly right for weird internal stuff,\n//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things\n//are pointers or not??  we don't track that so we can't recreate that)\n//But what can you do.\nfunction typeString(dataType) {\n    let baseString = typeStringWithoutLocation(dataType);\n    if (isReferenceType(dataType) && dataType.location) {\n        return baseString + \" \" + dataType.location;\n    }\n    else {\n        return baseString;\n    }\n}\nexports.typeString = typeString;\nfunction typeStringWithoutLocation(dataType) {\n    switch (dataType.typeClass) {\n        case \"uint\":\n            return dataType.typeHint || `uint${dataType.bits}`;\n        case \"int\":\n            return dataType.typeHint || `int${dataType.bits}`;\n        case \"bool\":\n            return dataType.typeHint || \"bool\";\n        case \"bytes\":\n            if (dataType.typeHint) {\n                return dataType.typeHint;\n            }\n            switch (dataType.kind) {\n                case \"dynamic\":\n                    return \"bytes\";\n                case \"static\":\n                    return `bytes${dataType.length}`;\n            }\n        case \"address\":\n            switch (dataType.kind) {\n                case \"general\":\n                    return dataType.typeHint || \"address\"; //I guess?\n                case \"specific\":\n                    return dataType.payable ? \"address payable\" : \"address\";\n            }\n        case \"string\":\n            return dataType.typeHint || \"string\";\n        case \"fixed\":\n            return dataType.typeHint || `fixed${dataType.bits}x${dataType.places}`;\n        case \"ufixed\":\n            return dataType.typeHint || `ufixed${dataType.bits}x${dataType.places}`;\n        case \"array\":\n            if (dataType.typeHint) {\n                return dataType.typeHint;\n            }\n            switch (dataType.kind) {\n                case \"dynamic\":\n                    return `${typeStringWithoutLocation(dataType.baseType)}[]`;\n                case \"static\":\n                    return `${typeStringWithoutLocation(dataType.baseType)}[${dataType.length}]`;\n            }\n        case \"mapping\":\n            return `mapping(${typeStringWithoutLocation(dataType.keyType)} => ${typeStringWithoutLocation(dataType.valueType)})`;\n        case \"struct\":\n        case \"enum\":\n            //combining these cases for simplicity\n            switch (dataType.kind) {\n                case \"local\":\n                    return `${dataType.typeClass} ${dataType.definingContractName}.${dataType.typeName}`;\n                case \"global\":\n                    return `${dataType.typeClass} ${dataType.typeName}`;\n            }\n            break; //to satisfy TS :P\n        case \"userDefinedValueType\":\n            //differs from struct & enum in that typeClass is omitted\n            switch (dataType.kind) {\n                case \"local\":\n                    return `${dataType.definingContractName}.${dataType.typeName}`;\n                case \"global\":\n                    return `${dataType.typeName}`;\n            }\n            break; //to satisfy TS :P\n        case \"tuple\":\n            return (dataType.typeHint ||\n                \"tuple(\" +\n                    dataType.memberTypes\n                        .map(memberType => typeString(memberType.type))\n                        .join(\",\") +\n                    \")\"); //note that we do include location and do not put spaces\n        case \"contract\":\n            return dataType.contractKind + \" \" + dataType.typeName;\n        case \"magic\":\n            //no, this is not transposed!\n            const variableNames = {\n                message: \"msg\",\n                transaction: \"tx\",\n                block: \"block\"\n            };\n            return variableNames[dataType.variable];\n        case \"type\":\n            return `type(${typeString(dataType.type)})`;\n        case \"function\":\n            let visibilityString;\n            switch (dataType.visibility) {\n                case \"external\":\n                    if (dataType.kind === \"general\") {\n                        if (dataType.typeHint) {\n                            return dataType.typeHint;\n                        }\n                        else {\n                            return \"function external\"; //I guess???\n                        }\n                    }\n                    visibilityString = \" external\"; //note the deliberate space!\n                    break;\n                case \"internal\":\n                    visibilityString = \"\";\n                    break;\n            }\n            let mutabilityString = dataType.mutability === \"nonpayable\" ? \"\" : \" \" + dataType.mutability; //again, note the deliberate space\n            let inputList = dataType.inputParameterTypes.map(typeString).join(\",\"); //note that we do include location, and do not put spaces\n            let outputList = dataType.outputParameterTypes.map(typeString).join(\",\");\n            let inputString = `function(${inputList})`;\n            let outputString = outputList === \"\" ? \"\" : ` returns (${outputList})`; //again, note the deliberate space\n            return inputString + mutabilityString + visibilityString + outputString;\n    }\n}\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\nfunction isContractDefinedType(anyType) {\n    const contractDefinedTypes = [\"enum\", \"struct\", \"userDefinedValueType\"];\n    return contractDefinedTypes.includes(anyType.typeClass)\n        && anyType.kind === \"local\";\n}\nexports.isContractDefinedType = isContractDefinedType;\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}