{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectAllocationInfo = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:allocate:utils\");\n\nconst Compilations = __importStar(require(\"../../compilations\"));\n\nconst compile_common_1 = require(\"@truffle/compile-common\");\n\nconst Contexts = __importStar(require(\"../../contexts\"));\n\nconst Abi = __importStar(require(\"@truffle/abi-utils\"));\n\nfunction collectAllocationInfo(compilations) {\n  let contexts = {};\n  let deployedContexts = {};\n  let contractsAndContexts = [];\n\n  for (const compilation of compilations) {\n    for (const contract of compilation.contracts) {\n      const node = Compilations.Utils.getContractNode(contract, compilation);\n      let deployedContext = undefined;\n      let constructorContext = undefined;\n      const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);\n      const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode);\n\n      if (deployedBytecode && deployedBytecode !== \"0x\") {\n        deployedContext = Contexts.Utils.makeContext(contract, node, compilation);\n        contexts[deployedContext.context] = deployedContext; //note that we don't set up deployedContexts until after normalization!\n      }\n\n      if (bytecode && bytecode !== \"0x\") {\n        constructorContext = Contexts.Utils.makeContext(contract, node, compilation, true);\n        contexts[constructorContext.context] = constructorContext;\n      }\n\n      contractsAndContexts.push({\n        contract,\n        node,\n        deployedContext,\n        constructorContext,\n        compilationId: compilation.id\n      });\n    }\n  }\n\n  debug(\"known contexts: %o\", Object.keys(contexts));\n  contexts = Contexts.Utils.normalizeContexts(contexts);\n  deployedContexts = Object.assign({}, ...Object.values(contexts).map(context => !context.isConstructor ? {\n    [context.context]: context\n  } : {}));\n\n  for (const contractAndContexts of contractsAndContexts) {\n    //change everything to normalized version\n    if (contractAndContexts.deployedContext) {\n      contractAndContexts.deployedContext = contexts[contractAndContexts.deployedContext.context]; //get normalized version\n    }\n\n    if (contractAndContexts.constructorContext) {\n      contractAndContexts.constructorContext = contexts[contractAndContexts.constructorContext.context]; //get normalized version\n    }\n  }\n\n  const allocationInfo = contractsAndContexts.map(_ref => {\n    let {\n      contract: {\n        abi,\n        compiler,\n        immutableReferences\n      },\n      compilationId,\n      node,\n      deployedContext,\n      constructorContext\n    } = _ref;\n    return {\n      abi: Abi.normalize(abi),\n      compilationId,\n      compiler,\n      contractNode: node,\n      deployedContext,\n      constructorContext,\n      immutableReferences\n    };\n  });\n  return {\n    contexts,\n    deployedContexts,\n    contractsAndContexts,\n    allocationInfo\n  };\n}\n\nexports.collectAllocationInfo = collectAllocationInfo;","map":{"version":3,"sources":["../../../../lib/abi-data/allocate/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collectAllocationInfo = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:abi-data:allocate:utils\");\nconst Compilations = __importStar(require(\"../../compilations\"));\nconst compile_common_1 = require(\"@truffle/compile-common\");\nconst Contexts = __importStar(require(\"../../contexts\"));\nconst Abi = __importStar(require(\"@truffle/abi-utils\"));\nfunction collectAllocationInfo(compilations) {\n    let contexts = {};\n    let deployedContexts = {};\n    let contractsAndContexts = [];\n    for (const compilation of compilations) {\n        for (const contract of compilation.contracts) {\n            const node = Compilations.Utils.getContractNode(contract, compilation);\n            let deployedContext = undefined;\n            let constructorContext = undefined;\n            const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);\n            const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode);\n            if (deployedBytecode && deployedBytecode !== \"0x\") {\n                deployedContext = Contexts.Utils.makeContext(contract, node, compilation);\n                contexts[deployedContext.context] = deployedContext;\n                //note that we don't set up deployedContexts until after normalization!\n            }\n            if (bytecode && bytecode !== \"0x\") {\n                constructorContext = Contexts.Utils.makeContext(contract, node, compilation, true);\n                contexts[constructorContext.context] = constructorContext;\n            }\n            contractsAndContexts.push({\n                contract,\n                node,\n                deployedContext,\n                constructorContext,\n                compilationId: compilation.id\n            });\n        }\n    }\n    debug(\"known contexts: %o\", Object.keys(contexts));\n    contexts = Contexts.Utils.normalizeContexts(contexts);\n    deployedContexts = Object.assign({}, ...Object.values(contexts).map(context => !context.isConstructor ? { [context.context]: context } : {}));\n    for (const contractAndContexts of contractsAndContexts) {\n        //change everything to normalized version\n        if (contractAndContexts.deployedContext) {\n            contractAndContexts.deployedContext =\n                contexts[contractAndContexts.deployedContext.context]; //get normalized version\n        }\n        if (contractAndContexts.constructorContext) {\n            contractAndContexts.constructorContext =\n                contexts[contractAndContexts.constructorContext.context]; //get normalized version\n        }\n    }\n    const allocationInfo = contractsAndContexts.map(({ contract: { abi, compiler, immutableReferences }, compilationId, node, deployedContext, constructorContext }) => ({\n        abi: Abi.normalize(abi),\n        compilationId,\n        compiler,\n        contractNode: node,\n        deployedContext,\n        constructorContext,\n        immutableReferences\n    }));\n    return {\n        contexts,\n        deployedContexts,\n        contractsAndContexts,\n        allocationInfo\n    };\n}\nexports.collectAllocationInfo = collectAllocationInfo;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}