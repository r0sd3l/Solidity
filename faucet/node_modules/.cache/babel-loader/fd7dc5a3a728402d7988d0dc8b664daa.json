{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:decode\");\n\nconst AstConstant = __importStar(require(\"./ast-constant\"));\n\nconst AbiData = __importStar(require(\"./abi-data\"));\n\nconst Compiler = __importStar(require(\"./compiler\"));\n\nconst Format = __importStar(require(\"./format\"));\n\nconst Basic = __importStar(require(\"./basic\"));\n\nconst Memory = __importStar(require(\"./memory\"));\n\nconst Special = __importStar(require(\"./special\"));\n\nconst Stack = __importStar(require(\"./stack\"));\n\nconst Storage = __importStar(require(\"./storage\"));\n\nconst Topic = __importStar(require(\"./topic\"));\n\nfunction* decode(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return Format.Utils.Circularity.tie(yield* decodeDispatch(dataType, pointer, info, options));\n}\n\nexports.default = decode;\n\nfunction* decodeDispatch(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  debug(\"type %O\", dataType);\n  debug(\"pointer %O\", pointer);\n\n  switch (pointer.location) {\n    case \"storage\":\n      return yield* Storage.Decode.decodeStorage(dataType, pointer, info);\n\n    case \"stack\":\n      return yield* Stack.Decode.decodeStack(dataType, pointer, info);\n\n    case \"stackliteral\":\n      return yield* Stack.Decode.decodeLiteral(dataType, pointer, info);\n\n    case \"definition\":\n      return yield* AstConstant.Decode.decodeConstant(dataType, pointer, info);\n\n    case \"special\":\n      return yield* Special.Decode.decodeSpecial(dataType, pointer, info);\n\n    case \"calldata\":\n    case \"eventdata\":\n    case \"returndata\":\n      return yield* AbiData.Decode.decodeAbi(dataType, pointer, info, options);\n\n    case \"eventtopic\":\n      return yield* Topic.Decode.decodeTopic(dataType, pointer, info, options);\n\n    case \"code\":\n    case \"nowhere\":\n      //currently only basic types can go in code, so we'll dispatch directly to decodeBasic\n      //(if it's a nowhere pointer, this will return an error result, of course)\n      //(also, Solidity <0.8.9 would always zero-pad immutables regardless of type,\n      //so we have to set the padding mode appropriately to allow for this)\n      return yield* Basic.Decode.decodeBasic(dataType, pointer, info, Object.assign(Object.assign({}, options), {\n        paddingMode: \"defaultOrZero\"\n      }));\n\n    case \"memory\":\n      //this case -- decoding something that resides *directly* in memory,\n      //rather than located via a pointer -- only comes up when decoding immutables\n      //in a constructor.  thus, we turn on the forceRightPadding option on Solidity\n      //versions prior to 0.8.9, because before then all immutables would be right-padded\n      //while in memory\n      switch (Compiler.Utils.solidityFamily(info.currentContext.compiler)) {\n        case \"0.5.x\":\n        case \"0.8.x\":\n        case \"0.8.7+\":\n          return yield* Memory.Decode.decodeMemory(dataType, pointer, info, Object.assign(Object.assign({}, options), {\n            paddingMode: \"right\"\n          }));\n\n        default:\n          return yield* Memory.Decode.decodeMemory(dataType, pointer, info, options);\n      }\n\n  }\n}","map":{"version":3,"sources":["../../lib/decode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:decode\");\nconst AstConstant = __importStar(require(\"./ast-constant\"));\nconst AbiData = __importStar(require(\"./abi-data\"));\nconst Compiler = __importStar(require(\"./compiler\"));\nconst Format = __importStar(require(\"./format\"));\nconst Basic = __importStar(require(\"./basic\"));\nconst Memory = __importStar(require(\"./memory\"));\nconst Special = __importStar(require(\"./special\"));\nconst Stack = __importStar(require(\"./stack\"));\nconst Storage = __importStar(require(\"./storage\"));\nconst Topic = __importStar(require(\"./topic\"));\nfunction* decode(dataType, pointer, info, options = {}) {\n    return Format.Utils.Circularity.tie(yield* decodeDispatch(dataType, pointer, info, options));\n}\nexports.default = decode;\nfunction* decodeDispatch(dataType, pointer, info, options = {}) {\n    debug(\"type %O\", dataType);\n    debug(\"pointer %O\", pointer);\n    switch (pointer.location) {\n        case \"storage\":\n            return yield* Storage.Decode.decodeStorage(dataType, pointer, info);\n        case \"stack\":\n            return yield* Stack.Decode.decodeStack(dataType, pointer, info);\n        case \"stackliteral\":\n            return yield* Stack.Decode.decodeLiteral(dataType, pointer, info);\n        case \"definition\":\n            return yield* AstConstant.Decode.decodeConstant(dataType, pointer, info);\n        case \"special\":\n            return yield* Special.Decode.decodeSpecial(dataType, pointer, info);\n        case \"calldata\":\n        case \"eventdata\":\n        case \"returndata\":\n            return yield* AbiData.Decode.decodeAbi(dataType, pointer, info, options);\n        case \"eventtopic\":\n            return yield* Topic.Decode.decodeTopic(dataType, pointer, info, options);\n        case \"code\":\n        case \"nowhere\":\n            //currently only basic types can go in code, so we'll dispatch directly to decodeBasic\n            //(if it's a nowhere pointer, this will return an error result, of course)\n            //(also, Solidity <0.8.9 would always zero-pad immutables regardless of type,\n            //so we have to set the padding mode appropriately to allow for this)\n            return yield* Basic.Decode.decodeBasic(dataType, pointer, info, Object.assign(Object.assign({}, options), { paddingMode: \"defaultOrZero\" }));\n        case \"memory\":\n            //this case -- decoding something that resides *directly* in memory,\n            //rather than located via a pointer -- only comes up when decoding immutables\n            //in a constructor.  thus, we turn on the forceRightPadding option on Solidity\n            //versions prior to 0.8.9, because before then all immutables would be right-padded\n            //while in memory\n            switch (Compiler.Utils.solidityFamily(info.currentContext.compiler)) {\n                case \"0.5.x\":\n                case \"0.8.x\":\n                case \"0.8.7+\":\n                    return yield* Memory.Decode.decodeMemory(dataType, pointer, info, Object.assign(Object.assign({}, options), { paddingMode: \"right\" }));\n                default:\n                    return yield* Memory.Decode.decodeMemory(dataType, pointer, info, options);\n            }\n    }\n}\n//# sourceMappingURL=decode.js.map"]},"metadata":{},"sourceType":"script"}