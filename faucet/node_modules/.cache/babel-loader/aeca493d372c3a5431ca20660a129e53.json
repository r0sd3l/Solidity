{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPaddingLeft = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:basic:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Contexts = __importStar(require(\"../../contexts\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nconst allocate_1 = require(\"../allocate\");\n\nfunction* decodeBasic(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    state\n  } = info;\n  const {\n    strictAbiMode: strict\n  } = options; //if this is undefined it'll still be falsy so it's OK\n\n  const paddingMode = options.paddingMode || \"default\";\n  let bytes;\n  let rawBytes;\n\n  try {\n    bytes = yield* read_1.default(pointer, state);\n  } catch (error) {\n    debug(\"segfault, pointer %o, state: %O\", pointer, state);\n    return errors_1.handleDecodingError(dataType, error, strict);\n  }\n\n  rawBytes = bytes;\n  debug(\"type %O\", dataType);\n  debug(\"pointer %o\", pointer);\n\n  switch (dataType.typeClass) {\n    case \"userDefinedValueType\":\n      {\n        const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n\n        if (!fullType.underlyingType) {\n          const error = {\n            kind: \"UserDefinedTypeNotFoundError\",\n            type: fullType\n          };\n\n          if (strict || options.allowRetry) {\n            throw new errors_1.StopDecodingError(error, true); //note that we allow a retry if we couldn't locate the underlying type!\n          }\n\n          return {\n            type: fullType,\n            kind: \"error\",\n            error\n          };\n        }\n\n        const underlyingResult = yield* decodeBasic(fullType.underlyingType, pointer, info, options);\n\n        switch (underlyingResult.kind //yes this switch is a little unnecessary :P\n        ) {\n          case \"value\":\n            //wrap the value and return\n            return {\n              //no idea why need coercion here\n              type: fullType,\n              kind: \"value\",\n              value: underlyingResult\n            };\n\n          case \"error\":\n            //wrap the error and return an error result!\n            //this is inconsistent with how we handle other container types\n            //(structs, arrays, mappings), where having an error in one element\n            //does not cause an error in the whole thing, but to do that here\n            //would cause problems for the type system :-/\n            //so we'll just be inconsistent\n            return {\n              //TS is being bad again :-/\n              type: fullType,\n              kind: \"error\",\n              error: {\n                kind: \"WrappedError\",\n                error: underlyingResult\n              }\n            };\n        }\n\n        break; //to satisfy TS :P\n      }\n\n    case \"bool\":\n      {\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"BoolPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n\n        bytes = removePadding(bytes, dataType, paddingMode); //note: the use of the BN is a little silly here,\n        //but, kind of stuck with it for now\n\n        const numeric = Conversion.toBN(bytes);\n\n        if (numeric.eqn(0)) {\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: false\n            }\n          };\n        } else if (numeric.eqn(1)) {\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          };\n        } else {\n          let error = {\n            kind: \"BoolOutOfRangeError\",\n            rawAsBN: numeric\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n      }\n\n    case \"uint\":\n      //first, check padding (if needed)\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"UintPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      } //now, truncate to appropriate length\n\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asBN: Conversion.toBN(bytes),\n          rawAsBN: Conversion.toBN(rawBytes)\n        }\n      };\n\n    case \"int\":\n      //first, check padding (if needed)\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"IntPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      } //now, truncate to appropriate length (keeping the bytes on the right)\n\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asBN: Conversion.toSignedBN(bytes),\n          rawAsBN: Conversion.toSignedBN(rawBytes)\n        }\n      };\n\n    case \"address\":\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"AddressPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      }\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asAddress: Evm.Utils.toAddress(bytes),\n          rawAsHex: Conversion.toHexString(rawBytes)\n        }\n      };\n\n    case \"contract\":\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"ContractPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      }\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n      const contractValueInfo = yield* decodeContract(bytes, info);\n      return {\n        type: fullType,\n        kind: \"value\",\n        value: contractValueInfo\n      };\n\n    case \"bytes\":\n      //NOTE: we assume this is a *static* bytestring,\n      //because this is decodeBasic! dynamic ones should\n      //go to decodeBytes!\n      let coercedDataType = dataType; //first, check padding (if needed)\n\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"BytesPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: coercedDataType,\n          kind: \"error\",\n          error\n        };\n      } //now, truncate to appropriate length\n\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: coercedDataType,\n        kind: \"value\",\n        value: {\n          asHex: Conversion.toHexString(bytes),\n          rawAsHex: Conversion.toHexString(rawBytes)\n        }\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            const error = {\n              kind: \"FunctionExternalNonStackPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n\n          bytes = removePadding(bytes, dataType, paddingMode);\n          const address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n          const selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: yield* decodeExternalFunction(address, selector, info)\n          };\n\n        case \"internal\":\n          //note: we used to error if we hit this point with strict === true,\n          //since internal function pointers don't go in the ABI, and strict\n          //mode is intended for ABI decoding.  however, there are times when\n          //we want to use strict mode to decode immutables, and immutables can\n          //include internal function pointers.  so now we allow this.  yes,\n          //this is a bit of an abuse of strict mode, which was after all meant\n          //for ABI decoding, but oh well.\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            const error = {\n              kind: \"FunctionInternalPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n\n          bytes = removePadding(bytes, dataType, paddingMode);\n          const deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n          const constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n          return decodeInternalFunction(dataType, deployedPc, constructorPc, info, strict);\n      }\n\n      break;\n    //to satisfy TypeScript\n\n    case \"enum\":\n      {\n        let numeric = Conversion.toBN(bytes);\n        const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n\n        if (!fullType.options) {\n          let error = {\n            kind: \"EnumNotFoundDecodingError\",\n            type: fullType,\n            rawAsBN: numeric\n          };\n\n          if (strict || options.allowRetry) {\n            throw new errors_1.StopDecodingError(error, true); //note that we allow a retry if we couldn't locate the enum type!\n          }\n\n          return {\n            type: fullType,\n            kind: \"error\",\n            error\n          };\n        } //note: I'm doing the padding checks a little more manually on this one\n        //so that we can have the right type of error\n\n\n        const numOptions = fullType.options.length;\n        const numBytes = Math.ceil(Math.log2(numOptions) / 8);\n        const paddingType = getPaddingType(dataType, paddingMode);\n\n        if (!checkPaddingDirect(bytes, numBytes, paddingType)) {\n          let error = {\n            kind: \"EnumPaddingError\",\n            type: fullType,\n            paddingType,\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n\n        bytes = removePaddingDirect(bytes, numBytes, paddingType);\n        numeric = Conversion.toBN(bytes); //alter numeric!\n\n        if (numeric.ltn(numOptions)) {\n          const name = fullType.options[numeric.toNumber()]; //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n          //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n          //an enum with that many options in the first place, we have bigger problems!\n\n          return {\n            type: fullType,\n            kind: \"value\",\n            value: {\n              name,\n              numericAsBN: numeric\n            }\n          };\n        } else {\n          let error = {\n            kind: \"EnumOutOfRangeError\",\n            type: fullType,\n            rawAsBN: numeric\n          };\n\n          if (strict) {\n            //note:\n            //if the enum is merely out of range rather than out of the ABI range,\n            //we do NOT throw an error here!  instead we simply return an error value,\n            //which we normally avoid doing in strict mode.  (the error will be caught\n            //later at the re-encoding step instead.)  why?  because we might be running\n            //in ABI mode, so we may need to abify this \"value\" rather than just throwing\n            //it out.\n            throw new errors_1.StopDecodingError(error); //note that we do NOT allow a retry here!\n            //if we *can* find the enum type but the value is out of range,\n            //we *know* that it is invalid!\n          }\n\n          return {\n            type: fullType,\n            kind: \"error\",\n            error\n          };\n        }\n      }\n\n    case \"fixed\":\n      {\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"FixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        } //now, truncate to appropriate length (keeping the bytes on the right)\n\n\n        bytes = removePadding(bytes, dataType, paddingMode);\n        let asBN = Conversion.toSignedBN(bytes);\n        let rawAsBN = Conversion.toSignedBN(rawBytes);\n        let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n        let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asBig,\n            rawAsBig\n          }\n        };\n      }\n\n    case \"ufixed\":\n      {\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"UfixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        } //now, truncate to appropriate length (keeping the bytes on the right)\n\n\n        bytes = removePadding(bytes, dataType, paddingMode);\n        let asBN = Conversion.toBN(bytes);\n        let rawAsBN = Conversion.toBN(rawBytes);\n        let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n        let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asBig,\n            rawAsBig\n          }\n        };\n      }\n  }\n}\n\nexports.decodeBasic = decodeBasic; //NOTE that this function returns a ContractValueInfo, not a ContractResult\n\nfunction* decodeContract(addressBytes, info) {\n  return (yield* decodeContractAndContext(addressBytes, info)).contractInfo;\n}\n\nexports.decodeContract = decodeContract;\n\nfunction* decodeContractAndContext(addressBytes, info) {\n  let address = Evm.Utils.toAddress(addressBytes);\n  let rawAddress = Conversion.toHexString(addressBytes);\n  let codeBytes = yield {\n    type: \"code\",\n    address\n  };\n  let code = Conversion.toHexString(codeBytes);\n  let context = Contexts.Utils.findContext(info.contexts, code);\n\n  if (context !== null) {\n    return {\n      context,\n      contractInfo: {\n        kind: \"known\",\n        address,\n        rawAddress,\n        class: Contexts.Import.contextToType(context)\n      }\n    };\n  } else {\n    return {\n      context,\n      contractInfo: {\n        kind: \"unknown\",\n        address,\n        rawAddress\n      }\n    };\n  }\n} //note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\n\n\nfunction* decodeExternalFunction(addressBytes, selectorBytes, info) {\n  let {\n    contractInfo: contract,\n    context\n  } = yield* decodeContractAndContext(addressBytes, info);\n  let selector = Conversion.toHexString(selectorBytes);\n\n  if (contract.kind === \"unknown\") {\n    return {\n      kind: \"unknown\",\n      contract,\n      selector\n    };\n  }\n\n  let abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n\n  if (abiEntry === undefined) {\n    return {\n      kind: \"invalid\",\n      contract,\n      selector\n    };\n  }\n\n  return {\n    kind: \"known\",\n    contract,\n    selector,\n    abi: abiEntry\n  };\n}\n\nexports.decodeExternalFunction = decodeExternalFunction; //this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\n\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info, strict) {\n  const deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n  const constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n  const context = Contexts.Import.contextToType(info.currentContext); //before anything else: do we even have an internal functions table?\n  //if not, we'll just return the info we have without really attemting to decode\n\n  if (!info.internalFunctionsTable) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"unknown\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //also before we continue: is the PC zero? if so let's just return that\n\n\n  if (deployedPc === 0 && constructorPc === 0) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //another check: is only the deployed PC zero?\n\n\n  if (deployedPc === 0 && constructorPc !== 0) {\n    const error = {\n      kind: \"MalformedInternalFunctionError\",\n      context,\n      deployedProgramCounter: 0,\n      constructorProgramCounter: constructorPc\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  } //one last pre-check: is this a deployed-format pointer in a constructor?\n\n\n  if (info.currentContext.isConstructor && constructorPc === 0) {\n    const error = {\n      kind: \"DeployedFunctionInConstructorError\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: 0\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  } //otherwise, we get our function\n\n\n  const pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n  const functionEntry = info.internalFunctionsTable[pc];\n\n  if (!functionEntry) {\n    //if it's not zero and there's no entry... error!\n    const error = {\n      kind: \"NoSuchInternalFunctionError\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  if (functionEntry.isDesignatedInvalid) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n\n  const name = functionEntry.name;\n  const mutability = functionEntry.mutability;\n  const definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null\n\n  const id = Evm.Import.makeInternalFunctionId(functionEntry);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"function\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc,\n      name,\n      id,\n      definedIn,\n      mutability\n    }\n  };\n}\n\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  const length = allocate_1.byteLength(dataType, userDefinedTypes);\n  const paddingType = getPaddingType(dataType, paddingMode);\n\n  if (paddingMode === \"permissive\") {\n    switch (dataType.typeClass) {\n      case \"bool\":\n      case \"enum\":\n      case \"function\":\n        //these three types are checked even in permissive mode\n        return checkPaddingDirect(bytes, length, paddingType);\n\n      default:\n        return true;\n    }\n  } else {\n    return checkPaddingDirect(bytes, length, paddingType);\n  }\n}\n\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  const length = allocate_1.byteLength(dataType, userDefinedTypes);\n  const paddingType = getPaddingType(dataType, paddingMode);\n  return removePaddingDirect(bytes, length, paddingType);\n}\n\nfunction removePaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"right\":\n      return bytes.slice(0, length);\n\n    default:\n      return bytes.slice(-length);\n  }\n}\n\nfunction checkPaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"left\":\n      return checkPaddingLeft(bytes, length);\n\n    case \"right\":\n      return checkPaddingRight(bytes, length);\n\n    case \"signed\":\n      return checkPaddingSigned(bytes, length);\n\n    case \"signedOrLeft\":\n      return checkPaddingSigned(bytes, length) || checkPaddingLeft(bytes, length);\n  }\n}\n\nfunction getPaddingType(dataType, paddingMode) {\n  switch (paddingMode) {\n    case \"right\":\n      return \"right\";\n\n    case \"default\":\n    case \"permissive\":\n      return defaultPaddingType(dataType);\n\n    case \"zero\":\n      {\n        const defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"left\" : defaultType;\n      }\n\n    case \"defaultOrZero\":\n      {\n        const defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"signedOrLeft\" : defaultType;\n      }\n  }\n}\n\nfunction defaultPaddingType(dataType) {\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      return \"right\";\n\n    case \"int\":\n    case \"fixed\":\n      return \"signed\";\n\n    case \"function\":\n      if (dataType.visibility === \"external\") {\n        return \"right\";\n      }\n\n    //otherwise, fall through to default\n\n    default:\n      return \"left\";\n  }\n}\n\nfunction checkPaddingRight(bytes, length) {\n  let padding = bytes.slice(length); //cut off the first length bytes\n\n  return padding.every(paddingByte => paddingByte === 0);\n} //exporting this one for use in stack.ts\n\n\nfunction checkPaddingLeft(bytes, length) {\n  let padding = bytes.slice(0, -length); //cut off the last length bytes\n\n  return padding.every(paddingByte => paddingByte === 0);\n}\n\nexports.checkPaddingLeft = checkPaddingLeft;\n\nfunction checkPaddingSigned(bytes, length) {\n  let padding = bytes.slice(0, -length); //padding is all but the last length bytes\n\n  let value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n\n  let signByte = value[0] & 0x80 ? 0xff : 0x00;\n  return padding.every(paddingByte => paddingByte === signByte);\n}","map":{"version":3,"sources":["../../../../lib/basic/decode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkPaddingLeft = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:basic:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Contexts = __importStar(require(\"../../contexts\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nconst allocate_1 = require(\"../allocate\");\nfunction* decodeBasic(dataType, pointer, info, options = {}) {\n    const { state } = info;\n    const { strictAbiMode: strict } = options; //if this is undefined it'll still be falsy so it's OK\n    const paddingMode = options.paddingMode || \"default\";\n    let bytes;\n    let rawBytes;\n    try {\n        bytes = yield* read_1.default(pointer, state);\n    }\n    catch (error) {\n        debug(\"segfault, pointer %o, state: %O\", pointer, state);\n        return errors_1.handleDecodingError(dataType, error, strict);\n    }\n    rawBytes = bytes;\n    debug(\"type %O\", dataType);\n    debug(\"pointer %o\", pointer);\n    switch (dataType.typeClass) {\n        case \"userDefinedValueType\": {\n            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));\n            if (!fullType.underlyingType) {\n                const error = {\n                    kind: \"UserDefinedTypeNotFoundError\",\n                    type: fullType\n                };\n                if (strict || options.allowRetry) {\n                    throw new errors_1.StopDecodingError(error, true);\n                    //note that we allow a retry if we couldn't locate the underlying type!\n                }\n                return {\n                    type: fullType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            const underlyingResult = yield* decodeBasic(fullType.underlyingType, pointer, info, options);\n            switch (underlyingResult.kind //yes this switch is a little unnecessary :P\n            ) {\n                case \"value\":\n                    //wrap the value and return\n                    return {\n                        //no idea why need coercion here\n                        type: fullType,\n                        kind: \"value\",\n                        value: underlyingResult\n                    };\n                case \"error\":\n                    //wrap the error and return an error result!\n                    //this is inconsistent with how we handle other container types\n                    //(structs, arrays, mappings), where having an error in one element\n                    //does not cause an error in the whole thing, but to do that here\n                    //would cause problems for the type system :-/\n                    //so we'll just be inconsistent\n                    return {\n                        //TS is being bad again :-/\n                        type: fullType,\n                        kind: \"error\",\n                        error: {\n                            kind: \"WrappedError\",\n                            error: underlyingResult\n                        }\n                    };\n            }\n            break; //to satisfy TS :P\n        }\n        case \"bool\": {\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"BoolPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            //note: the use of the BN is a little silly here,\n            //but, kind of stuck with it for now\n            const numeric = Conversion.toBN(bytes);\n            if (numeric.eqn(0)) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    value: { asBoolean: false }\n                };\n            }\n            else if (numeric.eqn(1)) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    value: { asBoolean: true }\n                };\n            }\n            else {\n                let error = {\n                    kind: \"BoolOutOfRangeError\",\n                    rawAsBN: numeric\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n        }\n        case \"uint\":\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"UintPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBN: Conversion.toBN(bytes),\n                    rawAsBN: Conversion.toBN(rawBytes)\n                }\n            };\n        case \"int\":\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"IntPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length (keeping the bytes on the right)\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBN: Conversion.toSignedBN(bytes),\n                    rawAsBN: Conversion.toSignedBN(rawBytes)\n                }\n            };\n        case \"address\":\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"AddressPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asAddress: Evm.Utils.toAddress(bytes),\n                    rawAsHex: Conversion.toHexString(rawBytes)\n                }\n            };\n        case \"contract\":\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"ContractPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePadding(bytes, dataType, paddingMode);\n            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));\n            const contractValueInfo = yield* decodeContract(bytes, info);\n            return {\n                type: fullType,\n                kind: \"value\",\n                value: contractValueInfo\n            };\n        case \"bytes\":\n            //NOTE: we assume this is a *static* bytestring,\n            //because this is decodeBasic! dynamic ones should\n            //go to decodeBytes!\n            let coercedDataType = dataType;\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"BytesPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: coercedDataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length\n            bytes = removePadding(bytes, dataType, paddingMode);\n            return {\n                type: coercedDataType,\n                kind: \"value\",\n                value: {\n                    asHex: Conversion.toHexString(bytes),\n                    rawAsHex: Conversion.toHexString(rawBytes)\n                }\n            };\n        case \"function\":\n            switch (dataType.visibility) {\n                case \"external\":\n                    if (!checkPadding(bytes, dataType, paddingMode)) {\n                        const error = {\n                            kind: \"FunctionExternalNonStackPaddingError\",\n                            paddingType: getPaddingType(dataType, paddingMode),\n                            raw: Conversion.toHexString(bytes)\n                        };\n                        if (strict) {\n                            throw new errors_1.StopDecodingError(error);\n                        }\n                        return {\n                            type: dataType,\n                            kind: \"error\",\n                            error\n                        };\n                    }\n                    bytes = removePadding(bytes, dataType, paddingMode);\n                    const address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n                    const selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n                    return {\n                        type: dataType,\n                        kind: \"value\",\n                        value: yield* decodeExternalFunction(address, selector, info)\n                    };\n                case \"internal\":\n                    //note: we used to error if we hit this point with strict === true,\n                    //since internal function pointers don't go in the ABI, and strict\n                    //mode is intended for ABI decoding.  however, there are times when\n                    //we want to use strict mode to decode immutables, and immutables can\n                    //include internal function pointers.  so now we allow this.  yes,\n                    //this is a bit of an abuse of strict mode, which was after all meant\n                    //for ABI decoding, but oh well.\n                    if (!checkPadding(bytes, dataType, paddingMode)) {\n                        const error = {\n                            kind: \"FunctionInternalPaddingError\",\n                            paddingType: getPaddingType(dataType, paddingMode),\n                            raw: Conversion.toHexString(bytes)\n                        };\n                        if (strict) {\n                            throw new errors_1.StopDecodingError(error);\n                        }\n                        return {\n                            type: dataType,\n                            kind: \"error\",\n                            error\n                        };\n                    }\n                    bytes = removePadding(bytes, dataType, paddingMode);\n                    const deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n                    const constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n                    return decodeInternalFunction(dataType, deployedPc, constructorPc, info, strict);\n            }\n            break; //to satisfy TypeScript\n        case \"enum\": {\n            let numeric = Conversion.toBN(bytes);\n            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));\n            if (!fullType.options) {\n                let error = {\n                    kind: \"EnumNotFoundDecodingError\",\n                    type: fullType,\n                    rawAsBN: numeric\n                };\n                if (strict || options.allowRetry) {\n                    throw new errors_1.StopDecodingError(error, true);\n                    //note that we allow a retry if we couldn't locate the enum type!\n                }\n                return {\n                    type: fullType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //note: I'm doing the padding checks a little more manually on this one\n            //so that we can have the right type of error\n            const numOptions = fullType.options.length;\n            const numBytes = Math.ceil(Math.log2(numOptions) / 8);\n            const paddingType = getPaddingType(dataType, paddingMode);\n            if (!checkPaddingDirect(bytes, numBytes, paddingType)) {\n                let error = {\n                    kind: \"EnumPaddingError\",\n                    type: fullType,\n                    paddingType,\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            bytes = removePaddingDirect(bytes, numBytes, paddingType);\n            numeric = Conversion.toBN(bytes); //alter numeric!\n            if (numeric.ltn(numOptions)) {\n                const name = fullType.options[numeric.toNumber()];\n                //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n                //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n                //an enum with that many options in the first place, we have bigger problems!\n                return {\n                    type: fullType,\n                    kind: \"value\",\n                    value: {\n                        name,\n                        numericAsBN: numeric\n                    }\n                };\n            }\n            else {\n                let error = {\n                    kind: \"EnumOutOfRangeError\",\n                    type: fullType,\n                    rawAsBN: numeric\n                };\n                if (strict) {\n                    //note:\n                    //if the enum is merely out of range rather than out of the ABI range,\n                    //we do NOT throw an error here!  instead we simply return an error value,\n                    //which we normally avoid doing in strict mode.  (the error will be caught\n                    //later at the re-encoding step instead.)  why?  because we might be running\n                    //in ABI mode, so we may need to abify this \"value\" rather than just throwing\n                    //it out.\n                    throw new errors_1.StopDecodingError(error);\n                    //note that we do NOT allow a retry here!\n                    //if we *can* find the enum type but the value is out of range,\n                    //we *know* that it is invalid!\n                }\n                return {\n                    type: fullType,\n                    kind: \"error\",\n                    error\n                };\n            }\n        }\n        case \"fixed\": {\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"FixedPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length (keeping the bytes on the right)\n            bytes = removePadding(bytes, dataType, paddingMode);\n            let asBN = Conversion.toSignedBN(bytes);\n            let rawAsBN = Conversion.toSignedBN(rawBytes);\n            let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n            let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBig,\n                    rawAsBig\n                }\n            };\n        }\n        case \"ufixed\": {\n            //first, check padding (if needed)\n            if (!checkPadding(bytes, dataType, paddingMode)) {\n                let error = {\n                    kind: \"UfixedPaddingError\",\n                    paddingType: getPaddingType(dataType, paddingMode),\n                    raw: Conversion.toHexString(bytes)\n                };\n                if (strict) {\n                    throw new errors_1.StopDecodingError(error);\n                }\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error\n                };\n            }\n            //now, truncate to appropriate length (keeping the bytes on the right)\n            bytes = removePadding(bytes, dataType, paddingMode);\n            let asBN = Conversion.toBN(bytes);\n            let rawAsBN = Conversion.toBN(rawBytes);\n            let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n            let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: {\n                    asBig,\n                    rawAsBig\n                }\n            };\n        }\n    }\n}\nexports.decodeBasic = decodeBasic;\n//NOTE that this function returns a ContractValueInfo, not a ContractResult\nfunction* decodeContract(addressBytes, info) {\n    return (yield* decodeContractAndContext(addressBytes, info)).contractInfo;\n}\nexports.decodeContract = decodeContract;\nfunction* decodeContractAndContext(addressBytes, info) {\n    let address = Evm.Utils.toAddress(addressBytes);\n    let rawAddress = Conversion.toHexString(addressBytes);\n    let codeBytes = yield {\n        type: \"code\",\n        address\n    };\n    let code = Conversion.toHexString(codeBytes);\n    let context = Contexts.Utils.findContext(info.contexts, code);\n    if (context !== null) {\n        return {\n            context,\n            contractInfo: {\n                kind: \"known\",\n                address,\n                rawAddress,\n                class: Contexts.Import.contextToType(context)\n            }\n        };\n    }\n    else {\n        return {\n            context,\n            contractInfo: {\n                kind: \"unknown\",\n                address,\n                rawAddress\n            }\n        };\n    }\n}\n//note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\nfunction* decodeExternalFunction(addressBytes, selectorBytes, info) {\n    let { contractInfo: contract, context } = yield* decodeContractAndContext(addressBytes, info);\n    let selector = Conversion.toHexString(selectorBytes);\n    if (contract.kind === \"unknown\") {\n        return {\n            kind: \"unknown\",\n            contract,\n            selector\n        };\n    }\n    let abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n    if (abiEntry === undefined) {\n        return {\n            kind: \"invalid\",\n            contract,\n            selector\n        };\n    }\n    return {\n        kind: \"known\",\n        contract,\n        selector,\n        abi: abiEntry\n    };\n}\nexports.decodeExternalFunction = decodeExternalFunction;\n//this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info, strict) {\n    const deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n    const constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n    const context = Contexts.Import.contextToType(info.currentContext);\n    //before anything else: do we even have an internal functions table?\n    //if not, we'll just return the info we have without really attemting to decode\n    if (!info.internalFunctionsTable) {\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n                kind: \"unknown\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    //also before we continue: is the PC zero? if so let's just return that\n    if (deployedPc === 0 && constructorPc === 0) {\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n                kind: \"exception\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    //another check: is only the deployed PC zero?\n    if (deployedPc === 0 && constructorPc !== 0) {\n        const error = {\n            kind: \"MalformedInternalFunctionError\",\n            context,\n            deployedProgramCounter: 0,\n            constructorProgramCounter: constructorPc\n        };\n        if (strict) {\n            throw new errors_1.StopDecodingError(error);\n        }\n        return {\n            type: dataType,\n            kind: \"error\",\n            error\n        };\n    }\n    //one last pre-check: is this a deployed-format pointer in a constructor?\n    if (info.currentContext.isConstructor && constructorPc === 0) {\n        const error = {\n            kind: \"DeployedFunctionInConstructorError\",\n            context,\n            deployedProgramCounter: deployedPc,\n            constructorProgramCounter: 0\n        };\n        if (strict) {\n            throw new errors_1.StopDecodingError(error);\n        }\n        return {\n            type: dataType,\n            kind: \"error\",\n            error\n        };\n    }\n    //otherwise, we get our function\n    const pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n    const functionEntry = info.internalFunctionsTable[pc];\n    if (!functionEntry) {\n        //if it's not zero and there's no entry... error!\n        const error = {\n            kind: \"NoSuchInternalFunctionError\",\n            context,\n            deployedProgramCounter: deployedPc,\n            constructorProgramCounter: constructorPc\n        };\n        if (strict) {\n            throw new errors_1.StopDecodingError(error);\n        }\n        return {\n            type: dataType,\n            kind: \"error\",\n            error\n        };\n    }\n    if (functionEntry.isDesignatedInvalid) {\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n                kind: \"exception\",\n                context,\n                deployedProgramCounter: deployedPc,\n                constructorProgramCounter: constructorPc\n            }\n        };\n    }\n    const name = functionEntry.name;\n    const mutability = functionEntry.mutability;\n    const definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null\n    const id = Evm.Import.makeInternalFunctionId(functionEntry);\n    return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n            kind: \"function\",\n            context,\n            deployedProgramCounter: deployedPc,\n            constructorProgramCounter: constructorPc,\n            name,\n            id,\n            definedIn,\n            mutability\n        }\n    };\n}\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n    const length = allocate_1.byteLength(dataType, userDefinedTypes);\n    const paddingType = getPaddingType(dataType, paddingMode);\n    if (paddingMode === \"permissive\") {\n        switch (dataType.typeClass) {\n            case \"bool\":\n            case \"enum\":\n            case \"function\":\n                //these three types are checked even in permissive mode\n                return checkPaddingDirect(bytes, length, paddingType);\n            default:\n                return true;\n        }\n    }\n    else {\n        return checkPaddingDirect(bytes, length, paddingType);\n    }\n}\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n    const length = allocate_1.byteLength(dataType, userDefinedTypes);\n    const paddingType = getPaddingType(dataType, paddingMode);\n    return removePaddingDirect(bytes, length, paddingType);\n}\nfunction removePaddingDirect(bytes, length, paddingType) {\n    switch (paddingType) {\n        case \"right\":\n            return bytes.slice(0, length);\n        default:\n            return bytes.slice(-length);\n    }\n}\nfunction checkPaddingDirect(bytes, length, paddingType) {\n    switch (paddingType) {\n        case \"left\":\n            return checkPaddingLeft(bytes, length);\n        case \"right\":\n            return checkPaddingRight(bytes, length);\n        case \"signed\":\n            return checkPaddingSigned(bytes, length);\n        case \"signedOrLeft\":\n            return (checkPaddingSigned(bytes, length) || checkPaddingLeft(bytes, length));\n    }\n}\nfunction getPaddingType(dataType, paddingMode) {\n    switch (paddingMode) {\n        case \"right\":\n            return \"right\";\n        case \"default\":\n        case \"permissive\":\n            return defaultPaddingType(dataType);\n        case \"zero\": {\n            const defaultType = defaultPaddingType(dataType);\n            return defaultType === \"signed\" ? \"left\" : defaultType;\n        }\n        case \"defaultOrZero\": {\n            const defaultType = defaultPaddingType(dataType);\n            return defaultType === \"signed\" ? \"signedOrLeft\" : defaultType;\n        }\n    }\n}\nfunction defaultPaddingType(dataType) {\n    switch (dataType.typeClass) {\n        case \"bytes\":\n            return \"right\";\n        case \"int\":\n        case \"fixed\":\n            return \"signed\";\n        case \"function\":\n            if (dataType.visibility === \"external\") {\n                return \"right\";\n            }\n        //otherwise, fall through to default\n        default:\n            return \"left\";\n    }\n}\nfunction checkPaddingRight(bytes, length) {\n    let padding = bytes.slice(length); //cut off the first length bytes\n    return padding.every(paddingByte => paddingByte === 0);\n}\n//exporting this one for use in stack.ts\nfunction checkPaddingLeft(bytes, length) {\n    let padding = bytes.slice(0, -length); //cut off the last length bytes\n    return padding.every(paddingByte => paddingByte === 0);\n}\nexports.checkPaddingLeft = checkPaddingLeft;\nfunction checkPaddingSigned(bytes, length) {\n    let padding = bytes.slice(0, -length); //padding is all but the last length bytes\n    let value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n    let signByte = value[0] & 0x80 ? 0xff : 0x00;\n    return padding.every(paddingByte => paddingByte === signByte);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}