{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.definitionToStoredType = exports.definitionToType = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:ast:import\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst Compiler = __importStar(require(\"../../compiler\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst import_1 = require(\"../../contexts/import\"); //NOTE: the following function will *not* work for arbitrary nodes! It will,\n//however, work well enough for what we need.  I.e., it will:\n//1. work when given the actual variable definition as the node,\n//2. work when given an elementary type as the node,\n//3. work when given a user-defined type as the node,\n//4. produce something of the correct size in all cases.\n//Use beyond that is at your own risk!\n//NOTE: set forceLocation to *null* to force no location. leave it undefined\n//to not force a location.\n\n\nfunction definitionToType(definition, compilationId, compiler, forceLocation) {\n  let typeClass = Utils.typeClass(definition);\n  let typeHint = Utils.typeStringWithoutLocation(definition);\n\n  switch (typeClass) {\n    case \"bool\":\n      return {\n        typeClass,\n        typeHint\n      };\n\n    case \"address\":\n      {\n        switch (Compiler.Utils.solidityFamily(compiler)) {\n          case \"unknown\": //I guess?\n\n          case \"pre-0.5.0\":\n            return {\n              typeClass,\n              kind: \"general\",\n              typeHint\n            };\n\n          default:\n            return {\n              typeClass,\n              kind: \"specific\",\n              payable: Utils.typeIdentifier(definition) === \"t_address_payable\"\n            };\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"uint\":\n      {\n        let bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          typeHint\n        };\n      }\n\n    case \"int\":\n      {\n        //typeScript won't let me group these for some reason\n        let bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          typeHint\n        };\n      }\n\n    case \"fixed\":\n      {\n        //typeScript won't let me group these for some reason\n        let bytes = Utils.specifiedSize(definition);\n        let places = Utils.decimalPlaces(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          places,\n          typeHint\n        };\n      }\n\n    case \"ufixed\":\n      {\n        let bytes = Utils.specifiedSize(definition);\n        let places = Utils.decimalPlaces(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          places,\n          typeHint\n        };\n      }\n\n    case \"string\":\n      {\n        if (forceLocation === null) {\n          return {\n            typeClass,\n            typeHint\n          };\n        }\n\n        let location = forceLocation || Utils.referenceType(definition);\n        return {\n          typeClass,\n          location,\n          typeHint\n        };\n      }\n\n    case \"bytes\":\n      {\n        let length = Utils.specifiedSize(definition);\n\n        if (length !== null) {\n          return {\n            typeClass,\n            kind: \"static\",\n            length,\n            typeHint\n          };\n        } else {\n          if (forceLocation === null) {\n            return {\n              typeClass,\n              kind: \"dynamic\",\n              typeHint\n            };\n          }\n\n          let location = forceLocation || Utils.referenceType(definition);\n          return {\n            typeClass,\n            kind: \"dynamic\",\n            location,\n            typeHint\n          };\n        }\n      }\n\n    case \"array\":\n      {\n        let baseDefinition = Utils.baseDefinition(definition);\n        let baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);\n        let location = forceLocation || Utils.referenceType(definition);\n\n        if (Utils.isDynamicArray(definition)) {\n          if (forceLocation !== null) {\n            return {\n              typeClass,\n              baseType,\n              kind: \"dynamic\",\n              location,\n              typeHint\n            };\n          } else {\n            return {\n              typeClass,\n              baseType,\n              kind: \"dynamic\",\n              typeHint\n            };\n          }\n        } else {\n          let length = new bn_js_1.default(Utils.staticLengthAsString(definition));\n\n          if (forceLocation !== null) {\n            return {\n              typeClass,\n              baseType,\n              kind: \"static\",\n              length,\n              location,\n              typeHint\n            };\n          } else {\n            return {\n              typeClass,\n              baseType,\n              kind: \"static\",\n              length,\n              typeHint\n            };\n          }\n        }\n      }\n\n    case \"mapping\":\n      {\n        let keyDefinition = Utils.keyDefinition(definition); //note that we can skip the scopes argument here! that's only needed when\n        //a general node, rather than a declaration, is being passed in\n\n        let keyType = definitionToType(keyDefinition, compilationId, compiler, null); //suppress the location on the key type (it'll be given as memory but\n        //this is meaningless)\n        //also, we have to tell TypeScript ourselves that this will be an elementary\n        //type; it has no way of knowing that\n\n        debug(\"definition: %O\", definition);\n        let valueDefinition = Utils.valueDefinition(definition);\n        let valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);\n\n        if (forceLocation === null) {\n          return {\n            typeClass,\n            keyType,\n            valueType\n          };\n        }\n\n        return {\n          typeClass,\n          keyType,\n          valueType,\n          location: \"storage\"\n        };\n      }\n\n    case \"function\":\n      {\n        //WARNING! This case will not work unless given the actual\n        //definition!  It should return something *roughly* usable, though.\n        let visibility = Utils.visibility(definition); //undefined if bad node\n\n        let mutability = Utils.mutability(definition); //undefined if bad node\n\n        let [inputParameters, outputParameters] = Utils.parameters(definition) || [[], []]; //HACK\n        //note: don't force a location on these! use the listed location!\n\n        let inputParameterTypes = inputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n        let outputParameterTypes = outputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n\n        switch (visibility) {\n          case \"internal\":\n            return {\n              typeClass,\n              visibility,\n              mutability,\n              inputParameterTypes,\n              outputParameterTypes\n            };\n\n          case \"external\":\n            return {\n              typeClass,\n              visibility,\n              kind: \"specific\",\n              mutability,\n              inputParameterTypes,\n              outputParameterTypes\n            };\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"struct\":\n      {\n        let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n        let qualifiedName = typeHint.match(/struct (.*)/)[1];\n        let definingContractName;\n        let typeName;\n\n        if (qualifiedName.includes(\".\")) {\n          [definingContractName, typeName] = qualifiedName.split(\".\");\n        } else {\n          typeName = qualifiedName; //leave definingContractName undefined\n        }\n\n        if (forceLocation === null) {\n          if (definingContractName) {\n            return {\n              typeClass,\n              kind: \"local\",\n              id,\n              typeName,\n              definingContractName\n            };\n          } else {\n            return {\n              typeClass,\n              kind: \"global\",\n              id,\n              typeName\n            };\n          }\n        }\n\n        let location = forceLocation || Utils.referenceType(definition);\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            location\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName,\n            location\n          };\n        }\n      }\n\n    case \"enum\":\n      {\n        let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n        let qualifiedName = typeHint.match(/enum (.*)/)[1];\n        let definingContractName;\n        let typeName;\n\n        if (qualifiedName.includes(\".\")) {\n          [definingContractName, typeName] = qualifiedName.split(\".\");\n        } else {\n          typeName = qualifiedName; //leave definingContractName undefined\n        }\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName\n          };\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n        let definingContractName;\n        let typeName;\n\n        if (typeHint.includes(\".\")) {\n          [definingContractName, typeName] = typeHint.split(\".\");\n        } else {\n          typeName = typeHint; //leave definingContractName undefined\n        }\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName\n          };\n        }\n      }\n\n    case \"contract\":\n      {\n        let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n        let typeName = typeHint.match(/(contract|library|interface) (.*)/)[2]; //note: we use the type string rather than the type identifier\n        //in order to avoid having to deal with the underscore problem\n\n        let contractKind = Utils.contractKind(definition);\n        return {\n          typeClass,\n          kind: \"native\",\n          id,\n          typeName,\n          contractKind\n        };\n      }\n\n    case \"magic\":\n      {\n        let typeIdentifier = Utils.typeIdentifier(definition);\n        let variable = typeIdentifier.match(/^t_magic_(.*)$/)[1];\n        return {\n          typeClass,\n          variable\n        };\n      }\n  }\n}\n\nexports.definitionToType = definitionToType; //whereas the above takes variable definitions, this takes the actual type\n//definition\n\nfunction definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {\n  switch (definition.nodeType) {\n    case \"StructDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        const memberTypes = definition.members.map(member => ({\n          name: member.name,\n          type: definitionToType(member, compilationId, compiler, null)\n        }));\n\n        if (definingContract) {\n          return {\n            typeClass: \"struct\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            memberTypes\n          };\n        } else {\n          return {\n            typeClass: \"struct\",\n            kind: \"global\",\n            id,\n            typeName,\n            memberTypes\n          };\n        }\n      }\n\n    case \"EnumDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        const options = definition.members.map(member => member.name);\n\n        if (definingContract) {\n          return {\n            typeClass: \"enum\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            options\n          };\n        } else {\n          return {\n            typeClass: \"enum\",\n            kind: \"global\",\n            id,\n            typeName,\n            options\n          };\n        }\n      }\n\n    case \"UserDefinedValueTypeDefinition\":\n      {\n        const {\n          id,\n          typeName,\n          definingContractName,\n          definingContract\n        } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n        let underlyingType = definitionToType(definition.underlyingType, compilationId, compiler, null); //final null doesn't matter here\n\n        if (definingContract) {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            underlyingType\n          };\n        } else {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"global\",\n            id,\n            typeName,\n            underlyingType\n          };\n        }\n      }\n\n    case \"ContractDefinition\":\n      {\n        let id = import_1.makeTypeId(definition.id, compilationId);\n        let typeName = definition.name;\n        let contractKind = definition.contractKind;\n        let payable = Utils.isContractPayable(definition);\n        return {\n          typeClass: \"contract\",\n          kind: \"native\",\n          id,\n          typeName,\n          contractKind,\n          payable\n        };\n      }\n  }\n}\n\nexports.definitionToStoredType = definitionToStoredType;\n\nfunction getDefiningInfo(definition, compilationId, compiler, referenceDeclarations) {\n  const id = import_1.makeTypeId(definition.id, compilationId);\n  let definingContractName;\n  let typeName;\n\n  if (definition.canonicalName) {\n    if (definition.canonicalName.includes(\".\")) {\n      [definingContractName, typeName] = definition.canonicalName.split(\".\");\n    } else {\n      typeName = definition.canonicalName;\n    }\n  } else {\n    //due to a bug, in 0.8.8 UDVTs lack a canonicalName.\n    //so we'll set typeName based on name instead of canonicalName,\n    //and set definingContractName below based on definingContract.\n    //(this does mean that we'll mess up a bit if referenceDeclarations\n    //is not passed... but realistically that shouldn't come up?  really the\n    //same kind of hapepns for every type)\n    typeName = definition.name;\n  }\n\n  let definingContract = undefined;\n  ;\n\n  if (referenceDeclarations) {\n    let contractDefinition = Object.values(referenceDeclarations).find(node => node.nodeType === \"ContractDefinition\" && node.nodes.some(subNode => import_1.makeTypeId(subNode.id, compilationId) === id));\n\n    if (contractDefinition) {\n      definingContract = definitionToStoredType(contractDefinition, compilationId, compiler); //can skip reference declarations\n\n      if (!definingContractName) {\n        definingContractName = contractDefinition.name;\n      }\n    }\n  }\n\n  return {\n    definingContract,\n    definingContractName,\n    typeName,\n    id\n  };\n}","map":{"version":3,"sources":["../../../../lib/ast/import/index.ts"],"names":[],"mappings":";AAAA;;;;AAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,kBAAZ,CAAd;;AAEA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAGA,MAAA,QAAA,GAAA,YAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,UAAA,CAAA,CAAA;;AAEA,MAAA,QAAA,GAAA,OAAA,CAAA,uBAAA,CAAA,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAgB,gBAAhB,CACE,UADF,EAEE,aAFF,EAGE,QAHF,EAIE,aAJF,EAIwC;AAEtC,MAAI,SAAS,GAAG,KAAK,CAAC,SAAN,CAAgB,UAAhB,CAAhB;AACA,MAAI,QAAQ,GAAG,KAAK,CAAC,yBAAN,CAAgC,UAAhC,CAAf;;AACA,UAAQ,SAAR;AACE,SAAK,MAAL;AACE,aAAO;AACL,QAAA,SADK;AAEL,QAAA;AAFK,OAAP;;AAIF,SAAK,SAAL;AAAgB;AACd,gBAAQ,QAAQ,CAAC,KAAT,CAAe,cAAf,CAA8B,QAA9B,CAAR;AACE,eAAK,SAAL,CADF,CACkB;;AAChB,eAAK,WAAL;AACE,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,IAAI,EAAE,SAFD;AAGL,cAAA;AAHK,aAAP;;AAKF;AACE,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,IAAI,EAAE,UAFD;AAGL,cAAA,OAAO,EAAE,KAAK,CAAC,cAAN,CAAqB,UAArB,MAAqC;AAHzC,aAAP;AATJ;;AAeA,cAhBc,CAgBP;AACR;;AACD,SAAK,MAAL;AAAa;AACX,YAAI,KAAK,GAAG,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAZ;AACA,eAAO;AACL,UAAA,SADK;AAEL,UAAA,IAAI,EAAE,KAAK,GAAG,CAFT;AAGL,UAAA;AAHK,SAAP;AAKD;;AACD,SAAK,KAAL;AAAY;AACV;AACA,YAAI,KAAK,GAAG,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAZ;AACA,eAAO;AACL,UAAA,SADK;AAEL,UAAA,IAAI,EAAE,KAAK,GAAG,CAFT;AAGL,UAAA;AAHK,SAAP;AAKD;;AACD,SAAK,OAAL;AAAc;AACZ;AACA,YAAI,KAAK,GAAG,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAZ;AACA,YAAI,MAAM,GAAG,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAb;AACA,eAAO;AACL,UAAA,SADK;AAEL,UAAA,IAAI,EAAE,KAAK,GAAG,CAFT;AAGL,UAAA,MAHK;AAIL,UAAA;AAJK,SAAP;AAMD;;AACD,SAAK,QAAL;AAAe;AACb,YAAI,KAAK,GAAG,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAZ;AACA,YAAI,MAAM,GAAG,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAb;AACA,eAAO;AACL,UAAA,SADK;AAEL,UAAA,IAAI,EAAE,KAAK,GAAG,CAFT;AAGL,UAAA,MAHK;AAIL,UAAA;AAJK,SAAP;AAMD;;AACD,SAAK,QAAL;AAAe;AACb,YAAI,aAAa,KAAK,IAAtB,EAA4B;AAC1B,iBAAO;AACL,YAAA,SADK;AAEL,YAAA;AAFK,WAAP;AAID;;AACD,YAAI,QAAQ,GAAG,aAAa,IAAI,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAhC;AACA,eAAO;AACL,UAAA,SADK;AAEL,UAAA,QAFK;AAGL,UAAA;AAHK,SAAP;AAKD;;AACD,SAAK,OAAL;AAAc;AACZ,YAAI,MAAM,GAAG,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAb;;AACA,YAAI,MAAM,KAAK,IAAf,EAAqB;AACnB,iBAAO;AACL,YAAA,SADK;AAEL,YAAA,IAAI,EAAE,QAFD;AAGL,YAAA,MAHK;AAIL,YAAA;AAJK,WAAP;AAMD,SAPD,MAOO;AACL,cAAI,aAAa,KAAK,IAAtB,EAA4B;AAC1B,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,IAAI,EAAE,SAFD;AAGL,cAAA;AAHK,aAAP;AAKD;;AACD,cAAI,QAAQ,GAAG,aAAa,IAAI,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAhC;AACA,iBAAO;AACL,YAAA,SADK;AAEL,YAAA,IAAI,EAAE,SAFD;AAGL,YAAA,QAHK;AAIL,YAAA;AAJK,WAAP;AAMD;AACF;;AACD,SAAK,OAAL;AAAc;AACZ,YAAI,cAAc,GAAG,KAAK,CAAC,cAAN,CAAqB,UAArB,CAArB;AACA,YAAI,QAAQ,GAAG,gBAAgB,CAC7B,cAD6B,EAE7B,aAF6B,EAG7B,QAH6B,EAI7B,aAJ6B,CAA/B;AAMA,YAAI,QAAQ,GAAG,aAAa,IAAI,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAhC;;AACA,YAAI,KAAK,CAAC,cAAN,CAAqB,UAArB,CAAJ,EAAsC;AACpC,cAAI,aAAa,KAAK,IAAtB,EAA4B;AAC1B,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,QAFK;AAGL,cAAA,IAAI,EAAE,SAHD;AAIL,cAAA,QAJK;AAKL,cAAA;AALK,aAAP;AAOD,WARD,MAQO;AACL,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,QAFK;AAGL,cAAA,IAAI,EAAE,SAHD;AAIL,cAAA;AAJK,aAAP;AAMD;AACF,SAjBD,MAiBO;AACL,cAAI,MAAM,GAAG,IAAI,OAAA,CAAA,OAAJ,CAAO,KAAK,CAAC,oBAAN,CAA2B,UAA3B,CAAP,CAAb;;AACA,cAAI,aAAa,KAAK,IAAtB,EAA4B;AAC1B,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,QAFK;AAGL,cAAA,IAAI,EAAE,QAHD;AAIL,cAAA,MAJK;AAKL,cAAA,QALK;AAML,cAAA;AANK,aAAP;AAQD,WATD,MASO;AACL,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,QAFK;AAGL,cAAA,IAAI,EAAE,QAHD;AAIL,cAAA,MAJK;AAKL,cAAA;AALK,aAAP;AAOD;AACF;AACF;;AACD,SAAK,SAAL;AAAgB;AACd,YAAI,aAAa,GAAG,KAAK,CAAC,aAAN,CAAoB,UAApB,CAApB,CADc,CAEd;AACA;;AACA,YAAI,OAAO,GACT,gBAAgB,CAAC,aAAD,EAAgB,aAAhB,EAA+B,QAA/B,EAAyC,IAAzC,CADlB,CAJc,CAOd;AACA;AACA;AACA;;AACA,QAAA,KAAK,CAAC,gBAAD,EAAmB,UAAnB,CAAL;AACA,YAAI,eAAe,GAAG,KAAK,CAAC,eAAN,CAAsB,UAAtB,CAAtB;AACA,YAAI,SAAS,GAAG,gBAAgB,CAC9B,eAD8B,EAE9B,aAF8B,EAG9B,QAH8B,EAI9B,aAJ8B,CAAhC;;AAMA,YAAI,aAAa,KAAK,IAAtB,EAA4B;AAC1B,iBAAO;AACL,YAAA,SADK;AAEL,YAAA,OAFK;AAGL,YAAA;AAHK,WAAP;AAKD;;AACD,eAAO;AACL,UAAA,SADK;AAEL,UAAA,OAFK;AAGL,UAAA,SAHK;AAIL,UAAA,QAAQ,EAAE;AAJL,SAAP;AAMD;;AACD,SAAK,UAAL;AAAiB;AACf;AACA;AACA,YAAI,UAAU,GAAG,KAAK,CAAC,UAAN,CAAiB,UAAjB,CAAjB,CAHe,CAGgC;;AAC/C,YAAI,UAAU,GAAG,KAAK,CAAC,UAAN,CAAiB,UAAjB,CAAjB,CAJe,CAIgC;;AAC/C,YAAI,CAAC,eAAD,EAAkB,gBAAlB,IAAsC,KAAK,CAAC,UAAN,CACxC,UADwC,KAErC,CAAC,EAAD,EAAK,EAAL,CAFL,CALe,CAOA;AACf;;AACA,YAAI,mBAAmB,GAAG,eAAe,CAAC,GAAhB,CAAoB,SAAS,IACrD,gBAAgB,CAAC,SAAD,EAAY,aAAZ,EAA2B,QAA3B,CADQ,CAA1B;AAGA,YAAI,oBAAoB,GAAG,gBAAgB,CAAC,GAAjB,CAAqB,SAAS,IACvD,gBAAgB,CAAC,SAAD,EAAY,aAAZ,EAA2B,QAA3B,CADS,CAA3B;;AAGA,gBAAQ,UAAR;AACE,eAAK,UAAL;AACE,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,UAFK;AAGL,cAAA,UAHK;AAIL,cAAA,mBAJK;AAKL,cAAA;AALK,aAAP;;AAOF,eAAK,UAAL;AACE,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,UAFK;AAGL,cAAA,IAAI,EAAE,UAHD;AAIL,cAAA,UAJK;AAKL,cAAA,mBALK;AAML,cAAA;AANK,aAAP;AAVJ;;AAmBA,cAlCe,CAkCR;AACR;;AACD,SAAK,QAAL;AAAe;AACb,YAAI,EAAE,GAAG,QAAA,CAAA,UAAA,CAAW,KAAK,CAAC,MAAN,CAAa,UAAb,CAAX,EAAqC,aAArC,CAAT;AACA,YAAI,aAAa,GAAG,QAAQ,CAAC,KAAT,CAAe,aAAf,EAA8B,CAA9B,CAApB;AACA,YAAI,oBAAJ;AACA,YAAI,QAAJ;;AACA,YAAI,aAAa,CAAC,QAAd,CAAuB,GAAvB,CAAJ,EAAiC;AAC/B,WAAC,oBAAD,EAAuB,QAAvB,IAAmC,aAAa,CAAC,KAAd,CAAoB,GAApB,CAAnC;AACD,SAFD,MAEO;AACL,UAAA,QAAQ,GAAG,aAAX,CADK,CAEL;AACD;;AACD,YAAI,aAAa,KAAK,IAAtB,EAA4B;AAC1B,cAAI,oBAAJ,EAA0B;AACxB,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,IAAI,EAAE,OAFD;AAGL,cAAA,EAHK;AAIL,cAAA,QAJK;AAKL,cAAA;AALK,aAAP;AAOD,WARD,MAQO;AACL,mBAAO;AACL,cAAA,SADK;AAEL,cAAA,IAAI,EAAE,QAFD;AAGL,cAAA,EAHK;AAIL,cAAA;AAJK,aAAP;AAMD;AACF;;AACD,YAAI,QAAQ,GAAG,aAAa,IAAI,KAAK,CAAC,aAAN,CAAoB,UAApB,CAAhC;;AACA,YAAI,oBAAJ,EAA0B;AACxB,iBAAO;AACL,YAAA,SADK;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,EAHK;AAIL,YAAA,QAJK;AAKL,YAAA,oBALK;AAML,YAAA;AANK,WAAP;AAQD,SATD,MASO;AACL,iBAAO;AACL,YAAA,SADK;AAEL,YAAA,IAAI,EAAE,QAFD;AAGL,YAAA,EAHK;AAIL,YAAA,QAJK;AAKL,YAAA;AALK,WAAP;AAOD;AACF;;AACD,SAAK,MAAL;AAAa;AACX,YAAI,EAAE,GAAG,QAAA,CAAA,UAAA,CAAW,KAAK,CAAC,MAAN,CAAa,UAAb,CAAX,EAAqC,aAArC,CAAT;AACA,YAAI,aAAa,GAAG,QAAQ,CAAC,KAAT,CAAe,WAAf,EAA4B,CAA5B,CAApB;AACA,YAAI,oBAAJ;AACA,YAAI,QAAJ;;AACA,YAAI,aAAa,CAAC,QAAd,CAAuB,GAAvB,CAAJ,EAAiC;AAC/B,WAAC,oBAAD,EAAuB,QAAvB,IAAmC,aAAa,CAAC,KAAd,CAAoB,GAApB,CAAnC;AACD,SAFD,MAEO;AACL,UAAA,QAAQ,GAAG,aAAX,CADK,CAEL;AACD;;AACD,YAAI,oBAAJ,EAA0B;AACxB,iBAAO;AACL,YAAA,SADK;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,EAHK;AAIL,YAAA,QAJK;AAKL,YAAA;AALK,WAAP;AAOD,SARD,MAQO;AACL,iBAAO;AACL,YAAA,SADK;AAEL,YAAA,IAAI,EAAE,QAFD;AAGL,YAAA,EAHK;AAIL,YAAA;AAJK,WAAP;AAMD;AACF;;AACD,SAAK,sBAAL;AAA6B;AAC3B,YAAI,EAAE,GAAG,QAAA,CAAA,UAAA,CAAW,KAAK,CAAC,MAAN,CAAa,UAAb,CAAX,EAAqC,aAArC,CAAT;AACA,YAAI,oBAAJ;AACA,YAAI,QAAJ;;AACA,YAAI,QAAQ,CAAC,QAAT,CAAkB,GAAlB,CAAJ,EAA4B;AAC1B,WAAC,oBAAD,EAAuB,QAAvB,IAAmC,QAAQ,CAAC,KAAT,CAAe,GAAf,CAAnC;AACD,SAFD,MAEO;AACL,UAAA,QAAQ,GAAG,QAAX,CADK,CAEL;AACD;;AACD,YAAI,oBAAJ,EAA0B;AACxB,iBAAO;AACL,YAAA,SADK;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,EAHK;AAIL,YAAA,QAJK;AAKL,YAAA;AALK,WAAP;AAOD,SARD,MAQO;AACL,iBAAO;AACL,YAAA,SADK;AAEL,YAAA,IAAI,EAAE,QAFD;AAGL,YAAA,EAHK;AAIL,YAAA;AAJK,WAAP;AAMD;AACF;;AACD,SAAK,UAAL;AAAiB;AACf,YAAI,EAAE,GAAG,QAAA,CAAA,UAAA,CAAW,KAAK,CAAC,MAAN,CAAa,UAAb,CAAX,EAAqC,aAArC,CAAT;AACA,YAAI,QAAQ,GAAG,QAAQ,CAAC,KAAT,CAAe,mCAAf,EAAoD,CAApD,CAAf,CAFe,CAGf;AACA;;AACA,YAAI,YAAY,GAAG,KAAK,CAAC,YAAN,CAAmB,UAAnB,CAAnB;AACA,eAAO;AACL,UAAA,SADK;AAEL,UAAA,IAAI,EAAE,QAFD;AAGL,UAAA,EAHK;AAIL,UAAA,QAJK;AAKL,UAAA;AALK,SAAP;AAOD;;AACD,SAAK,OAAL;AAAc;AACZ,YAAI,cAAc,GAAG,KAAK,CAAC,cAAN,CAAqB,UAArB,CAArB;AACA,YAAI,QAAQ,GACV,cAAc,CAAC,KAAf,CAAqB,gBAArB,EAAuC,CAAvC,CADF;AAGA,eAAO;AACL,UAAA,SADK;AAEL,UAAA;AAFK,SAAP;AAID;AA1VH;AA4VD;;AApWD,OAAA,CAAA,gBAAA,GAAA,gBAAA,C,CAsWA;AACA;;AACA,SAAgB,sBAAhB,CACE,UADF,EAEE,aAFF,EAGE,QAHF,EAIE,qBAJF,EAIkC;AAEhC,UAAQ,UAAU,CAAC,QAAnB;AACE,SAAK,kBAAL;AAAyB;AACvB,cAAM;AACJ,UAAA,EADI;AAEJ,UAAA,QAFI;AAGJ,UAAA,oBAHI;AAIJ,UAAA;AAJI,YAKF,eAAe,CACjB,UADiB,EAEjB,aAFiB,EAGjB,QAHiB,EAIjB,qBAJiB,CALnB;AAWA,cAAM,WAAW,GAGX,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAuB,MAAM,KAAK;AACtC,UAAA,IAAI,EAAE,MAAM,CAAC,IADyB;AAEtC,UAAA,IAAI,EAAE,gBAAgB,CAAC,MAAD,EAAS,aAAT,EAAwB,QAAxB,EAAkC,IAAlC;AAFgB,SAAL,CAA7B,CAHN;;AAOA,YAAI,gBAAJ,EAAsB;AACpB,iBAAO;AACL,YAAA,SAAS,EAAE,QADN;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,EAHK;AAIL,YAAA,QAJK;AAKL,YAAA,oBALK;AAML,YAAA,gBANK;AAOL,YAAA;AAPK,WAAP;AASD,SAVD,MAUO;AACL,iBAAO;AACL,YAAA,SAAS,EAAE,QADN;AAEL,YAAA,IAAI,EAAE,QAFD;AAGL,YAAA,EAHK;AAIL,YAAA,QAJK;AAKL,YAAA;AALK,WAAP;AAOD;AACF;;AACD,SAAK,gBAAL;AAAuB;AACrB,cAAM;AACJ,UAAA,EADI;AAEJ,UAAA,QAFI;AAGJ,UAAA,oBAHI;AAIJ,UAAA;AAJI,YAKF,eAAe,CACjB,UADiB,EAEjB,aAFiB,EAGjB,QAHiB,EAIjB,qBAJiB,CALnB;AAWA,cAAM,OAAO,GAAG,UAAU,CAAC,OAAX,CAAmB,GAAnB,CAAuB,MAAM,IAAI,MAAM,CAAC,IAAxC,CAAhB;;AACA,YAAI,gBAAJ,EAAsB;AACpB,iBAAO;AACL,YAAA,SAAS,EAAE,MADN;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,EAHK;AAIL,YAAA,QAJK;AAKL,YAAA,oBALK;AAML,YAAA,gBANK;AAOL,YAAA;AAPK,WAAP;AASD,SAVD,MAUO;AACL,iBAAO;AACL,YAAA,SAAS,EAAE,MADN;AAEL,YAAA,IAAI,EAAE,QAFD;AAGL,YAAA,EAHK;AAIL,YAAA,QAJK;AAKL,YAAA;AALK,WAAP;AAOD;AACF;;AACD,SAAK,gCAAL;AAAuC;AACrC,cAAM;AACJ,UAAA,EADI;AAEJ,UAAA,QAFI;AAGJ,UAAA,oBAHI;AAIJ,UAAA;AAJI,YAKF,eAAe,CACjB,UADiB,EAEjB,aAFiB,EAGjB,QAHiB,EAIjB,qBAJiB,CALnB;AAWA,YAAI,cAAc,GAChB,gBAAgB,CAAC,UAAU,CAAC,cAAZ,EAA4B,aAA5B,EAA2C,QAA3C,EAAqD,IAArD,CADlB,CAZqC,CAayC;;AAC9E,YAAI,gBAAJ,EAAsB;AACpB,iBAAO;AACL,YAAA,SAAS,EAAE,sBADN;AAEL,YAAA,IAAI,EAAE,OAFD;AAGL,YAAA,EAHK;AAIL,YAAA,QAJK;AAKL,YAAA,oBALK;AAML,YAAA,gBANK;AAOL,YAAA;AAPK,WAAP;AASD,SAVD,MAUO;AACL,iBAAO;AACL,YAAA,SAAS,EAAE,sBADN;AAEL,YAAA,IAAI,EAAE,QAFD;AAGL,YAAA,EAHK;AAIL,YAAA,QAJK;AAKL,YAAA;AALK,WAAP;AAOD;AACF;;AACD,SAAK,oBAAL;AAA2B;AACzB,YAAI,EAAE,GAAG,QAAA,CAAA,UAAA,CAAW,UAAU,CAAC,EAAtB,EAA0B,aAA1B,CAAT;AACA,YAAI,QAAQ,GAAG,UAAU,CAAC,IAA1B;AACA,YAAI,YAAY,GAAG,UAAU,CAAC,YAA9B;AACA,YAAI,OAAO,GAAG,KAAK,CAAC,iBAAN,CAAwB,UAAxB,CAAd;AACA,eAAO;AACL,UAAA,SAAS,EAAE,UADN;AAEL,UAAA,IAAI,EAAE,QAFD;AAGL,UAAA,EAHK;AAIL,UAAA,QAJK;AAKL,UAAA,YALK;AAML,UAAA;AANK,SAAP;AAQD;AAxHH;AA0HD;;AAhID,OAAA,CAAA,sBAAA,GAAA,sBAAA;;AAyIA,SAAS,eAAT,CACE,UADF,EAEE,aAFF,EAGE,QAHF,EAIE,qBAJF,EAIkC;AAEhC,QAAM,EAAE,GAAG,QAAA,CAAA,UAAA,CAAW,UAAU,CAAC,EAAtB,EAA0B,aAA1B,CAAX;AACA,MAAI,oBAAJ;AACA,MAAI,QAAJ;;AACA,MAAI,UAAU,CAAC,aAAf,EAA8B;AAC5B,QAAI,UAAU,CAAC,aAAX,CAAyB,QAAzB,CAAkC,GAAlC,CAAJ,EAA4C;AAC1C,OAAC,oBAAD,EAAuB,QAAvB,IAAmC,UAAU,CAAC,aAAX,CAAyB,KAAzB,CAA+B,GAA/B,CAAnC;AACD,KAFD,MAEO;AACL,MAAA,QAAQ,GAAG,UAAU,CAAC,aAAtB;AACD;AACF,GAND,MAMO;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,QAAQ,GAAG,UAAU,CAAC,IAAtB;AACD;;AACD,MAAI,gBAAgB,GAAgD,SAApE;AAA8E;;AAC9E,MAAI,qBAAJ,EAA2B;AACzB,QAAI,kBAAkB,GAAG,MAAM,CAAC,MAAP,CAAc,qBAAd,EAAqC,IAArC,CACvB,IAAI,IACF,IAAI,CAAC,QAAL,KAAkB,oBAAlB,IACA,IAAI,CAAC,KAAL,CAAW,IAAX,CACG,OAAD,IAAsB,QAAA,CAAA,UAAA,CAAW,OAAO,CAAC,EAAnB,EAAuB,aAAvB,MAA0C,EADlE,CAHqB,CAAzB;;AAOA,QAAI,kBAAJ,EAAwB;AACtB,MAAA,gBAAgB,GACd,sBAAsB,CAAC,kBAAD,EAAqB,aAArB,EAAoC,QAApC,CADxB,CADsB,CAGnB;;AACH,UAAI,CAAC,oBAAL,EAA2B;AACzB,QAAA,oBAAoB,GAAG,kBAAkB,CAAC,IAA1C;AACD;AACF;AACF;;AACD,SAAO;AACL,IAAA,gBADK;AAEL,IAAA,oBAFK;AAGL,IAAA,QAHK;AAIL,IAAA;AAJK,GAAP;AAMD","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.definitionToStoredType = exports.definitionToType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:ast:import\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst Compiler = __importStar(require(\"../../compiler\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst import_1 = require(\"../../contexts/import\");\n//NOTE: the following function will *not* work for arbitrary nodes! It will,\n//however, work well enough for what we need.  I.e., it will:\n//1. work when given the actual variable definition as the node,\n//2. work when given an elementary type as the node,\n//3. work when given a user-defined type as the node,\n//4. produce something of the correct size in all cases.\n//Use beyond that is at your own risk!\n//NOTE: set forceLocation to *null* to force no location. leave it undefined\n//to not force a location.\nfunction definitionToType(definition, compilationId, compiler, forceLocation) {\n    let typeClass = Utils.typeClass(definition);\n    let typeHint = Utils.typeStringWithoutLocation(definition);\n    switch (typeClass) {\n        case \"bool\":\n            return {\n                typeClass,\n                typeHint\n            };\n        case \"address\": {\n            switch (Compiler.Utils.solidityFamily(compiler)) {\n                case \"unknown\": //I guess?\n                case \"pre-0.5.0\":\n                    return {\n                        typeClass,\n                        kind: \"general\",\n                        typeHint\n                    };\n                default:\n                    return {\n                        typeClass,\n                        kind: \"specific\",\n                        payable: Utils.typeIdentifier(definition) === \"t_address_payable\"\n                    };\n            }\n            break; //to satisfy typescript\n        }\n        case \"uint\": {\n            let bytes = Utils.specifiedSize(definition);\n            return {\n                typeClass,\n                bits: bytes * 8,\n                typeHint\n            };\n        }\n        case \"int\": {\n            //typeScript won't let me group these for some reason\n            let bytes = Utils.specifiedSize(definition);\n            return {\n                typeClass,\n                bits: bytes * 8,\n                typeHint\n            };\n        }\n        case \"fixed\": {\n            //typeScript won't let me group these for some reason\n            let bytes = Utils.specifiedSize(definition);\n            let places = Utils.decimalPlaces(definition);\n            return {\n                typeClass,\n                bits: bytes * 8,\n                places,\n                typeHint\n            };\n        }\n        case \"ufixed\": {\n            let bytes = Utils.specifiedSize(definition);\n            let places = Utils.decimalPlaces(definition);\n            return {\n                typeClass,\n                bits: bytes * 8,\n                places,\n                typeHint\n            };\n        }\n        case \"string\": {\n            if (forceLocation === null) {\n                return {\n                    typeClass,\n                    typeHint\n                };\n            }\n            let location = forceLocation || Utils.referenceType(definition);\n            return {\n                typeClass,\n                location,\n                typeHint\n            };\n        }\n        case \"bytes\": {\n            let length = Utils.specifiedSize(definition);\n            if (length !== null) {\n                return {\n                    typeClass,\n                    kind: \"static\",\n                    length,\n                    typeHint\n                };\n            }\n            else {\n                if (forceLocation === null) {\n                    return {\n                        typeClass,\n                        kind: \"dynamic\",\n                        typeHint\n                    };\n                }\n                let location = forceLocation || Utils.referenceType(definition);\n                return {\n                    typeClass,\n                    kind: \"dynamic\",\n                    location,\n                    typeHint\n                };\n            }\n        }\n        case \"array\": {\n            let baseDefinition = Utils.baseDefinition(definition);\n            let baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);\n            let location = forceLocation || Utils.referenceType(definition);\n            if (Utils.isDynamicArray(definition)) {\n                if (forceLocation !== null) {\n                    return {\n                        typeClass,\n                        baseType,\n                        kind: \"dynamic\",\n                        location,\n                        typeHint\n                    };\n                }\n                else {\n                    return {\n                        typeClass,\n                        baseType,\n                        kind: \"dynamic\",\n                        typeHint\n                    };\n                }\n            }\n            else {\n                let length = new bn_js_1.default(Utils.staticLengthAsString(definition));\n                if (forceLocation !== null) {\n                    return {\n                        typeClass,\n                        baseType,\n                        kind: \"static\",\n                        length,\n                        location,\n                        typeHint\n                    };\n                }\n                else {\n                    return {\n                        typeClass,\n                        baseType,\n                        kind: \"static\",\n                        length,\n                        typeHint\n                    };\n                }\n            }\n        }\n        case \"mapping\": {\n            let keyDefinition = Utils.keyDefinition(definition);\n            //note that we can skip the scopes argument here! that's only needed when\n            //a general node, rather than a declaration, is being passed in\n            let keyType = (definitionToType(keyDefinition, compilationId, compiler, null));\n            //suppress the location on the key type (it'll be given as memory but\n            //this is meaningless)\n            //also, we have to tell TypeScript ourselves that this will be an elementary\n            //type; it has no way of knowing that\n            debug(\"definition: %O\", definition);\n            let valueDefinition = Utils.valueDefinition(definition);\n            let valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);\n            if (forceLocation === null) {\n                return {\n                    typeClass,\n                    keyType,\n                    valueType\n                };\n            }\n            return {\n                typeClass,\n                keyType,\n                valueType,\n                location: \"storage\"\n            };\n        }\n        case \"function\": {\n            //WARNING! This case will not work unless given the actual\n            //definition!  It should return something *roughly* usable, though.\n            let visibility = Utils.visibility(definition); //undefined if bad node\n            let mutability = Utils.mutability(definition); //undefined if bad node\n            let [inputParameters, outputParameters] = Utils.parameters(definition) || [[], []]; //HACK\n            //note: don't force a location on these! use the listed location!\n            let inputParameterTypes = inputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n            let outputParameterTypes = outputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n            switch (visibility) {\n                case \"internal\":\n                    return {\n                        typeClass,\n                        visibility,\n                        mutability,\n                        inputParameterTypes,\n                        outputParameterTypes\n                    };\n                case \"external\":\n                    return {\n                        typeClass,\n                        visibility,\n                        kind: \"specific\",\n                        mutability,\n                        inputParameterTypes,\n                        outputParameterTypes\n                    };\n            }\n            break; //to satisfy typescript\n        }\n        case \"struct\": {\n            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n            let qualifiedName = typeHint.match(/struct (.*)/)[1];\n            let definingContractName;\n            let typeName;\n            if (qualifiedName.includes(\".\")) {\n                [definingContractName, typeName] = qualifiedName.split(\".\");\n            }\n            else {\n                typeName = qualifiedName;\n                //leave definingContractName undefined\n            }\n            if (forceLocation === null) {\n                if (definingContractName) {\n                    return {\n                        typeClass,\n                        kind: \"local\",\n                        id,\n                        typeName,\n                        definingContractName\n                    };\n                }\n                else {\n                    return {\n                        typeClass,\n                        kind: \"global\",\n                        id,\n                        typeName\n                    };\n                }\n            }\n            let location = forceLocation || Utils.referenceType(definition);\n            if (definingContractName) {\n                return {\n                    typeClass,\n                    kind: \"local\",\n                    id,\n                    typeName,\n                    definingContractName,\n                    location\n                };\n            }\n            else {\n                return {\n                    typeClass,\n                    kind: \"global\",\n                    id,\n                    typeName,\n                    location\n                };\n            }\n        }\n        case \"enum\": {\n            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n            let qualifiedName = typeHint.match(/enum (.*)/)[1];\n            let definingContractName;\n            let typeName;\n            if (qualifiedName.includes(\".\")) {\n                [definingContractName, typeName] = qualifiedName.split(\".\");\n            }\n            else {\n                typeName = qualifiedName;\n                //leave definingContractName undefined\n            }\n            if (definingContractName) {\n                return {\n                    typeClass,\n                    kind: \"local\",\n                    id,\n                    typeName,\n                    definingContractName\n                };\n            }\n            else {\n                return {\n                    typeClass,\n                    kind: \"global\",\n                    id,\n                    typeName\n                };\n            }\n        }\n        case \"userDefinedValueType\": {\n            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n            let definingContractName;\n            let typeName;\n            if (typeHint.includes(\".\")) {\n                [definingContractName, typeName] = typeHint.split(\".\");\n            }\n            else {\n                typeName = typeHint;\n                //leave definingContractName undefined\n            }\n            if (definingContractName) {\n                return {\n                    typeClass,\n                    kind: \"local\",\n                    id,\n                    typeName,\n                    definingContractName\n                };\n            }\n            else {\n                return {\n                    typeClass,\n                    kind: \"global\",\n                    id,\n                    typeName\n                };\n            }\n        }\n        case \"contract\": {\n            let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n            let typeName = typeHint.match(/(contract|library|interface) (.*)/)[2];\n            //note: we use the type string rather than the type identifier\n            //in order to avoid having to deal with the underscore problem\n            let contractKind = Utils.contractKind(definition);\n            return {\n                typeClass,\n                kind: \"native\",\n                id,\n                typeName,\n                contractKind\n            };\n        }\n        case \"magic\": {\n            let typeIdentifier = Utils.typeIdentifier(definition);\n            let variable = (typeIdentifier.match(/^t_magic_(.*)$/)[1]);\n            return {\n                typeClass,\n                variable\n            };\n        }\n    }\n}\nexports.definitionToType = definitionToType;\n//whereas the above takes variable definitions, this takes the actual type\n//definition\nfunction definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {\n    switch (definition.nodeType) {\n        case \"StructDefinition\": {\n            const { id, typeName, definingContractName, definingContract } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n            const memberTypes = definition.members.map(member => ({\n                name: member.name,\n                type: definitionToType(member, compilationId, compiler, null)\n            }));\n            if (definingContract) {\n                return {\n                    typeClass: \"struct\",\n                    kind: \"local\",\n                    id,\n                    typeName,\n                    definingContractName,\n                    definingContract,\n                    memberTypes\n                };\n            }\n            else {\n                return {\n                    typeClass: \"struct\",\n                    kind: \"global\",\n                    id,\n                    typeName,\n                    memberTypes\n                };\n            }\n        }\n        case \"EnumDefinition\": {\n            const { id, typeName, definingContractName, definingContract } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n            const options = definition.members.map(member => member.name);\n            if (definingContract) {\n                return {\n                    typeClass: \"enum\",\n                    kind: \"local\",\n                    id,\n                    typeName,\n                    definingContractName,\n                    definingContract,\n                    options\n                };\n            }\n            else {\n                return {\n                    typeClass: \"enum\",\n                    kind: \"global\",\n                    id,\n                    typeName,\n                    options\n                };\n            }\n        }\n        case \"UserDefinedValueTypeDefinition\": {\n            const { id, typeName, definingContractName, definingContract } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);\n            let underlyingType = definitionToType(definition.underlyingType, compilationId, compiler, null); //final null doesn't matter here\n            if (definingContract) {\n                return {\n                    typeClass: \"userDefinedValueType\",\n                    kind: \"local\",\n                    id,\n                    typeName,\n                    definingContractName,\n                    definingContract,\n                    underlyingType\n                };\n            }\n            else {\n                return {\n                    typeClass: \"userDefinedValueType\",\n                    kind: \"global\",\n                    id,\n                    typeName,\n                    underlyingType\n                };\n            }\n        }\n        case \"ContractDefinition\": {\n            let id = import_1.makeTypeId(definition.id, compilationId);\n            let typeName = definition.name;\n            let contractKind = definition.contractKind;\n            let payable = Utils.isContractPayable(definition);\n            return {\n                typeClass: \"contract\",\n                kind: \"native\",\n                id,\n                typeName,\n                contractKind,\n                payable\n            };\n        }\n    }\n}\nexports.definitionToStoredType = definitionToStoredType;\nfunction getDefiningInfo(definition, compilationId, compiler, referenceDeclarations) {\n    const id = import_1.makeTypeId(definition.id, compilationId);\n    let definingContractName;\n    let typeName;\n    if (definition.canonicalName) {\n        if (definition.canonicalName.includes(\".\")) {\n            [definingContractName, typeName] = definition.canonicalName.split(\".\");\n        }\n        else {\n            typeName = definition.canonicalName;\n        }\n    }\n    else {\n        //due to a bug, in 0.8.8 UDVTs lack a canonicalName.\n        //so we'll set typeName based on name instead of canonicalName,\n        //and set definingContractName below based on definingContract.\n        //(this does mean that we'll mess up a bit if referenceDeclarations\n        //is not passed... but realistically that shouldn't come up?  really the\n        //same kind of hapepns for every type)\n        typeName = definition.name;\n    }\n    let definingContract = undefined;\n    ;\n    if (referenceDeclarations) {\n        let contractDefinition = Object.values(referenceDeclarations).find(node => node.nodeType === \"ContractDefinition\" &&\n            node.nodes.some((subNode) => import_1.makeTypeId(subNode.id, compilationId) === id));\n        if (contractDefinition) {\n            definingContract = (definitionToStoredType(contractDefinition, compilationId, compiler)); //can skip reference declarations\n            if (!definingContractName) {\n                definingContractName = contractDefinition.name;\n            }\n        }\n    }\n    return {\n        definingContract,\n        definingContractName,\n        typeName,\n        id\n    };\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}