{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeLiteral = exports.decodeStack = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:stack:decode\");\n\nconst AbiData = __importStar(require(\"../../abi-data\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Memory = __importStar(require(\"../../memory\"));\n\nconst Storage = __importStar(require(\"../../storage\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeStack(dataType, pointer, info) {\n  let rawValue;\n\n  try {\n    rawValue = yield* read_1.default(pointer, info.state);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error);\n  }\n\n  const literalPointer = {\n    location: \"stackliteral\",\n    literal: rawValue\n  };\n  return yield* decodeLiteral(dataType, literalPointer, info);\n}\n\nexports.decodeStack = decodeStack;\n\nfunction* decodeLiteral(dataType, pointer, info) {\n  debug(\"type %O\", dataType);\n  debug(\"pointer %o\", pointer);\n\n  if (Format.Types.isReferenceType(dataType)) {\n    switch (dataType.location) {\n      case \"memory\":\n        //first: do we have a memory pointer? if so we can just dispatch to\n        //decodeMemoryReference\n        return yield* Memory.Decode.decodeMemoryReferenceByAddress(dataType, pointer, info);\n\n      case \"storage\":\n        //next: do we have a storage pointer (which may be a mapping)? if so, we can\n        //we dispatch to decodeStorageByAddress\n        return yield* Storage.Decode.decodeStorageReferenceByAddress(dataType, pointer, info);\n\n      case \"calldata\":\n        //next: do we have a calldata pointer?\n        //if it's a lookup type, it'll need special handling\n        if (dataType.typeClass === \"bytes\" || dataType.typeClass === \"string\" || dataType.typeClass === \"array\" && dataType.kind === \"dynamic\") {\n          const lengthAsBN = Conversion.toBN(pointer.literal.slice(Evm.Utils.WORD_SIZE));\n          const locationOnly = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n          return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, {\n            location: \"stackliteral\",\n            literal: locationOnly\n          }, info, {\n            abiPointerBase: 0,\n            lengthOverride: lengthAsBN\n          });\n        } else {\n          //multivalue case -- this case is straightforward\n          return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, pointer, info, {\n            abiPointerBase: 0 //let's be explicit\n\n          });\n        }\n\n    }\n  } //next: do we have an external function?  these work differently on the stack\n  //than elsewhere, so we can't just pass it on to decodeBasic.\n\n\n  if (dataType.typeClass === \"function\" && dataType.visibility === \"external\") {\n    let address = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n    let selectorWord = pointer.literal.slice(-Evm.Utils.WORD_SIZE);\n\n    if (!Basic.Decode.checkPaddingLeft(address, Evm.Utils.ADDRESS_SIZE) || !Basic.Decode.checkPaddingLeft(selectorWord, Evm.Utils.SELECTOR_SIZE)) {\n      return {\n        type: dataType,\n        kind: \"error\",\n        error: {\n          kind: \"FunctionExternalStackPaddingError\",\n          rawAddress: Conversion.toHexString(address),\n          rawSelector: Conversion.toHexString(selectorWord)\n        }\n      };\n    }\n\n    let selector = selectorWord.slice(-Evm.Utils.SELECTOR_SIZE);\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: yield* Basic.Decode.decodeExternalFunction(address, selector, info)\n    };\n  } //finally, if none of the above hold, we can just dispatch to decodeBasic.\n  //however, note that because we're on the stack, we use the permissive padding\n  //option so that errors won't result due to values with bad padding\n  //(of numeric or bytesN type, anyway)\n\n\n  return yield* Basic.Decode.decodeBasic(dataType, pointer, info, {\n    paddingMode: \"permissive\"\n  });\n}\n\nexports.decodeLiteral = decodeLiteral;","map":{"version":3,"sources":["../../../../lib/stack/decode/index.ts"],"names":[],"mappings":";AAAA;;;;AAIG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,oBAAZ,CAAd;;AAEA,MAAA,OAAA,GAAA,YAAA,CAAA,OAAA,CAAA,gBAAA,CAAA,CAAA;;AACA,MAAA,UAAA,GAAA,YAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AACA,MAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,YAAA,CAAA,OAAA,CAAA,eAAA,CAAA,CAAA;;AAGA,MAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAEA,UAAiB,WAAjB,CACE,QADF,EAEE,OAFF,EAGE,IAHF,EAGmB;AAEjB,MAAI,QAAJ;;AACA,MAAI;AACF,IAAA,QAAQ,GAAG,OAAO,MAAA,CAAA,OAAA,CAAK,OAAL,EAAc,IAAI,CAAC,KAAnB,CAAlB;AACD,GAFD,CAEE,OAAO,KAAP,EAAc;AACd,WAAO,QAAA,CAAA,mBAAA,CAAoB,QAApB,EAA8B,KAA9B,CAAP;AACD;;AACD,QAAM,cAAc,GAAgC;AAClD,IAAA,QAAQ,EAAE,cADwC;AAElD,IAAA,OAAO,EAAE;AAFyC,GAApD;AAIA,SAAO,OAAO,aAAa,CAAC,QAAD,EAAW,cAAX,EAA2B,IAA3B,CAA3B;AACD;;AAhBD,OAAA,CAAA,WAAA,GAAA,WAAA;;AAkBA,UAAiB,aAAjB,CACE,QADF,EAEE,OAFF,EAGE,IAHF,EAGmB;AAEjB,EAAA,KAAK,CAAC,SAAD,EAAY,QAAZ,CAAL;AACA,EAAA,KAAK,CAAC,YAAD,EAAe,OAAf,CAAL;;AAEA,MAAI,MAAM,CAAC,KAAP,CAAa,eAAb,CAA6B,QAA7B,CAAJ,EAA4C;AAC1C,YAAQ,QAAQ,CAAC,QAAjB;AACE,WAAK,QAAL;AACE;AACA;AACA,eAAO,OAAO,MAAM,CAAC,MAAP,CAAc,8BAAd,CACZ,QADY,EAEZ,OAFY,EAGZ,IAHY,CAAd;;AAMF,WAAK,SAAL;AACE;AACA;AACA,eAAO,OAAO,OAAO,CAAC,MAAR,CAAe,+BAAf,CACZ,QADY,EAEZ,OAFY,EAGZ,IAHY,CAAd;;AAMF,WAAK,UAAL;AACE;AAEA;AACA,YACE,QAAQ,CAAC,SAAT,KAAuB,OAAvB,IACA,QAAQ,CAAC,SAAT,KAAuB,QADvB,IAEC,QAAQ,CAAC,SAAT,KAAuB,OAAvB,IAAkC,QAAQ,CAAC,IAAT,KAAkB,SAHvD,EAIE;AACA,gBAAM,UAAU,GAAG,UAAU,CAAC,IAAX,CACjB,OAAO,CAAC,OAAR,CAAgB,KAAhB,CAAsB,GAAG,CAAC,KAAJ,CAAU,SAAhC,CADiB,CAAnB;AAGA,gBAAM,YAAY,GAAG,OAAO,CAAC,OAAR,CAAgB,KAAhB,CAAsB,CAAtB,EAAyB,GAAG,CAAC,KAAJ,CAAU,SAAnC,CAArB;AACA,iBAAO,OAAO,OAAO,CAAC,MAAR,CAAe,2BAAf,CACZ,QADY,EAEZ;AAAE,YAAA,QAAQ,EAAE,cAAZ;AAAqC,YAAA,OAAO,EAAE;AAA9C,WAFY,EAGZ,IAHY,EAIZ;AACE,YAAA,cAAc,EAAE,CADlB;AAEE,YAAA,cAAc,EAAE;AAFlB,WAJY,CAAd;AASD,SAlBD,MAkBO;AACL;AACA,iBAAO,OAAO,OAAO,CAAC,MAAR,CAAe,2BAAf,CACZ,QADY,EAEZ,OAFY,EAGZ,IAHY,EAIZ;AACE,YAAA,cAAc,EAAE,CADlB,CACoB;;AADpB,WAJY,CAAd;AAQD;;AAnDL;AAqDD,GA3DgB,CA6DjB;AACA;;;AACA,MAAI,QAAQ,CAAC,SAAT,KAAuB,UAAvB,IAAqC,QAAQ,CAAC,UAAT,KAAwB,UAAjE,EAA6E;AAC3E,QAAI,OAAO,GAAG,OAAO,CAAC,OAAR,CAAgB,KAAhB,CAAsB,CAAtB,EAAyB,GAAG,CAAC,KAAJ,CAAU,SAAnC,CAAd;AACA,QAAI,YAAY,GAAG,OAAO,CAAC,OAAR,CAAgB,KAAhB,CAAsB,CAAC,GAAG,CAAC,KAAJ,CAAU,SAAjC,CAAnB;;AACA,QACE,CAAC,KAAK,CAAC,MAAN,CAAa,gBAAb,CAA8B,OAA9B,EAAuC,GAAG,CAAC,KAAJ,CAAU,YAAjD,CAAD,IACA,CAAC,KAAK,CAAC,MAAN,CAAa,gBAAb,CAA8B,YAA9B,EAA4C,GAAG,CAAC,KAAJ,CAAU,aAAtD,CAFH,EAGE;AACA,aAAO;AACL,QAAA,IAAI,EAAE,QADD;AAEL,QAAA,IAAI,EAAE,OAFD;AAGL,QAAA,KAAK,EAAE;AACL,UAAA,IAAI,EAAE,mCADD;AAEL,UAAA,UAAU,EAAE,UAAU,CAAC,WAAX,CAAuB,OAAvB,CAFP;AAGL,UAAA,WAAW,EAAE,UAAU,CAAC,WAAX,CAAuB,YAAvB;AAHR;AAHF,OAAP;AASD;;AACD,QAAI,QAAQ,GAAG,YAAY,CAAC,KAAb,CAAmB,CAAC,GAAG,CAAC,KAAJ,CAAU,aAA9B,CAAf;AACA,WAAO;AACL,MAAA,IAAI,EAAE,QADD;AAEL,MAAA,IAAI,EAAE,OAFD;AAGL,MAAA,KAAK,EAAE,OAAO,KAAK,CAAC,MAAN,CAAa,sBAAb,CAAoC,OAApC,EAA6C,QAA7C,EAAuD,IAAvD;AAHT,KAAP;AAKD,GAtFgB,CAwFjB;AACA;AACA;AACA;;;AACA,SAAO,OAAO,KAAK,CAAC,MAAN,CAAa,WAAb,CAAyB,QAAzB,EAAmC,OAAnC,EAA4C,IAA5C,EAAkD;AAC9D,IAAA,WAAW,EAAE;AADiD,GAAlD,CAAd;AAGD;;AAlGD,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeLiteral = exports.decodeStack = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:stack:decode\");\nconst AbiData = __importStar(require(\"../../abi-data\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Memory = __importStar(require(\"../../memory\"));\nconst Storage = __importStar(require(\"../../storage\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction* decodeStack(dataType, pointer, info) {\n    let rawValue;\n    try {\n        rawValue = yield* read_1.default(pointer, info.state);\n    }\n    catch (error) {\n        return errors_1.handleDecodingError(dataType, error);\n    }\n    const literalPointer = {\n        location: \"stackliteral\",\n        literal: rawValue\n    };\n    return yield* decodeLiteral(dataType, literalPointer, info);\n}\nexports.decodeStack = decodeStack;\nfunction* decodeLiteral(dataType, pointer, info) {\n    debug(\"type %O\", dataType);\n    debug(\"pointer %o\", pointer);\n    if (Format.Types.isReferenceType(dataType)) {\n        switch (dataType.location) {\n            case \"memory\":\n                //first: do we have a memory pointer? if so we can just dispatch to\n                //decodeMemoryReference\n                return yield* Memory.Decode.decodeMemoryReferenceByAddress(dataType, pointer, info);\n            case \"storage\":\n                //next: do we have a storage pointer (which may be a mapping)? if so, we can\n                //we dispatch to decodeStorageByAddress\n                return yield* Storage.Decode.decodeStorageReferenceByAddress(dataType, pointer, info);\n            case \"calldata\":\n                //next: do we have a calldata pointer?\n                //if it's a lookup type, it'll need special handling\n                if (dataType.typeClass === \"bytes\" ||\n                    dataType.typeClass === \"string\" ||\n                    (dataType.typeClass === \"array\" && dataType.kind === \"dynamic\")) {\n                    const lengthAsBN = Conversion.toBN(pointer.literal.slice(Evm.Utils.WORD_SIZE));\n                    const locationOnly = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n                    return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, { location: \"stackliteral\", literal: locationOnly }, info, {\n                        abiPointerBase: 0,\n                        lengthOverride: lengthAsBN\n                    });\n                }\n                else {\n                    //multivalue case -- this case is straightforward\n                    return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, pointer, info, {\n                        abiPointerBase: 0 //let's be explicit\n                    });\n                }\n        }\n    }\n    //next: do we have an external function?  these work differently on the stack\n    //than elsewhere, so we can't just pass it on to decodeBasic.\n    if (dataType.typeClass === \"function\" && dataType.visibility === \"external\") {\n        let address = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n        let selectorWord = pointer.literal.slice(-Evm.Utils.WORD_SIZE);\n        if (!Basic.Decode.checkPaddingLeft(address, Evm.Utils.ADDRESS_SIZE) ||\n            !Basic.Decode.checkPaddingLeft(selectorWord, Evm.Utils.SELECTOR_SIZE)) {\n            return {\n                type: dataType,\n                kind: \"error\",\n                error: {\n                    kind: \"FunctionExternalStackPaddingError\",\n                    rawAddress: Conversion.toHexString(address),\n                    rawSelector: Conversion.toHexString(selectorWord)\n                }\n            };\n        }\n        let selector = selectorWord.slice(-Evm.Utils.SELECTOR_SIZE);\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: yield* Basic.Decode.decodeExternalFunction(address, selector, info)\n        };\n    }\n    //finally, if none of the above hold, we can just dispatch to decodeBasic.\n    //however, note that because we're on the stack, we use the permissive padding\n    //option so that errors won't result due to values with bad padding\n    //(of numeric or bytesN type, anyway)\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, {\n        paddingMode: \"permissive\"\n    });\n}\nexports.decodeLiteral = decodeLiteral;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}