{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abiParameterToType = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:import\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nfunction abiParameterToType(abi) {\n  let typeName = abi.type;\n  let typeHint = abi.internalType; //first: is it an array?\n\n  let arrayMatch = typeName.match(/(.*)\\[(\\d*)\\]$/);\n\n  if (arrayMatch) {\n    let baseTypeName = arrayMatch[1];\n    let lengthAsString = arrayMatch[2]; //may be empty!\n\n    let baseAbi = Object.assign(Object.assign({}, abi), {\n      type: baseTypeName\n    });\n    let baseType = abiParameterToType(baseAbi);\n\n    if (lengthAsString === \"\") {\n      return {\n        typeClass: \"array\",\n        kind: \"dynamic\",\n        baseType,\n        typeHint\n      };\n    } else {\n      let length = new bn_js_1.default(lengthAsString);\n      return {\n        typeClass: \"array\",\n        kind: \"static\",\n        length,\n        baseType,\n        typeHint\n      };\n    }\n  } //otherwise, here are the simple cases\n\n\n  let typeClass = typeName.match(/^([^0-9]+)/)[1];\n\n  switch (typeClass) {\n    case \"uint\":\n    case \"int\":\n      {\n        let bits = typeName.match(/^u?int([0-9]+)/)[1];\n        return {\n          typeClass,\n          bits: parseInt(bits),\n          typeHint\n        };\n      }\n\n    case \"bytes\":\n      let length = typeName.match(/^bytes([0-9]*)/)[1];\n\n      if (length === \"\") {\n        return {\n          typeClass,\n          kind: \"dynamic\",\n          typeHint\n        };\n      } else {\n        return {\n          typeClass,\n          kind: \"static\",\n          length: parseInt(length),\n          typeHint\n        };\n      }\n\n    case \"address\":\n      return {\n        typeClass,\n        kind: \"general\",\n        typeHint\n      };\n\n    case \"string\":\n    case \"bool\":\n      return {\n        typeClass,\n        typeHint\n      };\n\n    case \"fixed\":\n    case \"ufixed\":\n      {\n        let [_, bits, places] = typeName.match(/^u?fixed([0-9]+)x([0-9]+)/);\n        return {\n          typeClass,\n          bits: parseInt(bits),\n          places: parseInt(places),\n          typeHint\n        };\n      }\n\n    case \"function\":\n      return {\n        typeClass,\n        visibility: \"external\",\n        kind: \"general\",\n        typeHint\n      };\n\n    case \"tuple\":\n      let memberTypes = abi.components.map(component => ({\n        name: component.name || undefined,\n        type: abiParameterToType(component)\n      }));\n      return {\n        typeClass,\n        memberTypes,\n        typeHint\n      };\n  }\n}\n\nexports.abiParameterToType = abiParameterToType;","map":{"version":3,"sources":["../../../../lib/abi-data/import/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.abiParameterToType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:abi-data:import\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nfunction abiParameterToType(abi) {\n    let typeName = abi.type;\n    let typeHint = abi.internalType;\n    //first: is it an array?\n    let arrayMatch = typeName.match(/(.*)\\[(\\d*)\\]$/);\n    if (arrayMatch) {\n        let baseTypeName = arrayMatch[1];\n        let lengthAsString = arrayMatch[2]; //may be empty!\n        let baseAbi = Object.assign(Object.assign({}, abi), { type: baseTypeName });\n        let baseType = abiParameterToType(baseAbi);\n        if (lengthAsString === \"\") {\n            return {\n                typeClass: \"array\",\n                kind: \"dynamic\",\n                baseType,\n                typeHint\n            };\n        }\n        else {\n            let length = new bn_js_1.default(lengthAsString);\n            return {\n                typeClass: \"array\",\n                kind: \"static\",\n                length,\n                baseType,\n                typeHint\n            };\n        }\n    }\n    //otherwise, here are the simple cases\n    let typeClass = typeName.match(/^([^0-9]+)/)[1];\n    switch (typeClass) {\n        case \"uint\":\n        case \"int\": {\n            let bits = typeName.match(/^u?int([0-9]+)/)[1];\n            return {\n                typeClass,\n                bits: parseInt(bits),\n                typeHint\n            };\n        }\n        case \"bytes\":\n            let length = typeName.match(/^bytes([0-9]*)/)[1];\n            if (length === \"\") {\n                return {\n                    typeClass,\n                    kind: \"dynamic\",\n                    typeHint\n                };\n            }\n            else {\n                return {\n                    typeClass,\n                    kind: \"static\",\n                    length: parseInt(length),\n                    typeHint\n                };\n            }\n        case \"address\":\n            return {\n                typeClass,\n                kind: \"general\",\n                typeHint\n            };\n        case \"string\":\n        case \"bool\":\n            return {\n                typeClass,\n                typeHint\n            };\n        case \"fixed\":\n        case \"ufixed\": {\n            let [_, bits, places] = typeName.match(/^u?fixed([0-9]+)x([0-9]+)/);\n            return {\n                typeClass,\n                bits: parseInt(bits),\n                places: parseInt(places),\n                typeHint\n            };\n        }\n        case \"function\":\n            return {\n                typeClass,\n                visibility: \"external\",\n                kind: \"general\",\n                typeHint\n            };\n        case \"tuple\":\n            let memberTypes = abi.components.map(component => ({\n                name: component.name || undefined,\n                type: abiParameterToType(component)\n            }));\n            return {\n                typeClass,\n                memberTypes,\n                typeHint\n            };\n    }\n}\nexports.abiParameterToType = abiParameterToType;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}