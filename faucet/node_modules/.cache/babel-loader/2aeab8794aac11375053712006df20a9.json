{"ast":null,"code":"export function countToggledBits(n) {\n  let count = 0;\n\n  while (n > BigInt(0)) {\n    if (n & BigInt(1)) ++count;\n    n >>= BigInt(1);\n  }\n\n  return count;\n}\nexport function computeNextFlags(flags, nextSize) {\n  const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);\n  const preservedFlags = flags & allowedMask;\n  let numMissingFlags = countToggledBits(flags - preservedFlags);\n  let nFlags = preservedFlags;\n\n  for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {\n    if (!(nFlags & mask)) {\n      nFlags |= mask;\n      --numMissingFlags;\n    }\n  }\n\n  return nFlags;\n}\nexport function computeTogglePositions(chars, toggleCase) {\n  const positions = [];\n\n  for (let idx = chars.length - 1; idx !== -1; --idx) {\n    if (toggleCase(chars[idx]) !== chars[idx]) positions.push(idx);\n  }\n\n  return positions;\n}\nexport function computeFlagsFromChars(untoggledChars, toggledChars, togglePositions) {\n  let flags = BigInt(0);\n\n  for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n    if (untoggledChars[togglePositions[idx]] !== toggledChars[togglePositions[idx]]) {\n      flags |= mask;\n    }\n  }\n\n  return flags;\n}\nexport function applyFlagsOnChars(chars, flags, togglePositions, toggleCase) {\n  for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n    if (flags & mask) chars[togglePositions[idx]] = toggleCase(chars[togglePositions[idx]]);\n  }\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ToggleFlags.js"],"names":["countToggledBits","n","count","BigInt","computeNextFlags","flags","nextSize","allowedMask","preservedFlags","numMissingFlags","nFlags","mask","computeTogglePositions","chars","toggleCase","positions","idx","length","push","computeFlagsFromChars","untoggledChars","toggledChars","togglePositions","applyFlagsOnChars"],"mappings":"AAAA,OAAO,SAASA,gBAAT,CAA0BC,CAA1B,EAA6B;AAChC,MAAIC,KAAK,GAAG,CAAZ;;AACA,SAAOD,CAAC,GAAGE,MAAM,CAAC,CAAD,CAAjB,EAAsB;AAClB,QAAIF,CAAC,GAAGE,MAAM,CAAC,CAAD,CAAd,EACI,EAAED,KAAF;AACJD,IAAAA,CAAC,KAAKE,MAAM,CAAC,CAAD,CAAZ;AACH;;AACD,SAAOD,KAAP;AACH;AACD,OAAO,SAASE,gBAAT,CAA0BC,KAA1B,EAAiCC,QAAjC,EAA2C;AAC9C,QAAMC,WAAW,GAAG,CAACJ,MAAM,CAAC,CAAD,CAAN,IAAaA,MAAM,CAACG,QAAD,CAApB,IAAkCH,MAAM,CAAC,CAAD,CAA5D;AACA,QAAMK,cAAc,GAAGH,KAAK,GAAGE,WAA/B;AACA,MAAIE,eAAe,GAAGT,gBAAgB,CAACK,KAAK,GAAGG,cAAT,CAAtC;AACA,MAAIE,MAAM,GAAGF,cAAb;;AACA,OAAK,IAAIG,IAAI,GAAGR,MAAM,CAAC,CAAD,CAAtB,EAA2BQ,IAAI,IAAIJ,WAAR,IAAuBE,eAAe,KAAK,CAAtE,EAAyEE,IAAI,KAAKR,MAAM,CAAC,CAAD,CAAxF,EAA6F;AACzF,QAAI,EAAEO,MAAM,GAAGC,IAAX,CAAJ,EAAsB;AAClBD,MAAAA,MAAM,IAAIC,IAAV;AACA,QAAEF,eAAF;AACH;AACJ;;AACD,SAAOC,MAAP;AACH;AACD,OAAO,SAASE,sBAAT,CAAgCC,KAAhC,EAAuCC,UAAvC,EAAmD;AACtD,QAAMC,SAAS,GAAG,EAAlB;;AACA,OAAK,IAAIC,GAAG,GAAGH,KAAK,CAACI,MAAN,GAAe,CAA9B,EAAiCD,GAAG,KAAK,CAAC,CAA1C,EAA6C,EAAEA,GAA/C,EAAoD;AAChD,QAAIF,UAAU,CAACD,KAAK,CAACG,GAAD,CAAN,CAAV,KAA2BH,KAAK,CAACG,GAAD,CAApC,EACID,SAAS,CAACG,IAAV,CAAeF,GAAf;AACP;;AACD,SAAOD,SAAP;AACH;AACD,OAAO,SAASI,qBAAT,CAA+BC,cAA/B,EAA+CC,YAA/C,EAA6DC,eAA7D,EAA8E;AACjF,MAAIjB,KAAK,GAAGF,MAAM,CAAC,CAAD,CAAlB;;AACA,OAAK,IAAIa,GAAG,GAAG,CAAV,EAAaL,IAAI,GAAGR,MAAM,CAAC,CAAD,CAA/B,EAAoCa,GAAG,KAAKM,eAAe,CAACL,MAA5D,EAAoE,EAAED,GAAF,EAAOL,IAAI,KAAKR,MAAM,CAAC,CAAD,CAA1F,EAA+F;AAC3F,QAAIiB,cAAc,CAACE,eAAe,CAACN,GAAD,CAAhB,CAAd,KAAyCK,YAAY,CAACC,eAAe,CAACN,GAAD,CAAhB,CAAzD,EAAiF;AAC7EX,MAAAA,KAAK,IAAIM,IAAT;AACH;AACJ;;AACD,SAAON,KAAP;AACH;AACD,OAAO,SAASkB,iBAAT,CAA2BV,KAA3B,EAAkCR,KAAlC,EAAyCiB,eAAzC,EAA0DR,UAA1D,EAAsE;AACzE,OAAK,IAAIE,GAAG,GAAG,CAAV,EAAaL,IAAI,GAAGR,MAAM,CAAC,CAAD,CAA/B,EAAoCa,GAAG,KAAKM,eAAe,CAACL,MAA5D,EAAoE,EAAED,GAAF,EAAOL,IAAI,KAAKR,MAAM,CAAC,CAAD,CAA1F,EAA+F;AAC3F,QAAIE,KAAK,GAAGM,IAAZ,EACIE,KAAK,CAACS,eAAe,CAACN,GAAD,CAAhB,CAAL,GAA8BF,UAAU,CAACD,KAAK,CAACS,eAAe,CAACN,GAAD,CAAhB,CAAN,CAAxC;AACP;AACJ","sourcesContent":["export function countToggledBits(n) {\n    let count = 0;\n    while (n > BigInt(0)) {\n        if (n & BigInt(1))\n            ++count;\n        n >>= BigInt(1);\n    }\n    return count;\n}\nexport function computeNextFlags(flags, nextSize) {\n    const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);\n    const preservedFlags = flags & allowedMask;\n    let numMissingFlags = countToggledBits(flags - preservedFlags);\n    let nFlags = preservedFlags;\n    for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {\n        if (!(nFlags & mask)) {\n            nFlags |= mask;\n            --numMissingFlags;\n        }\n    }\n    return nFlags;\n}\nexport function computeTogglePositions(chars, toggleCase) {\n    const positions = [];\n    for (let idx = chars.length - 1; idx !== -1; --idx) {\n        if (toggleCase(chars[idx]) !== chars[idx])\n            positions.push(idx);\n    }\n    return positions;\n}\nexport function computeFlagsFromChars(untoggledChars, toggledChars, togglePositions) {\n    let flags = BigInt(0);\n    for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n        if (untoggledChars[togglePositions[idx]] !== toggledChars[togglePositions[idx]]) {\n            flags |= mask;\n        }\n    }\n    return flags;\n}\nexport function applyFlagsOnChars(chars, flags, togglePositions, toggleCase) {\n    for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {\n        if (flags & mask)\n            chars[togglePositions[idx]] = toggleCase(chars[togglePositions[idx]]);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}