{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst util = require('util');\n\nconst Decoder = require('./decoder');\n\nconst Simple = require('./simple');\n\nconst utils = require('./utils');\n\nconst constants = require('./constants');\n\nconst bignumber = require('bignumber.js').BigNumber;\n\nconst NoFilter = require('nofilter');\n\nconst MT = constants.MT;\nconst SYMS = constants.SYMS;\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\n\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {Object} [options={}] - options for creation\n   * @param {string} [options.separator='\\n'] - output between detected objects\n   * @param {boolean} [options.stream_errors=false] - put error info into the\n   *   output stream\n   * @param {number} [options.max_depth=-1] - -1 for \"until you run out of\n   *   memory\".  Set this to a finite positive number for un-trusted inputs.\n   *   Most standard inputs won't nest more than 100 or so levels; I've tested\n   *   into the millions before running out of memory.\n   */\n  constructor(options) {\n    const opts = Object.assign({\n      separator: '\\n',\n      stream_errors: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    const separator = opts.separator;\n    delete opts.separator;\n    const stream_errors = opts.stream_errors;\n    delete opts.stream_errors;\n    super(opts);\n    this.float_bytes = -1;\n    this.separator = separator;\n    this.stream_errors = stream_errors;\n    this.parser = new Decoder(opts);\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('data', this._on_data.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb);\n  }\n\n  _flush(cb) {\n    return this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er);\n        }\n\n        return cb();\n      } else {\n        return cb(er);\n      }\n    });\n  }\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {(Buffer|string)} input - the CBOR bytes to format\n   * @param {string} [encoding='hex'] - the encoding of input, ignored if\n   *   input is Buffer\n   * @param {function(Error, string): undefined} cb - callback\n   * @returns {Promise} if callback not specified\n   */\n\n\n  static diagnose(input, encoding, cb) {\n    if (input == null) {\n      throw new Error('input required');\n    }\n\n    let opts = {};\n    let encod = 'hex';\n\n    switch (typeof encoding) {\n      case 'function':\n        cb = encoding;\n        encod = utils.guessEncoding(input);\n        break;\n\n      case 'object':\n        opts = utils.extend({}, encoding);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n        break;\n\n      default:\n        encod = encoding != null ? encoding : 'hex';\n    }\n\n    const bs = new NoFilter();\n    const d = new Diagnose(opts);\n    let p = null;\n\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')));\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')));\n        return d.on('error', reject);\n      });\n    }\n\n    d.pipe(bs);\n    d.end(input, encod);\n    return p;\n  }\n\n  _on_error(er) {\n    if (this.stream_errors) {\n      return this.push(er.toString());\n    } else {\n      return this.emit('error', er);\n    }\n  }\n\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      return this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len];\n    }\n  }\n\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          return this.push(', ');\n        }\n\n        break;\n\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            return this.push(': ');\n          } else {\n            return this.push(', ');\n          }\n        }\n\n    }\n  }\n\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return;\n    }\n\n    this._fore(parent_mt, pos);\n\n    return this.push((() => {\n      switch (false) {\n        case val !== SYMS.NULL:\n          return 'null';\n\n        case val !== SYMS.UNDEFINED:\n          return 'undefined';\n\n        case typeof val !== 'string':\n          return JSON.stringify(val);\n\n        case !(this.float_bytes > 0):\n          const fb = this.float_bytes;\n          this.float_bytes = -1;\n          return util.inspect(val) + '_' + fb;\n\n        case !Buffer.isBuffer(val):\n          return 'h\\'' + val.toString('hex') + '\\'';\n\n        case !(val instanceof bignumber):\n          return val.toString();\n\n        default:\n          return util.inspect(val);\n      }\n    })());\n  }\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos);\n\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`);\n        break;\n\n      case MT.ARRAY:\n        this.push('[');\n        break;\n\n      case MT.MAP:\n        this.push('{');\n        break;\n\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(');\n        break;\n    }\n\n    if (tag === SYMS.STREAM) {\n      return this.push('_ ');\n    }\n  }\n\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        return this.push(')');\n\n      case MT.ARRAY:\n        return this.push(']');\n\n      case MT.MAP:\n        return this.push('}');\n\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        return this.push(')');\n    }\n  }\n\n  _on_data() {\n    return this.push(this.separator);\n  }\n\n}\n\nmodule.exports = Diagnose;","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/cbor/lib/diagnose.js"],"names":["stream","require","util","Decoder","Simple","utils","constants","bignumber","BigNumber","NoFilter","MT","SYMS","Diagnose","Transform","constructor","options","opts","Object","assign","separator","stream_errors","readableObjectMode","writableObjectMode","float_bytes","parser","on","_on_more","bind","_on_value","_on_start","_on_stop","_on_data","_on_error","_transform","fresh","encoding","cb","write","_flush","er","diagnose","input","Error","encod","guessEncoding","extend","bs","d","p","toString","Promise","resolve","reject","pipe","end","push","emit","mt","len","parent_mt","pos","SIMPLE_FLOAT","_fore","BYTE_STRING","UTF8_STRING","ARRAY","MAP","val","BREAK","NULL","UNDEFINED","JSON","stringify","fb","inspect","Buffer","isBuffer","tag","TAG","STREAM","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stream = require('stream')\nconst util = require('util')\nconst Decoder = require('./decoder')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst constants = require('./constants')\nconst bignumber = require('bignumber.js').BigNumber\nconst NoFilter = require('nofilter')\n\nconst MT = constants.MT\nconst SYMS = constants.SYMS\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\nclass Diagnose extends stream.Transform {\n\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {Object} [options={}] - options for creation\n   * @param {string} [options.separator='\\n'] - output between detected objects\n   * @param {boolean} [options.stream_errors=false] - put error info into the\n   *   output stream\n   * @param {number} [options.max_depth=-1] - -1 for \"until you run out of\n   *   memory\".  Set this to a finite positive number for un-trusted inputs.\n   *   Most standard inputs won't nest more than 100 or so levels; I've tested\n   *   into the millions before running out of memory.\n   */\n  constructor(options) {\n    const opts = Object.assign({\n      separator: '\\n',\n      stream_errors: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    })\n    const separator = opts.separator\n    delete opts.separator\n    const stream_errors = opts.stream_errors\n    delete opts.stream_errors\n    super(opts)\n\n    this.float_bytes = -1\n    this.separator = separator\n    this.stream_errors = stream_errors\n    this.parser = new Decoder(opts)\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('data', this._on_data.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb)\n  }\n\n  _flush(cb) {\n    return this.parser._flush((er) => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er)\n        }\n        return cb()\n      } else {\n        return cb(er)\n      }\n    })\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {(Buffer|string)} input - the CBOR bytes to format\n   * @param {string} [encoding='hex'] - the encoding of input, ignored if\n   *   input is Buffer\n   * @param {function(Error, string): undefined} cb - callback\n   * @returns {Promise} if callback not specified\n   */\n  static diagnose(input, encoding, cb) {\n    if (input == null) {\n      throw new Error('input required')\n    }\n    let opts = {}\n    let encod = 'hex'\n    switch (typeof encoding) {\n      case 'function':\n        cb = encoding\n        encod = utils.guessEncoding(input)\n        break\n      case 'object':\n        opts = utils.extend({}, encoding)\n        encod = (opts.encoding != null) ?\n          opts.encoding : utils.guessEncoding(input)\n        delete opts.encoding\n        break\n      default:\n        encod = (encoding != null) ? encoding : 'hex'\n    }\n    const bs = new NoFilter()\n    const d = new Diagnose(opts)\n    let p = null\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')))\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')))\n        return d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    d.end(input, encod)\n    return p\n  }\n\n  _on_error(er) {\n    if (this.stream_errors) {\n      return this.push(er.toString())\n    } else {\n      return this.emit('error', er)\n    }\n  }\n\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      return this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len]\n    }\n  }\n\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          return this.push(', ')\n        }\n        break\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            return this.push(': ')\n          } else {\n            return this.push(', ')\n          }\n        }\n    }\n  }\n\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return\n    }\n    this._fore(parent_mt, pos)\n    return this.push((() => {\n      switch (false) {\n        case val !== SYMS.NULL:\n          return 'null'\n        case val !== SYMS.UNDEFINED:\n          return 'undefined'\n        case typeof val !== 'string':\n          return JSON.stringify(val)\n        case !(this.float_bytes > 0):\n          const fb = this.float_bytes\n          this.float_bytes = -1\n          return (util.inspect(val)) + '_' + fb\n        case !Buffer.isBuffer(val):\n          return 'h\\'' + (val.toString('hex')) + '\\''\n        case !(val instanceof bignumber):\n          return val.toString()\n        default:\n          return util.inspect(val)\n      }\n    })())\n  }\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos)\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`)\n        break\n      case MT.ARRAY:\n        this.push('[')\n        break\n      case MT.MAP:\n        this.push('{')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(')\n        break\n    }\n    if (tag === SYMS.STREAM) {\n      return this.push('_ ')\n    }\n  }\n\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        return this.push(')')\n      case MT.ARRAY:\n        return this.push(']')\n      case MT.MAP:\n        return this.push('}')\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        return this.push(')')\n    }\n  }\n\n  _on_data() {\n    return this.push(this.separator)\n  }\n}\n\nmodule.exports = Diagnose\n"]},"metadata":{},"sourceType":"script"}