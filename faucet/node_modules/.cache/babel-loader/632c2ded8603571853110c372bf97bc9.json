{"ast":null,"code":"import { add64, isEqual64, isStrictlyPositive64, isStrictlySmaller64, substract64, Unit64 } from '../_internals/helpers/ArrayInt64.js';\nimport { arrayInt64 } from '../_internals/ArrayInt64Arbitrary.js';\nimport { doubleToIndex, indexToDouble } from '../_internals/helpers/DoubleHelpers.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\n\nfunction safeDoubleToIndex(d, constraintsLabel) {\n  if (Number.isNaN(d)) {\n    throw new Error('fc.doubleNext constraints.' + constraintsLabel + ' must be a 32-bit float');\n  }\n\n  return doubleToIndex(d);\n}\n\nfunction unmapperDoubleToIndex(value) {\n  if (typeof value !== 'number') throw new Error('Unsupported type');\n  return doubleToIndex(value);\n}\n\nexport function doubleNext() {\n  let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    noDefaultInfinity = false,\n    noNaN = false,\n    min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY,\n    max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY\n  } = constraints;\n  const minIndex = safeDoubleToIndex(min, 'min');\n  const maxIndex = safeDoubleToIndex(max, 'max');\n\n  if (isStrictlySmaller64(maxIndex, minIndex)) {\n    throw new Error('fc.doubleNext constraints.min must be smaller or equal to constraints.max');\n  }\n\n  if (noNaN) {\n    return convertFromNext(convertToNext(arrayInt64(minIndex, maxIndex)).map(indexToDouble, unmapperDoubleToIndex));\n  }\n\n  const positiveMaxIdx = isStrictlyPositive64(maxIndex);\n  const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);\n  const maxIndexWithNaN = positiveMaxIdx ? add64(maxIndex, Unit64) : maxIndex;\n  return convertFromNext(convertToNext(arrayInt64(minIndexWithNaN, maxIndexWithNaN)).map(index => {\n    if (isStrictlySmaller64(maxIndex, index) || isStrictlySmaller64(index, minIndex)) return Number.NaN;else return indexToDouble(index);\n  }, value => {\n    if (typeof value !== 'number') throw new Error('Unsupported type');\n    if (Number.isNaN(value)) return !isEqual64(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n    return doubleToIndex(value);\n  }));\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_next/doubleNext.js"],"names":["add64","isEqual64","isStrictlyPositive64","isStrictlySmaller64","substract64","Unit64","arrayInt64","doubleToIndex","indexToDouble","convertFromNext","convertToNext","safeDoubleToIndex","d","constraintsLabel","Number","isNaN","Error","unmapperDoubleToIndex","value","doubleNext","constraints","noDefaultInfinity","noNaN","min","MAX_VALUE","NEGATIVE_INFINITY","max","POSITIVE_INFINITY","minIndex","maxIndex","map","positiveMaxIdx","minIndexWithNaN","maxIndexWithNaN","index","NaN"],"mappings":"AAAA,SAASA,KAAT,EAAgBC,SAAhB,EAA2BC,oBAA3B,EAAiDC,mBAAjD,EAAsEC,WAAtE,EAAmFC,MAAnF,QAAkG,qCAAlG;AACA,SAASC,UAAT,QAA2B,sCAA3B;AACA,SAASC,aAAT,EAAwBC,aAAxB,QAA6C,wCAA7C;AACA,SAASC,eAAT,EAA0BC,aAA1B,QAA+C,gDAA/C;;AACA,SAASC,iBAAT,CAA2BC,CAA3B,EAA8BC,gBAA9B,EAAgD;AAC5C,MAAIC,MAAM,CAACC,KAAP,CAAaH,CAAb,CAAJ,EAAqB;AACjB,UAAM,IAAII,KAAJ,CAAU,+BAA+BH,gBAA/B,GAAkD,yBAA5D,CAAN;AACH;;AACD,SAAON,aAAa,CAACK,CAAD,CAApB;AACH;;AACD,SAASK,qBAAT,CAA+BC,KAA/B,EAAsC;AAClC,MAAI,OAAOA,KAAP,KAAiB,QAArB,EACI,MAAM,IAAIF,KAAJ,CAAU,kBAAV,CAAN;AACJ,SAAOT,aAAa,CAACW,KAAD,CAApB;AACH;;AACD,OAAO,SAASC,UAAT,GAAsC;AAAA,MAAlBC,WAAkB,uEAAJ,EAAI;AACzC,QAAM;AAAEC,IAAAA,iBAAiB,GAAG,KAAtB;AAA6BC,IAAAA,KAAK,GAAG,KAArC;AAA4CC,IAAAA,GAAG,GAAGF,iBAAiB,GAAG,CAACP,MAAM,CAACU,SAAX,GAAuBV,MAAM,CAACW,iBAAjG;AAAoHC,IAAAA,GAAG,GAAGL,iBAAiB,GAAGP,MAAM,CAACU,SAAV,GAAsBV,MAAM,CAACa;AAAxK,MAA+LP,WAArM;AACA,QAAMQ,QAAQ,GAAGjB,iBAAiB,CAACY,GAAD,EAAM,KAAN,CAAlC;AACA,QAAMM,QAAQ,GAAGlB,iBAAiB,CAACe,GAAD,EAAM,KAAN,CAAlC;;AACA,MAAIvB,mBAAmB,CAAC0B,QAAD,EAAWD,QAAX,CAAvB,EAA6C;AACzC,UAAM,IAAIZ,KAAJ,CAAU,2EAAV,CAAN;AACH;;AACD,MAAIM,KAAJ,EAAW;AACP,WAAOb,eAAe,CAACC,aAAa,CAACJ,UAAU,CAACsB,QAAD,EAAWC,QAAX,CAAX,CAAb,CAA8CC,GAA9C,CAAkDtB,aAAlD,EAAiES,qBAAjE,CAAD,CAAtB;AACH;;AACD,QAAMc,cAAc,GAAG7B,oBAAoB,CAAC2B,QAAD,CAA3C;AACA,QAAMG,eAAe,GAAGD,cAAc,GAAGH,QAAH,GAAcxB,WAAW,CAACwB,QAAD,EAAWvB,MAAX,CAA/D;AACA,QAAM4B,eAAe,GAAGF,cAAc,GAAG/B,KAAK,CAAC6B,QAAD,EAAWxB,MAAX,CAAR,GAA6BwB,QAAnE;AACA,SAAOpB,eAAe,CAACC,aAAa,CAACJ,UAAU,CAAC0B,eAAD,EAAkBC,eAAlB,CAAX,CAAb,CAA4DH,GAA5D,CAAiEI,KAAD,IAAW;AAC9F,QAAI/B,mBAAmB,CAAC0B,QAAD,EAAWK,KAAX,CAAnB,IAAwC/B,mBAAmB,CAAC+B,KAAD,EAAQN,QAAR,CAA/D,EACI,OAAOd,MAAM,CAACqB,GAAd,CADJ,KAGI,OAAO3B,aAAa,CAAC0B,KAAD,CAApB;AACP,GALsB,EAKnBhB,KAAD,IAAW;AACV,QAAI,OAAOA,KAAP,KAAiB,QAArB,EACI,MAAM,IAAIF,KAAJ,CAAU,kBAAV,CAAN;AACJ,QAAIF,MAAM,CAACC,KAAP,CAAaG,KAAb,CAAJ,EACI,OAAO,CAACjB,SAAS,CAAC4B,QAAD,EAAWI,eAAX,CAAV,GAAwCA,eAAxC,GAA0DD,eAAjE;AACJ,WAAOzB,aAAa,CAACW,KAAD,CAApB;AACH,GAXsB,CAAD,CAAtB;AAYH","sourcesContent":["import { add64, isEqual64, isStrictlyPositive64, isStrictlySmaller64, substract64, Unit64, } from '../_internals/helpers/ArrayInt64.js';\nimport { arrayInt64 } from '../_internals/ArrayInt64Arbitrary.js';\nimport { doubleToIndex, indexToDouble } from '../_internals/helpers/DoubleHelpers.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\nfunction safeDoubleToIndex(d, constraintsLabel) {\n    if (Number.isNaN(d)) {\n        throw new Error('fc.doubleNext constraints.' + constraintsLabel + ' must be a 32-bit float');\n    }\n    return doubleToIndex(d);\n}\nfunction unmapperDoubleToIndex(value) {\n    if (typeof value !== 'number')\n        throw new Error('Unsupported type');\n    return doubleToIndex(value);\n}\nexport function doubleNext(constraints = {}) {\n    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY, } = constraints;\n    const minIndex = safeDoubleToIndex(min, 'min');\n    const maxIndex = safeDoubleToIndex(max, 'max');\n    if (isStrictlySmaller64(maxIndex, minIndex)) {\n        throw new Error('fc.doubleNext constraints.min must be smaller or equal to constraints.max');\n    }\n    if (noNaN) {\n        return convertFromNext(convertToNext(arrayInt64(minIndex, maxIndex)).map(indexToDouble, unmapperDoubleToIndex));\n    }\n    const positiveMaxIdx = isStrictlyPositive64(maxIndex);\n    const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);\n    const maxIndexWithNaN = positiveMaxIdx ? add64(maxIndex, Unit64) : maxIndex;\n    return convertFromNext(convertToNext(arrayInt64(minIndexWithNaN, maxIndexWithNaN)).map((index) => {\n        if (isStrictlySmaller64(maxIndex, index) || isStrictlySmaller64(index, minIndex))\n            return Number.NaN;\n        else\n            return indexToDouble(index);\n    }, (value) => {\n        if (typeof value !== 'number')\n            throw new Error('Unsupported type');\n        if (Number.isNaN(value))\n            return !isEqual64(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n        return doubleToIndex(value);\n    }));\n}\n"]},"metadata":{},"sourceType":"module"}