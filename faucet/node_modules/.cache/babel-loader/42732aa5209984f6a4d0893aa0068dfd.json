{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeNativize = exports.unsafeNativizeVariables = exports.ResultInspector = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:format:utils:inspect\");\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst Format = __importStar(require(\"../common\"));\n\nconst Exception = __importStar(require(\"./exception\")); //HACK -- inspect options are ridiculous, I swear >_>\n\n\nfunction cleanStylize(options) {\n  return Object.assign({}, ...Object.entries(options).map(_ref => {\n    let [key, value] = _ref;\n    return key === \"stylize\" ? {} : {\n      [key]: value\n    };\n  }));\n}\n/**\n * This class is meant to be used with Node's\n * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)\n * function.  Given a [[Format.Values.Result]] `value`, one can use\n * `new ResultInspector(value)` to create a ResultInspector for that value,\n * which can be used with util.inspect() to create a human-readable string\n * representing the value.\n *\n * @example\n * Suppose `value` is a Result.  In Node, the following would print to the\n * console a human-readable representation of `value`, with colors enabled,\n * no maximum depth, and no maximum array length, and lines (usually) no\n * longer than 80 characters:\n * ```javascript\n * console.log(\n *   util.inspect(\n *     new ResultInspector(value),\n *     {\n *       colors: true,\n *       depth: null,\n *       maxArrayLength: null,\n *       breakLength: 80\n *     }\n *   )\n * );\n * ```\n * Of course, there are many other ways to use util.inspect; see Node's\n * documentation, linked above, for more.\n */\n\n\nclass ResultInspector {\n  constructor(result) {\n    this.result = result;\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.result.kind) {\n      case \"value\":\n        switch (this.result.type.typeClass) {\n          case \"uint\":\n          case \"int\":\n            return options.stylize(this.result.value.asBN.toString(), \"number\");\n\n          case \"fixed\":\n          case \"ufixed\":\n            //note: because this is just for display, we don't bother adjusting the magic values Big.NE or Big.PE;\n            //we'll trust those to their defaults\n            return options.stylize(this.result.value.asBig.toString(), \"number\");\n\n          case \"bool\":\n            return util_1.default.inspect(this.result.value.asBoolean, options);\n\n          case \"bytes\":\n            let hex = this.result.value.asHex;\n\n            switch (this.result.type.kind) {\n              case \"static\":\n                return options.stylize(hex, \"number\");\n\n              case \"dynamic\":\n                return options.stylize(`hex'${hex.slice(2)}'`, \"string\");\n            }\n\n          case \"address\":\n            return options.stylize(this.result.value.asAddress, \"number\");\n\n          case \"string\":\n            {\n              let coercedResult = this.result;\n\n              switch (coercedResult.value.kind) {\n                case \"valid\":\n                  return util_1.default.inspect(coercedResult.value.asString, options);\n\n                case \"malformed\":\n                  //note: this will turn malformed utf-8 into replacement characters (U+FFFD)\n                  //note we need to cut off the 0x prefix\n                  return util_1.default.inspect(Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString());\n              }\n            }\n\n          case \"array\":\n            {\n              let coercedResult = this.result;\n\n              if (coercedResult.reference !== undefined) {\n                return formatCircular(coercedResult.reference, options);\n              }\n\n              return util_1.default.inspect(coercedResult.value.map(element => new ResultInspector(element)), options);\n            }\n\n          case \"mapping\":\n            return util_1.default.inspect(new Map(this.result.value.map(_ref2 => {\n              let {\n                key,\n                value\n              } = _ref2;\n              return [new ResultInspector(key), new ResultInspector(value)];\n            })), options);\n\n          case \"struct\":\n            {\n              let coercedResult = this.result;\n\n              if (coercedResult.reference !== undefined) {\n                return formatCircular(coercedResult.reference, options);\n              }\n\n              return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(_ref3 => {\n                let {\n                  name,\n                  value\n                } = _ref3;\n                return {\n                  [name]: new ResultInspector(value)\n                };\n              })), options);\n            }\n\n          case \"userDefinedValueType\":\n            {\n              const typeName = Format.Types.typeStringWithoutLocation(this.result.type);\n              const coercedResult = this.result;\n              const inspectOfUnderlying = util_1.default.inspect(new ResultInspector(coercedResult.value), options);\n              return `${typeName}.wrap(${inspectOfUnderlying})`; //note only the underlying part is stylized\n            }\n\n          case \"tuple\":\n            {\n              let coercedResult = this.result; //if everything is named, do same as with struct.\n              //if not, just do an array.\n              //(good behavior in the mixed case is hard, unfortunately)\n\n              if (coercedResult.value.every(_ref4 => {\n                let {\n                  name\n                } = _ref4;\n                return name;\n              })) {\n                return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(_ref5 => {\n                  let {\n                    name,\n                    value\n                  } = _ref5;\n                  return {\n                    [name]: new ResultInspector(value)\n                  };\n                })), options);\n              } else {\n                return util_1.default.inspect(coercedResult.value.map(_ref6 => {\n                  let {\n                    value\n                  } = _ref6;\n                  return new ResultInspector(value);\n                }), options);\n              }\n            }\n\n          case \"type\":\n            {\n              switch (this.result.type.type.typeClass) {\n                case \"contract\":\n                  //same as struct case but w/o circularity check\n                  return util_1.default.inspect(Object.assign({}, ...this.result.value.map(_ref7 => {\n                    let {\n                      name,\n                      value\n                    } = _ref7;\n                    return {\n                      [name]: new ResultInspector(value)\n                    };\n                  })), options);\n\n                case \"enum\":\n                  {\n                    return enumTypeName(this.result.type.type);\n                  }\n              }\n            }\n\n          case \"magic\":\n            return util_1.default.inspect(Object.assign({}, ...Object.entries(this.result.value).map(_ref8 => {\n              let [key, value] = _ref8;\n              return {\n                [key]: new ResultInspector(value)\n              };\n            })), options);\n\n          case \"enum\":\n            {\n              return enumFullName(this.result); //not stylized\n            }\n\n          case \"contract\":\n            {\n              return util_1.default.inspect(new ContractInfoInspector(this.result.value), options);\n            }\n\n          case \"function\":\n            switch (this.result.type.visibility) {\n              case \"external\":\n                {\n                  let coercedResult = this.result;\n                  let contractString = util_1.default.inspect(new ContractInfoInspector(coercedResult.value.contract), Object.assign(Object.assign({}, cleanStylize(options)), {\n                    colors: false\n                  }));\n                  let firstLine;\n\n                  switch (coercedResult.value.kind) {\n                    case \"known\":\n                      firstLine = `[Function: ${coercedResult.value.abi.name} of`;\n                      break;\n\n                    case \"invalid\":\n                    case \"unknown\":\n                      firstLine = `[Function: Unknown selector ${coercedResult.value.selector} of`;\n                      break;\n                  }\n\n                  let secondLine = `${contractString}]`;\n                  let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \"; //now, put it together\n\n                  return options.stylize(firstLine + breakingSpace + secondLine, \"special\");\n                }\n\n              case \"internal\":\n                {\n                  let coercedResult = this.result;\n\n                  switch (coercedResult.value.kind) {\n                    case \"function\":\n                      if (coercedResult.value.definedIn) {\n                        return options.stylize(`[Function: ${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}]`, \"special\");\n                      } else {\n                        return options.stylize(`[Function: ${coercedResult.value.name}]`, \"special\");\n                      }\n\n                    case \"exception\":\n                      return coercedResult.value.deployedProgramCounter === 0 ? options.stylize(`[Function: <zero>]`, \"special\") : options.stylize(`[Function: <uninitialized>]`, \"special\");\n\n                    case \"unknown\":\n                      let firstLine = `[Function: decoding not supported (raw info:`;\n                      let secondLine = `deployed PC=${coercedResult.value.deployedProgramCounter}, constructor PC=${coercedResult.value.constructorProgramCounter})]`;\n                      let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \"; //now, put it together\n\n                      return options.stylize(firstLine + breakingSpace + secondLine, \"special\");\n                  }\n                }\n            }\n\n        }\n\n      case \"error\":\n        {\n          debug(\"this.result: %O\", this.result);\n          let errorResult = this.result; //the hell?? why couldn't it make this inference??\n\n          switch (errorResult.error.kind) {\n            case \"WrappedError\":\n              return util_1.default.inspect(new ResultInspector(errorResult.error.error), options);\n\n            case \"UintPaddingError\":\n              return `Uint has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"IntPaddingError\":\n              return `Int has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"UintPaddingError\":\n              return `Ufixed has (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"FixedPaddingError\":\n              return `Fixed has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"BoolOutOfRangeError\":\n              return `Invalid boolean (numeric value ${errorResult.error.rawAsBN.toString()})`;\n\n            case \"BoolPaddingError\":\n              return `Boolean has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"BytesPaddingError\":\n              return `Bytestring has extra trailing bytes (padding error) (raw value ${errorResult.error.raw})`;\n\n            case \"AddressPaddingError\":\n              return `Address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"EnumOutOfRangeError\":\n              return `Invalid ${enumTypeName(errorResult.error.type)} (numeric value ${errorResult.error.rawAsBN.toString()})`;\n\n            case \"EnumPaddingError\":\n              return `Enum ${enumTypeName(errorResult.error.type)} has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"EnumNotFoundDecodingError\":\n              return `Unknown enum type ${enumTypeName(errorResult.error.type)} of id ${errorResult.error.type.id} (numeric value ${errorResult.error.rawAsBN.toString()})`;\n\n            case \"ContractPaddingError\":\n              return `Contract address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"FunctionExternalNonStackPaddingError\":\n              return `External function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"FunctionExternalStackPaddingError\":\n              return `External function address or selector has extra leading bytes (padding error) (raw address ${errorResult.error.rawAddress}, raw selector ${errorResult.error.rawSelector})`;\n\n            case \"FunctionInternalPaddingError\":\n              return `Internal function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n\n            case \"NoSuchInternalFunctionError\":\n              return `Invalid function (Deployed PC=${errorResult.error.deployedProgramCounter}, constructor PC=${errorResult.error.constructorProgramCounter}) of contract ${errorResult.error.context.typeName}`;\n\n            case \"DeployedFunctionInConstructorError\":\n              return `Deployed-style function (PC=${errorResult.error.deployedProgramCounter}) in constructor`;\n\n            case \"MalformedInternalFunctionError\":\n              return `Malformed internal function w/constructor PC only (value: ${errorResult.error.constructorProgramCounter})`;\n\n            case \"IndexedReferenceTypeError\":\n              //for this one we'll bother with some line-wrapping\n              let firstLine = `Cannot decode indexed parameter of reference type ${errorResult.error.type.typeClass}`;\n              let secondLine = `(raw value ${errorResult.error.raw})`;\n              let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \";\n              return firstLine + breakingSpace + secondLine;\n\n            case \"OverlongArraysAndStringsNotImplementedError\":\n              return `Array or string is too long (length ${errorResult.error.lengthAsBN.toString()}); decoding is not supported`;\n\n            case \"OverlargePointersNotImplementedError\":\n              return `Pointer is too large (value ${errorResult.error.pointerAsBN.toString()}); decoding is not supported`;\n\n            case \"UserDefinedTypeNotFoundError\":\n            case \"UnsupportedConstantError\":\n            case \"UnusedImmutableError\":\n            case \"ReadErrorStack\":\n            case \"ReadErrorStorage\":\n            case \"ReadErrorBytes\":\n              return Exception.message(errorResult.error);\n            //yay, these five are already defined!\n          }\n        }\n    }\n  }\n\n}\n\nexports.ResultInspector = ResultInspector; //these get their own class to deal with a minor complication\n\nclass ContractInfoInspector {\n  constructor(value) {\n    this.value = value;\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.value.kind) {\n      case \"known\":\n        return options.stylize(this.value.address, \"number\") + ` (${this.value.class.typeName})`;\n\n      case \"unknown\":\n        return options.stylize(this.value.address, \"number\") + \" of unknown class\";\n    }\n  }\n\n}\n\nfunction enumTypeName(enumType) {\n  return (enumType.kind === \"local\" ? enumType.definingContractName + \".\" : \"\") + enumType.typeName;\n} //this function will be used in the future for displaying circular\n//structures\n\n\nfunction formatCircular(loopLength, options) {\n  return options.stylize(`[Circular (=up ${loopLength})]`, \"special\");\n}\n\nfunction enumFullName(value) {\n  switch (value.type.kind) {\n    case \"local\":\n      return `${value.type.definingContractName}.${value.type.typeName}.${value.value.name}`;\n\n    case \"global\":\n      return `${value.type.typeName}.${value.value.name}`;\n  }\n}\n/**\n * WARNING! Do NOT use this function in real code unless you\n * absolutely have to!  Using it in controlled tests is fine,\n * but do NOT use it in real code if you have any better option!\n * See [[unsafeNativize]] for why!\n */\n\n\nfunction unsafeNativizeVariables(variables) {\n  return Object.assign({}, ...Object.entries(variables).map(_ref9 => {\n    let [name, value] = _ref9;\n\n    try {\n      return {\n        [name]: unsafeNativize(value)\n      };\n    } catch (_) {\n      return undefined; //I guess??\n    }\n  }));\n}\n\nexports.unsafeNativizeVariables = unsafeNativizeVariables; //HACK! Avoid using!\n\n/**\n * WARNING! Do NOT use this function in real code unless you absolutely have\n * to!  Using it in controlled tests is fine, but do NOT use it in real code if\n * you have any better option!\n *\n * This function is a giant hack.  It will throw exceptions on numbers that\n * don't fit in a Javascript number.  It loses various information.  It was\n * only ever written to support our hacked-together watch expression system,\n * and later repurposed to make testing easier.\n *\n * If you are not doing something as horrible as evaluating user-inputted\n * Javascript expressions meant to operate upon Solidity variables, then you\n * probably have a better option than using this in real code!\n *\n * (For instance, if you just want to nicely print individual values, without\n * attempting to first operate on them via Javascript expressions, we have the\n * [[ResultInspector]] class, which can be used with Node's\n * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)\n * to do exactly that.)\n *\n * Remember, the decoder output format was made to be machine-readable.  It\n * shouldn't be too hard for you to process.  If it comes to it, copy-paste\n * this code and dehackify it for your use case, which hopefully is more\n * manageable than the one that caused us to write this.\n */\n\nfunction unsafeNativize(result) {\n  return unsafeNativizeWithTable(result, []);\n}\n\nexports.unsafeNativize = unsafeNativize;\n\nfunction unsafeNativizeWithTable(result, seenSoFar) {\n  if (result.kind === \"error\") {\n    debug(\"ErrorResult: %O\", result);\n\n    switch (result.error.kind) {\n      case \"BoolOutOfRangeError\":\n        return true;\n\n      default:\n        return undefined;\n    }\n  } //NOTE: for simplicity, only arrays & structs will call unsafeNativizeWithTable;\n  //other containers will just call unsafeNativize because they can get away with it\n  //(only things that can *be* circular need unsafeNativizeWithTable, not things that\n  //can merely *contain* circularities)\n\n\n  switch (result.type.typeClass) {\n    case \"uint\":\n    case \"int\":\n      return result.value.asBN.toNumber();\n    //WARNING\n\n    case \"bool\":\n      return result.value.asBoolean;\n\n    case \"bytes\":\n      return result.value.asHex;\n\n    case \"address\":\n      return result.value.asAddress;\n\n    case \"string\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.value.kind) {\n          case \"valid\":\n            return coercedResult.value.asString;\n\n          case \"malformed\":\n            // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n            // note we need to cut off the 0x prefix\n            return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n        }\n      }\n\n    case \"fixed\":\n    case \"ufixed\":\n      //HACK: Big doesn't have a toNumber() method, so we convert to string and then parse with Number\n      //NOTE: we don't bother setting the magic variables Big.NE or Big.PE first, as the choice of\n      //notation shouldn't affect the result (can you believe I have to write this? @_@)\n      return Number(result.value.asBig.toString());\n    //WARNING\n\n    case \"array\":\n      {\n        let coercedResult = result;\n\n        if (coercedResult.reference === undefined) {\n          //we need to do some pointer stuff here, so let's first create our new\n          //object we'll be pointing to\n          //[we don't want to alter the original accidentally so let's clone a bit]\n          let output = [...coercedResult.value]; //now, we can't use a map here, or we'll screw things up!\n          //we want to *mutate* output, not replace it with a new object\n\n          for (let index in output) {\n            output[index] = unsafeNativizeWithTable(output[index], [output, ...seenSoFar]);\n          }\n\n          return output;\n        } else {\n          return seenSoFar[coercedResult.reference - 1];\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        return unsafeNativize(result.value);\n      }\n\n    case \"mapping\":\n      return Object.assign({}, ...result.value.map(_ref10 => {\n        let {\n          key,\n          value\n        } = _ref10;\n        return {\n          [unsafeNativize(key).toString()]: unsafeNativize(value)\n        };\n      }));\n\n    case \"struct\":\n      {\n        let coercedResult = result;\n\n        if (coercedResult.reference === undefined) {\n          //we need to do some pointer stuff here, so let's first create our new\n          //object we'll be pointing to\n          let output = Object.assign({}, ...result.value.map(_ref11 => {\n            let {\n              name,\n              value\n            } = _ref11;\n            return {\n              [name]: value //we *don't* nativize yet!\n\n            };\n          })); //now, we can't use a map here, or we'll screw things up!\n          //we want to *mutate* output, not replace it with a new object\n\n          for (let name in output) {\n            output[name] = unsafeNativizeWithTable(output[name], [output, ...seenSoFar]);\n          }\n\n          return output;\n        } else {\n          return seenSoFar[coercedResult.reference - 1];\n        }\n      }\n\n    case \"type\":\n      switch (result.type.type.typeClass) {\n        case \"contract\":\n          return Object.assign({}, ...result.value.map(_ref12 => {\n            let {\n              name,\n              value\n            } = _ref12;\n            return {\n              [name]: unsafeNativize(value)\n            };\n          }));\n\n        case \"enum\":\n          return Object.assign({}, ...result.value.map(enumValue => ({\n            [enumValue.value.name]: unsafeNativize(enumValue)\n          })));\n      }\n\n    case \"tuple\":\n      return result.value.map(_ref13 => {\n        let {\n          value\n        } = _ref13;\n        return unsafeNativize(value);\n      });\n\n    case \"magic\":\n      return Object.assign({}, ...Object.entries(result.value).map(_ref14 => {\n        let [key, value] = _ref14;\n        return {\n          [key]: unsafeNativize(value)\n        };\n      }));\n\n    case \"enum\":\n      return enumFullName(result);\n\n    case \"contract\":\n      return result.value.address;\n    //we no longer include additional info\n\n    case \"function\":\n      switch (result.type.visibility) {\n        case \"external\":\n          {\n            let coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"known\":\n                return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).${coercedResult.value.abi.name}`;\n\n              case \"invalid\":\n                return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).call(${coercedResult.value.selector}...)`;\n\n              case \"unknown\":\n                return `${coercedResult.value.contract.address}.call(${coercedResult.value.selector}...)`;\n            }\n          }\n\n        case \"internal\":\n          {\n            let coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"function\":\n                if (coercedResult.value.definedIn) {\n                  return `${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}`;\n                } else {\n                  return coercedResult.value.name;\n                }\n\n              case \"exception\":\n                return coercedResult.value.deployedProgramCounter === 0 ? `<zero>` : `<uninitialized>`;\n\n              case \"unknown\":\n                return `<decoding not supported>`;\n            }\n          }\n      }\n\n  }\n}","map":{"version":3,"sources":["../../../../lib/format/utils/inspect.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.unsafeNativize = exports.unsafeNativizeVariables = exports.ResultInspector = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:format:utils:inspect\");\nconst util_1 = __importDefault(require(\"util\"));\nconst Format = __importStar(require(\"../common\"));\nconst Exception = __importStar(require(\"./exception\"));\n//HACK -- inspect options are ridiculous, I swear >_>\nfunction cleanStylize(options) {\n    return Object.assign({}, ...Object.entries(options).map(([key, value]) => key === \"stylize\" ? {} : { [key]: value }));\n}\n/**\n * This class is meant to be used with Node's\n * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)\n * function.  Given a [[Format.Values.Result]] `value`, one can use\n * `new ResultInspector(value)` to create a ResultInspector for that value,\n * which can be used with util.inspect() to create a human-readable string\n * representing the value.\n *\n * @example\n * Suppose `value` is a Result.  In Node, the following would print to the\n * console a human-readable representation of `value`, with colors enabled,\n * no maximum depth, and no maximum array length, and lines (usually) no\n * longer than 80 characters:\n * ```javascript\n * console.log(\n *   util.inspect(\n *     new ResultInspector(value),\n *     {\n *       colors: true,\n *       depth: null,\n *       maxArrayLength: null,\n *       breakLength: 80\n *     }\n *   )\n * );\n * ```\n * Of course, there are many other ways to use util.inspect; see Node's\n * documentation, linked above, for more.\n */\nclass ResultInspector {\n    constructor(result) {\n        this.result = result;\n    }\n    [util_1.default.inspect.custom](depth, options) {\n        switch (this.result.kind) {\n            case \"value\":\n                switch (this.result.type.typeClass) {\n                    case \"uint\":\n                    case \"int\":\n                        return options.stylize((this.result).value.asBN.toString(), \"number\");\n                    case \"fixed\":\n                    case \"ufixed\":\n                        //note: because this is just for display, we don't bother adjusting the magic values Big.NE or Big.PE;\n                        //we'll trust those to their defaults\n                        return options.stylize((this.result).value.asBig.toString(), \"number\");\n                    case \"bool\":\n                        return util_1.default.inspect(this.result.value.asBoolean, options);\n                    case \"bytes\":\n                        let hex = this.result.value.asHex;\n                        switch (this.result.type.kind) {\n                            case \"static\":\n                                return options.stylize(hex, \"number\");\n                            case \"dynamic\":\n                                return options.stylize(`hex'${hex.slice(2)}'`, \"string\");\n                        }\n                    case \"address\":\n                        return options.stylize(this.result.value.asAddress, \"number\");\n                    case \"string\": {\n                        let coercedResult = this.result;\n                        switch (coercedResult.value.kind) {\n                            case \"valid\":\n                                return util_1.default.inspect(coercedResult.value.asString, options);\n                            case \"malformed\":\n                                //note: this will turn malformed utf-8 into replacement characters (U+FFFD)\n                                //note we need to cut off the 0x prefix\n                                return util_1.default.inspect(Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString());\n                        }\n                    }\n                    case \"array\": {\n                        let coercedResult = this.result;\n                        if (coercedResult.reference !== undefined) {\n                            return formatCircular(coercedResult.reference, options);\n                        }\n                        return util_1.default.inspect(coercedResult.value.map(element => new ResultInspector(element)), options);\n                    }\n                    case \"mapping\":\n                        return util_1.default.inspect(new Map((this.result).value.map(({ key, value }) => [\n                            new ResultInspector(key),\n                            new ResultInspector(value)\n                        ])), options);\n                    case \"struct\": {\n                        let coercedResult = this.result;\n                        if (coercedResult.reference !== undefined) {\n                            return formatCircular(coercedResult.reference, options);\n                        }\n                        return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(({ name, value }) => ({\n                            [name]: new ResultInspector(value)\n                        }))), options);\n                    }\n                    case \"userDefinedValueType\": {\n                        const typeName = Format.Types.typeStringWithoutLocation(this.result.type);\n                        const coercedResult = this.result;\n                        const inspectOfUnderlying = util_1.default.inspect(new ResultInspector(coercedResult.value), options);\n                        return `${typeName}.wrap(${inspectOfUnderlying})`; //note only the underlying part is stylized\n                    }\n                    case \"tuple\": {\n                        let coercedResult = this.result;\n                        //if everything is named, do same as with struct.\n                        //if not, just do an array.\n                        //(good behavior in the mixed case is hard, unfortunately)\n                        if (coercedResult.value.every(({ name }) => name)) {\n                            return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(({ name, value }) => ({\n                                [name]: new ResultInspector(value)\n                            }))), options);\n                        }\n                        else {\n                            return util_1.default.inspect(coercedResult.value.map(({ value }) => new ResultInspector(value)), options);\n                        }\n                    }\n                    case \"type\": {\n                        switch (this.result.type.type.typeClass) {\n                            case \"contract\":\n                                //same as struct case but w/o circularity check\n                                return util_1.default.inspect(Object.assign({}, ...this.result.value.map(({ name, value }) => ({\n                                    [name]: new ResultInspector(value)\n                                }))), options);\n                            case \"enum\": {\n                                return enumTypeName(this.result.type.type);\n                            }\n                        }\n                    }\n                    case \"magic\":\n                        return util_1.default.inspect(Object.assign({}, ...Object.entries(this.result.value).map(([key, value]) => ({ [key]: new ResultInspector(value) }))), options);\n                    case \"enum\": {\n                        return enumFullName(this.result); //not stylized\n                    }\n                    case \"contract\": {\n                        return util_1.default.inspect(new ContractInfoInspector(this.result.value), options);\n                    }\n                    case \"function\":\n                        switch (this.result.type.visibility) {\n                            case \"external\": {\n                                let coercedResult = (this.result);\n                                let contractString = util_1.default.inspect(new ContractInfoInspector(coercedResult.value.contract), Object.assign(Object.assign({}, cleanStylize(options)), { colors: false }));\n                                let firstLine;\n                                switch (coercedResult.value.kind) {\n                                    case \"known\":\n                                        firstLine = `[Function: ${coercedResult.value.abi.name} of`;\n                                        break;\n                                    case \"invalid\":\n                                    case \"unknown\":\n                                        firstLine = `[Function: Unknown selector ${coercedResult.value.selector} of`;\n                                        break;\n                                }\n                                let secondLine = `${contractString}]`;\n                                let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength\n                                    ? \"\\n\"\n                                    : \" \";\n                                //now, put it together\n                                return options.stylize(firstLine + breakingSpace + secondLine, \"special\");\n                            }\n                            case \"internal\": {\n                                let coercedResult = (this.result);\n                                switch (coercedResult.value.kind) {\n                                    case \"function\":\n                                        if (coercedResult.value.definedIn) {\n                                            return options.stylize(`[Function: ${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}]`, \"special\");\n                                        }\n                                        else {\n                                            return options.stylize(`[Function: ${coercedResult.value.name}]`, \"special\");\n                                        }\n                                    case \"exception\":\n                                        return coercedResult.value.deployedProgramCounter === 0\n                                            ? options.stylize(`[Function: <zero>]`, \"special\")\n                                            : options.stylize(`[Function: <uninitialized>]`, \"special\");\n                                    case \"unknown\":\n                                        let firstLine = `[Function: decoding not supported (raw info:`;\n                                        let secondLine = `deployed PC=${coercedResult.value.deployedProgramCounter}, constructor PC=${coercedResult.value.constructorProgramCounter})]`;\n                                        let breakingSpace = firstLine.length + secondLine.length + 1 >\n                                            options.breakLength\n                                            ? \"\\n\"\n                                            : \" \";\n                                        //now, put it together\n                                        return options.stylize(firstLine + breakingSpace + secondLine, \"special\");\n                                }\n                            }\n                        }\n                }\n            case \"error\": {\n                debug(\"this.result: %O\", this.result);\n                let errorResult = this.result; //the hell?? why couldn't it make this inference??\n                switch (errorResult.error.kind) {\n                    case \"WrappedError\":\n                        return util_1.default.inspect(new ResultInspector(errorResult.error.error), options);\n                    case \"UintPaddingError\":\n                        return `Uint has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n                    case \"IntPaddingError\":\n                        return `Int has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n                    case \"UintPaddingError\":\n                        return `Ufixed has (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n                    case \"FixedPaddingError\":\n                        return `Fixed has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n                    case \"BoolOutOfRangeError\":\n                        return `Invalid boolean (numeric value ${errorResult.error.rawAsBN.toString()})`;\n                    case \"BoolPaddingError\":\n                        return `Boolean has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n                    case \"BytesPaddingError\":\n                        return `Bytestring has extra trailing bytes (padding error) (raw value ${errorResult.error.raw})`;\n                    case \"AddressPaddingError\":\n                        return `Address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n                    case \"EnumOutOfRangeError\":\n                        return `Invalid ${enumTypeName(errorResult.error.type)} (numeric value ${errorResult.error.rawAsBN.toString()})`;\n                    case \"EnumPaddingError\":\n                        return `Enum ${enumTypeName(errorResult.error.type)} has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n                    case \"EnumNotFoundDecodingError\":\n                        return `Unknown enum type ${enumTypeName(errorResult.error.type)} of id ${errorResult.error.type.id} (numeric value ${errorResult.error.rawAsBN.toString()})`;\n                    case \"ContractPaddingError\":\n                        return `Contract address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n                    case \"FunctionExternalNonStackPaddingError\":\n                        return `External function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n                    case \"FunctionExternalStackPaddingError\":\n                        return `External function address or selector has extra leading bytes (padding error) (raw address ${errorResult.error.rawAddress}, raw selector ${errorResult.error.rawSelector})`;\n                    case \"FunctionInternalPaddingError\":\n                        return `Internal function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;\n                    case \"NoSuchInternalFunctionError\":\n                        return `Invalid function (Deployed PC=${errorResult.error.deployedProgramCounter}, constructor PC=${errorResult.error.constructorProgramCounter}) of contract ${errorResult.error.context.typeName}`;\n                    case \"DeployedFunctionInConstructorError\":\n                        return `Deployed-style function (PC=${errorResult.error.deployedProgramCounter}) in constructor`;\n                    case \"MalformedInternalFunctionError\":\n                        return `Malformed internal function w/constructor PC only (value: ${errorResult.error.constructorProgramCounter})`;\n                    case \"IndexedReferenceTypeError\": //for this one we'll bother with some line-wrapping\n                        let firstLine = `Cannot decode indexed parameter of reference type ${errorResult.error.type.typeClass}`;\n                        let secondLine = `(raw value ${errorResult.error.raw})`;\n                        let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength\n                            ? \"\\n\"\n                            : \" \";\n                        return firstLine + breakingSpace + secondLine;\n                    case \"OverlongArraysAndStringsNotImplementedError\":\n                        return `Array or string is too long (length ${errorResult.error.lengthAsBN.toString()}); decoding is not supported`;\n                    case \"OverlargePointersNotImplementedError\":\n                        return `Pointer is too large (value ${errorResult.error.pointerAsBN.toString()}); decoding is not supported`;\n                    case \"UserDefinedTypeNotFoundError\":\n                    case \"UnsupportedConstantError\":\n                    case \"UnusedImmutableError\":\n                    case \"ReadErrorStack\":\n                    case \"ReadErrorStorage\":\n                    case \"ReadErrorBytes\":\n                        return Exception.message(errorResult.error); //yay, these five are already defined!\n                }\n            }\n        }\n    }\n}\nexports.ResultInspector = ResultInspector;\n//these get their own class to deal with a minor complication\nclass ContractInfoInspector {\n    constructor(value) {\n        this.value = value;\n    }\n    [util_1.default.inspect.custom](depth, options) {\n        switch (this.value.kind) {\n            case \"known\":\n                return (options.stylize(this.value.address, \"number\") +\n                    ` (${this.value.class.typeName})`);\n            case \"unknown\":\n                return (options.stylize(this.value.address, \"number\") + \" of unknown class\");\n        }\n    }\n}\nfunction enumTypeName(enumType) {\n    return ((enumType.kind === \"local\" ? enumType.definingContractName + \".\" : \"\") +\n        enumType.typeName);\n}\n//this function will be used in the future for displaying circular\n//structures\nfunction formatCircular(loopLength, options) {\n    return options.stylize(`[Circular (=up ${loopLength})]`, \"special\");\n}\nfunction enumFullName(value) {\n    switch (value.type.kind) {\n        case \"local\":\n            return `${value.type.definingContractName}.${value.type.typeName}.${value.value.name}`;\n        case \"global\":\n            return `${value.type.typeName}.${value.value.name}`;\n    }\n}\n/**\n * WARNING! Do NOT use this function in real code unless you\n * absolutely have to!  Using it in controlled tests is fine,\n * but do NOT use it in real code if you have any better option!\n * See [[unsafeNativize]] for why!\n */\nfunction unsafeNativizeVariables(variables) {\n    return Object.assign({}, ...Object.entries(variables).map(([name, value]) => {\n        try {\n            return { [name]: unsafeNativize(value) };\n        }\n        catch (_) {\n            return undefined; //I guess??\n        }\n    }));\n}\nexports.unsafeNativizeVariables = unsafeNativizeVariables;\n//HACK! Avoid using!\n/**\n * WARNING! Do NOT use this function in real code unless you absolutely have\n * to!  Using it in controlled tests is fine, but do NOT use it in real code if\n * you have any better option!\n *\n * This function is a giant hack.  It will throw exceptions on numbers that\n * don't fit in a Javascript number.  It loses various information.  It was\n * only ever written to support our hacked-together watch expression system,\n * and later repurposed to make testing easier.\n *\n * If you are not doing something as horrible as evaluating user-inputted\n * Javascript expressions meant to operate upon Solidity variables, then you\n * probably have a better option than using this in real code!\n *\n * (For instance, if you just want to nicely print individual values, without\n * attempting to first operate on them via Javascript expressions, we have the\n * [[ResultInspector]] class, which can be used with Node's\n * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)\n * to do exactly that.)\n *\n * Remember, the decoder output format was made to be machine-readable.  It\n * shouldn't be too hard for you to process.  If it comes to it, copy-paste\n * this code and dehackify it for your use case, which hopefully is more\n * manageable than the one that caused us to write this.\n */\nfunction unsafeNativize(result) {\n    return unsafeNativizeWithTable(result, []);\n}\nexports.unsafeNativize = unsafeNativize;\nfunction unsafeNativizeWithTable(result, seenSoFar) {\n    if (result.kind === \"error\") {\n        debug(\"ErrorResult: %O\", result);\n        switch (result.error.kind) {\n            case \"BoolOutOfRangeError\":\n                return true;\n            default:\n                return undefined;\n        }\n    }\n    //NOTE: for simplicity, only arrays & structs will call unsafeNativizeWithTable;\n    //other containers will just call unsafeNativize because they can get away with it\n    //(only things that can *be* circular need unsafeNativizeWithTable, not things that\n    //can merely *contain* circularities)\n    switch (result.type.typeClass) {\n        case \"uint\":\n        case \"int\":\n            return (result).value.asBN.toNumber(); //WARNING\n        case \"bool\":\n            return result.value.asBoolean;\n        case \"bytes\":\n            return result.value.asHex;\n        case \"address\":\n            return result.value.asAddress;\n        case \"string\": {\n            let coercedResult = result;\n            switch (coercedResult.value.kind) {\n                case \"valid\":\n                    return coercedResult.value.asString;\n                case \"malformed\":\n                    // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n                    // note we need to cut off the 0x prefix\n                    return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n            }\n        }\n        case \"fixed\":\n        case \"ufixed\":\n            //HACK: Big doesn't have a toNumber() method, so we convert to string and then parse with Number\n            //NOTE: we don't bother setting the magic variables Big.NE or Big.PE first, as the choice of\n            //notation shouldn't affect the result (can you believe I have to write this? @_@)\n            return Number((result).value.asBig.toString()); //WARNING\n        case \"array\": {\n            let coercedResult = result;\n            if (coercedResult.reference === undefined) {\n                //we need to do some pointer stuff here, so let's first create our new\n                //object we'll be pointing to\n                //[we don't want to alter the original accidentally so let's clone a bit]\n                let output = [...coercedResult.value];\n                //now, we can't use a map here, or we'll screw things up!\n                //we want to *mutate* output, not replace it with a new object\n                for (let index in output) {\n                    output[index] = unsafeNativizeWithTable(output[index], [\n                        output,\n                        ...seenSoFar\n                    ]);\n                }\n                return output;\n            }\n            else {\n                return seenSoFar[coercedResult.reference - 1];\n            }\n        }\n        case \"userDefinedValueType\": {\n            return unsafeNativize(result.value);\n        }\n        case \"mapping\":\n            return Object.assign({}, ...result.value.map(({ key, value }) => ({\n                [unsafeNativize(key).toString()]: unsafeNativize(value)\n            })));\n        case \"struct\": {\n            let coercedResult = result;\n            if (coercedResult.reference === undefined) {\n                //we need to do some pointer stuff here, so let's first create our new\n                //object we'll be pointing to\n                let output = Object.assign({}, ...result.value.map(({ name, value }) => ({\n                    [name]: value //we *don't* nativize yet!\n                })));\n                //now, we can't use a map here, or we'll screw things up!\n                //we want to *mutate* output, not replace it with a new object\n                for (let name in output) {\n                    output[name] = unsafeNativizeWithTable(output[name], [\n                        output,\n                        ...seenSoFar\n                    ]);\n                }\n                return output;\n            }\n            else {\n                return seenSoFar[coercedResult.reference - 1];\n            }\n        }\n        case \"type\":\n            switch (result.type.type.typeClass) {\n                case \"contract\":\n                    return Object.assign({}, ...result.value.map(({ name, value }) => ({\n                        [name]: unsafeNativize(value)\n                    })));\n                case \"enum\":\n                    return Object.assign({}, ...result.value.map(enumValue => ({\n                        [enumValue.value.name]: unsafeNativize(enumValue)\n                    })));\n            }\n        case \"tuple\":\n            return result.value.map(({ value }) => unsafeNativize(value));\n        case \"magic\":\n            return Object.assign({}, ...Object.entries(result.value).map(([key, value]) => ({ [key]: unsafeNativize(value) })));\n        case \"enum\":\n            return enumFullName(result);\n        case \"contract\":\n            return result.value.address; //we no longer include additional info\n        case \"function\":\n            switch (result.type.visibility) {\n                case \"external\": {\n                    let coercedResult = result;\n                    switch (coercedResult.value.kind) {\n                        case \"known\":\n                            return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).${coercedResult.value.abi.name}`;\n                        case \"invalid\":\n                            return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).call(${coercedResult.value.selector}...)`;\n                        case \"unknown\":\n                            return `${coercedResult.value.contract.address}.call(${coercedResult.value.selector}...)`;\n                    }\n                }\n                case \"internal\": {\n                    let coercedResult = result;\n                    switch (coercedResult.value.kind) {\n                        case \"function\":\n                            if (coercedResult.value.definedIn) {\n                                return `${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}`;\n                            }\n                            else {\n                                return coercedResult.value.name;\n                            }\n                        case \"exception\":\n                            return coercedResult.value.deployedProgramCounter === 0\n                                ? `<zero>`\n                                : `<uninitialized>`;\n                        case \"unknown\":\n                            return `<decoding not supported>`;\n                    }\n                }\n            }\n    }\n}\n//# sourceMappingURL=inspect.js.map"]},"metadata":{},"sourceType":"script"}