{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readBytes = exports.readCode = void 0;\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* readCode(pointer, state) {\n  let code = state.code;\n\n  if (!code) {\n    code = yield {\n      type: \"code\",\n      address: Evm.Utils.toAddress(state.specials.this)\n    };\n  }\n\n  return readBytes(pointer, Object.assign(Object.assign({}, state), {\n    code\n  }));\n}\n\nexports.readCode = readCode;\n\nfunction readBytes(pointer, state) {\n  let sourceBytes = state[pointer.location];\n  const {\n    start: offset,\n    length\n  } = pointer;\n\n  if (!Number.isSafeInteger(offset + length)) {\n    throw new errors_1.DecodingError({\n      kind: \"ReadErrorBytes\",\n      location: pointer.location,\n      start: offset,\n      length\n    });\n  } // grab `length` bytes no matter what, here fill this array\n\n\n  var bytes = new Uint8Array(length);\n  bytes.fill(0); //fill it wil zeroes to start\n  //if the start is beyond the end of the source, just return those 0s\n\n  if (offset >= sourceBytes.length) {\n    return bytes;\n  } // if we're reading past the end of the source, truncate the length to read\n\n\n  let excess = offset + length - sourceBytes.length;\n  let readLength;\n\n  if (excess > 0) {\n    readLength = sourceBytes.length - offset;\n  } else {\n    readLength = length;\n  } //get the (truncated) bytes\n\n\n  let existing = new Uint8Array(sourceBytes.buffer, offset, readLength); //copy it into our buffer\n\n  bytes.set(existing);\n  return bytes;\n}\n\nexports.readBytes = readBytes;","map":{"version":3,"sources":["../../../../lib/bytes/read/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,GAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAEA,MAAA,QAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAGA,UAAiB,QAAjB,CACE,OADF,EAEE,KAFF,EAEqB;AAEnB,MAAI,IAAI,GAAG,KAAK,CAAC,IAAjB;;AACA,MAAI,CAAC,IAAL,EAAW;AACT,IAAA,IAAI,GAAG,MAAM;AACX,MAAA,IAAI,EAAE,MADK;AAEX,MAAA,OAAO,EAAE,GAAG,CAAC,KAAJ,CAAU,SAAV,CAAoB,KAAK,CAAC,QAAN,CAAe,IAAnC;AAFE,KAAb;AAID;;AACD,SAAO,SAAS,CAAC,OAAD,EAAQ,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,KAAP,CAAA,EAAY;AAAE,IAAA;AAAF,GAAZ,CAAR,CAAhB;AACD;;AAZD,OAAA,CAAA,QAAA,GAAA,QAAA;;AAcA,SAAgB,SAAhB,CACE,OADF,EAEE,KAFF,EAEqB;AAEnB,MAAI,WAAW,GAAG,KAAK,CAAC,OAAO,CAAC,QAAT,CAAvB;AAEA,QAAM;AAAE,IAAA,KAAK,EAAE,MAAT;AAAiB,IAAA;AAAjB,MAA4B,OAAlC;;AACA,MAAI,CAAC,MAAM,CAAC,aAAP,CAAqB,MAAM,GAAG,MAA9B,CAAL,EAA4C;AAC1C,UAAM,IAAI,QAAA,CAAA,aAAJ,CAAkB;AACtB,MAAA,IAAI,EAAE,gBADgB;AAEtB,MAAA,QAAQ,EAAE,OAAO,CAAC,QAFI;AAGtB,MAAA,KAAK,EAAE,MAHe;AAItB,MAAA;AAJsB,KAAlB,CAAN;AAMD,GAZkB,CAcnB;;;AACA,MAAI,KAAK,GAAG,IAAI,UAAJ,CAAe,MAAf,CAAZ;AACA,EAAA,KAAK,CAAC,IAAN,CAAW,CAAX,EAhBmB,CAgBJ;AAEf;;AACA,MAAI,MAAM,IAAI,WAAW,CAAC,MAA1B,EAAkC;AAChC,WAAO,KAAP;AACD,GArBkB,CAuBnB;;;AACA,MAAI,MAAM,GAAG,MAAM,GAAG,MAAT,GAAkB,WAAW,CAAC,MAA3C;AACA,MAAI,UAAJ;;AACA,MAAI,MAAM,GAAG,CAAb,EAAgB;AACd,IAAA,UAAU,GAAG,WAAW,CAAC,MAAZ,GAAqB,MAAlC;AACD,GAFD,MAEO;AACL,IAAA,UAAU,GAAG,MAAb;AACD,GA9BkB,CAgCnB;;;AACA,MAAI,QAAQ,GAAG,IAAI,UAAJ,CAAe,WAAW,CAAC,MAA3B,EAAmC,MAAnC,EAA2C,UAA3C,CAAf,CAjCmB,CAmCnB;;AACA,EAAA,KAAK,CAAC,GAAN,CAAU,QAAV;AAEA,SAAO,KAAP;AACD;;AAzCD,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readBytes = exports.readCode = void 0;\nconst Evm = __importStar(require(\"../../evm\"));\nconst errors_1 = require(\"../../errors\");\nfunction* readCode(pointer, state) {\n    let code = state.code;\n    if (!code) {\n        code = yield {\n            type: \"code\",\n            address: Evm.Utils.toAddress(state.specials.this)\n        };\n    }\n    return readBytes(pointer, Object.assign(Object.assign({}, state), { code }));\n}\nexports.readCode = readCode;\nfunction readBytes(pointer, state) {\n    let sourceBytes = state[pointer.location];\n    const { start: offset, length } = pointer;\n    if (!Number.isSafeInteger(offset + length)) {\n        throw new errors_1.DecodingError({\n            kind: \"ReadErrorBytes\",\n            location: pointer.location,\n            start: offset,\n            length\n        });\n    }\n    // grab `length` bytes no matter what, here fill this array\n    var bytes = new Uint8Array(length);\n    bytes.fill(0); //fill it wil zeroes to start\n    //if the start is beyond the end of the source, just return those 0s\n    if (offset >= sourceBytes.length) {\n        return bytes;\n    }\n    // if we're reading past the end of the source, truncate the length to read\n    let excess = offset + length - sourceBytes.length;\n    let readLength;\n    if (excess > 0) {\n        readLength = sourceBytes.length - offset;\n    }\n    else {\n        readLength = length;\n    }\n    //get the (truncated) bytes\n    let existing = new Uint8Array(sourceBytes.buffer, offset, readLength);\n    //copy it into our buffer\n    bytes.set(existing);\n    return bytes;\n}\nexports.readBytes = readBytes;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}