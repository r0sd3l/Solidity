{"ast":null,"code":"export const MIN_VALUE_32 = 2 ** -126 * 2 ** -23;\nexport const MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);\nexport const EPSILON_32 = 2 ** -23;\nconst INDEX_POSITIVE_INFINITY = 2139095040;\nconst INDEX_NEGATIVE_INFINITY = -2139095041;\nexport function decomposeFloat(f) {\n  const maxSignificand = 1 + (2 ** 23 - 1) / 2 ** 23;\n\n  for (let exponent = -126; exponent !== 128; ++exponent) {\n    const powExponent = 2 ** exponent;\n    const maxForExponent = maxSignificand * powExponent;\n\n    if (Math.abs(f) <= maxForExponent) {\n      return {\n        exponent,\n        significand: f / powExponent\n      };\n    }\n  }\n\n  return {\n    exponent: Number.NaN,\n    significand: Number.NaN\n  };\n}\n\nfunction indexInFloatFromDecomp(exponent, significand) {\n  if (exponent === -126) {\n    return significand * 0x800000;\n  }\n\n  return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;\n}\n\nexport function floatToIndex(f) {\n  if (f === Number.POSITIVE_INFINITY) {\n    return INDEX_POSITIVE_INFINITY;\n  }\n\n  if (f === Number.NEGATIVE_INFINITY) {\n    return INDEX_NEGATIVE_INFINITY;\n  }\n\n  const decomp = decomposeFloat(f);\n  const exponent = decomp.exponent;\n  const significand = decomp.significand;\n\n  if (Number.isNaN(exponent) || Number.isNaN(significand) || !Number.isInteger(significand * 0x800000)) {\n    return Number.NaN;\n  }\n\n  if (f > 0 || f === 0 && 1 / f === Number.POSITIVE_INFINITY) {\n    return indexInFloatFromDecomp(exponent, significand);\n  } else {\n    return -indexInFloatFromDecomp(exponent, -significand) - 1;\n  }\n}\nexport function indexToFloat(index) {\n  if (index < 0) {\n    return -indexToFloat(-index - 1);\n  }\n\n  if (index === INDEX_POSITIVE_INFINITY) {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  if (index < 0x1000000) {\n    return index * 2 ** -149;\n  }\n\n  const postIndex = index - 0x1000000;\n  const exponent = -125 + (postIndex >> 23);\n  const significand = 1 + (postIndex & 0x7fffff) / 0x800000;\n  return significand * 2 ** exponent;\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js"],"names":["MIN_VALUE_32","MAX_VALUE_32","EPSILON_32","INDEX_POSITIVE_INFINITY","INDEX_NEGATIVE_INFINITY","decomposeFloat","f","maxSignificand","exponent","powExponent","maxForExponent","Math","abs","significand","Number","NaN","indexInFloatFromDecomp","floatToIndex","POSITIVE_INFINITY","NEGATIVE_INFINITY","decomp","isNaN","isInteger","indexToFloat","index","postIndex"],"mappings":"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","sourcesContent":["export const MIN_VALUE_32 = 2 ** -126 * 2 ** -23;\nexport const MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);\nexport const EPSILON_32 = 2 ** -23;\nconst INDEX_POSITIVE_INFINITY = 2139095040;\nconst INDEX_NEGATIVE_INFINITY = -2139095041;\nexport function decomposeFloat(f) {\n    const maxSignificand = 1 + (2 ** 23 - 1) / 2 ** 23;\n    for (let exponent = -126; exponent !== 128; ++exponent) {\n        const powExponent = 2 ** exponent;\n        const maxForExponent = maxSignificand * powExponent;\n        if (Math.abs(f) <= maxForExponent) {\n            return { exponent, significand: f / powExponent };\n        }\n    }\n    return { exponent: Number.NaN, significand: Number.NaN };\n}\nfunction indexInFloatFromDecomp(exponent, significand) {\n    if (exponent === -126) {\n        return significand * 0x800000;\n    }\n    return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;\n}\nexport function floatToIndex(f) {\n    if (f === Number.POSITIVE_INFINITY) {\n        return INDEX_POSITIVE_INFINITY;\n    }\n    if (f === Number.NEGATIVE_INFINITY) {\n        return INDEX_NEGATIVE_INFINITY;\n    }\n    const decomp = decomposeFloat(f);\n    const exponent = decomp.exponent;\n    const significand = decomp.significand;\n    if (Number.isNaN(exponent) || Number.isNaN(significand) || !Number.isInteger(significand * 0x800000)) {\n        return Number.NaN;\n    }\n    if (f > 0 || (f === 0 && 1 / f === Number.POSITIVE_INFINITY)) {\n        return indexInFloatFromDecomp(exponent, significand);\n    }\n    else {\n        return -indexInFloatFromDecomp(exponent, -significand) - 1;\n    }\n}\nexport function indexToFloat(index) {\n    if (index < 0) {\n        return -indexToFloat(-index - 1);\n    }\n    if (index === INDEX_POSITIVE_INFINITY) {\n        return Number.POSITIVE_INFINITY;\n    }\n    if (index < 0x1000000) {\n        return index * 2 ** -149;\n    }\n    const postIndex = index - 0x1000000;\n    const exponent = -125 + (postIndex >> 23);\n    const significand = 1 + (postIndex & 0x7fffff) / 0x800000;\n    return significand * 2 ** exponent;\n}\n"]},"metadata":{},"sourceType":"module"}