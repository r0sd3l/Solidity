{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.message = void 0;\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:format:utils:exception\");\n\nconst Format = __importStar(require(\"../common\"));\n\nconst AstUtils = __importStar(require(\"../../ast/utils\")); //this function gives an error message\n//for those errors that are meant to possibly\n//be wrapped in a DecodingError and thrown\n\n\nfunction message(error) {\n  switch (error.kind) {\n    case \"UserDefinedTypeNotFoundError\":\n      let typeName = Format.Types.isContractDefinedType(error.type) ? error.type.definingContractName + \".\" + error.type.typeName : error.type.typeName;\n      return `Unknown ${error.type.typeClass} type ${typeName} of id ${error.type.id}`;\n\n    case \"UnsupportedConstantError\":\n      return `Unsupported constant type ${AstUtils.typeClass(error.definition)}`;\n\n    case \"UnusedImmutableError\":\n      return \"Cannot read unused immutable\";\n\n    case \"ReadErrorStack\":\n      return `Can't read stack from position ${error.from} to ${error.to}`;\n\n    case \"ReadErrorBytes\":\n      return `Can't read ${error.length} bytes from ${error.location} starting at ${error.start}`;\n\n    case \"ReadErrorStorage\":\n      if (error.range.length) {\n        return `Can't read ${error.range.length} bytes from storage starting at index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)}`;\n      } else {\n        return `Can't read storage from index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)} to index ${error.range.to.index} in ${slotAddressPrintout(error.range.to.slot)}`;\n      }\n\n  }\n}\n\nexports.message = message;\n\nfunction slotAddressPrintout(slot) {\n  if (slot.key !== undefined && slot.path !== undefined) {\n    // mapping reference\n    let {\n      type: keyEncoding,\n      value: keyValue\n    } = keyInfoForPrinting(slot.key);\n    return \"keccak(\" + keyValue + \" as \" + keyEncoding + \", \" + slotAddressPrintout(slot.path) + \") + \" + slot.offset.toString();\n  } else if (slot.path !== undefined) {\n    const pathAddressPrintout = slotAddressPrintout(slot.path);\n    return slot.hashPath ? \"keccak(\" + pathAddressPrintout + \")\" + slot.offset.toString() : pathAddressPrintout + slot.offset.toString();\n  } else {\n    return slot.offset.toString();\n  }\n} //this is like the old toSoliditySha3Input, but for debugging purposes ONLY\n//it will NOT produce correct input to soliditySha3\n//please use mappingKeyAsHex instead if you wish to encode a mapping key.\n\n\nfunction keyInfoForPrinting(input) {\n  switch (input.type.typeClass) {\n    case \"uint\":\n      return {\n        type: \"uint\",\n        value: input.value.asBN.toString()\n      };\n\n    case \"int\":\n      return {\n        type: \"int\",\n        value: input.value.asBN.toString()\n      };\n\n    case \"fixed\":\n      return {\n        type: `fixed256x${input.type.places}`,\n        value: input.value.asBig.toString()\n      };\n\n    case \"ufixed\":\n      return {\n        type: `ufixed256x${input.type.places}`,\n        value: input.value.asBig.toString()\n      };\n\n    case \"bool\":\n      //this is the case that won't work as valid input to soliditySha3 :)\n      return {\n        type: \"uint\",\n        value: input.value.asBoolean.toString()\n      };\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return {\n            type: \"bytes32\",\n            value: input.value.asHex\n          };\n\n        case \"dynamic\":\n          return {\n            type: \"bytes\",\n            value: input.value.asHex\n          };\n      }\n\n    case \"address\":\n      return {\n        type: \"address\",\n        value: input.value.asAddress\n      };\n\n    case \"string\":\n      let coercedInput = input;\n\n      switch (coercedInput.value.kind) {\n        case \"valid\":\n          return {\n            type: \"string\",\n            value: coercedInput.value.asString\n          };\n\n        case \"malformed\":\n          return {\n            type: \"bytes\",\n            value: coercedInput.value.asHex\n          };\n      }\n\n    //fixed and ufixed are skipped for now\n  }\n}","map":{"version":3,"sources":["../../../../lib/format/utils/exception.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAIG;;AACH,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,8BAAZ,CAAd;;AAEA,MAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,YAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA,C,CAGA;AACA;AACA;;;AACA,SAAgB,OAAhB,CAAwB,KAAxB,EAA6D;AAC3D,UAAQ,KAAK,CAAC,IAAd;AACE,SAAK,8BAAL;AACE,UAAI,QAAQ,GAAG,MAAM,CAAC,KAAP,CAAa,qBAAb,CAAmC,KAAK,CAAC,IAAzC,IACX,KAAK,CAAC,IAAN,CAAW,oBAAX,GAAkC,GAAlC,GAAwC,KAAK,CAAC,IAAN,CAAW,QADxC,GAEX,KAAK,CAAC,IAAN,CAAW,QAFf;AAGA,aAAO,WAAW,KAAK,CAAC,IAAN,CAAW,SAAS,SAAS,QAAQ,UACrD,KAAK,CAAC,IAAN,CAAW,EACb,EAFA;;AAGF,SAAK,0BAAL;AACE,aAAO,6BAA6B,QAAQ,CAAC,SAAT,CAClC,KAAK,CAAC,UAD4B,CAEnC,EAFD;;AAGF,SAAK,sBAAL;AACE,aAAO,8BAAP;;AACF,SAAK,gBAAL;AACE,aAAO,kCAAkC,KAAK,CAAC,IAAI,OAAO,KAAK,CAAC,EAAE,EAAlE;;AACF,SAAK,gBAAL;AACE,aAAO,cAAc,KAAK,CAAC,MAAM,eAC/B,KAAK,CAAC,QACR,gBAAgB,KAAK,CAAC,KAAK,EAF3B;;AAGF,SAAK,kBAAL;AACE,UAAI,KAAK,CAAC,KAAN,CAAY,MAAhB,EAAwB;AACtB,eAAO,cACL,KAAK,CAAC,KAAN,CAAY,MACd,yCACE,KAAK,CAAC,KAAN,CAAY,IAAZ,CAAiB,KACnB,OAAO,mBAAmB,CAAC,KAAK,CAAC,KAAN,CAAY,IAAZ,CAAiB,IAAlB,CAAuB,EAJjD;AAKD,OAND,MAMO;AACL,eAAO,iCACL,KAAK,CAAC,KAAN,CAAY,IAAZ,CAAiB,KACnB,OAAO,mBAAmB,CAAC,KAAK,CAAC,KAAN,CAAY,IAAZ,CAAiB,IAAlB,CAAuB,aAC/C,KAAK,CAAC,KAAN,CAAY,EAAZ,CAAe,KACjB,OAAO,mBAAmB,CAAC,KAAK,CAAC,KAAN,CAAY,EAAZ,CAAe,IAAhB,CAAqB,EAJ/C;AAKD;;AAjCL;AAmCD;;AApCD,OAAA,CAAA,OAAA,GAAA,OAAA;;AAsCA,SAAS,mBAAT,CAA6B,IAA7B,EAA+C;AAC7C,MAAI,IAAI,CAAC,GAAL,KAAa,SAAb,IAA0B,IAAI,CAAC,IAAL,KAAc,SAA5C,EAAuD;AACrD;AACA,QAAI;AAAE,MAAA,IAAI,EAAE,WAAR;AAAqB,MAAA,KAAK,EAAE;AAA5B,QAAyC,kBAAkB,CAAC,IAAI,CAAC,GAAN,CAA/D;AACA,WACE,YACA,QADA,GAEA,MAFA,GAGA,WAHA,GAIA,IAJA,GAKA,mBAAmB,CAAC,IAAI,CAAC,IAAN,CALnB,GAMA,MANA,GAOA,IAAI,CAAC,MAAL,CAAY,QAAZ,EARF;AAUD,GAbD,MAaO,IAAI,IAAI,CAAC,IAAL,KAAc,SAAlB,EAA6B;AAClC,UAAM,mBAAmB,GAAG,mBAAmB,CAAC,IAAI,CAAC,IAAN,CAA/C;AACA,WAAO,IAAI,CAAC,QAAL,GACH,YAAY,mBAAZ,GAAkC,GAAlC,GAAwC,IAAI,CAAC,MAAL,CAAY,QAAZ,EADrC,GAEH,mBAAmB,GAAG,IAAI,CAAC,MAAL,CAAY,QAAZ,EAF1B;AAGD,GALM,MAKA;AACL,WAAO,IAAI,CAAC,MAAL,CAAY,QAAZ,EAAP;AACD;AACF,C,CAED;AACA;AACA;;;AACA,SAAS,kBAAT,CACE,KADF,EACsC;AAEpC,UAAQ,KAAK,CAAC,IAAN,CAAW,SAAnB;AACE,SAAK,MAAL;AACE,aAAO;AACL,QAAA,IAAI,EAAE,MADD;AAEL,QAAA,KAAK,EAA4B,KAAM,CAAC,KAAP,CAAa,IAAb,CAAkB,QAAlB;AAF5B,OAAP;;AAIF,SAAK,KAAL;AACE,aAAO;AACL,QAAA,IAAI,EAAE,KADD;AAEL,QAAA,KAAK,EAA2B,KAAM,CAAC,KAAP,CAAa,IAAb,CAAkB,QAAlB;AAF3B,OAAP;;AAIF,SAAK,OAAL;AACE,aAAO;AACL,QAAA,IAAI,EAAE,YAAY,KAAK,CAAC,IAAN,CAAW,MAAM,EAD9B;AAEL,QAAA,KAAK,EAA6B,KAAM,CAAC,KAAP,CAAa,KAAb,CAAmB,QAAnB;AAF7B,OAAP;;AAIF,SAAK,QAAL;AACE,aAAO;AACL,QAAA,IAAI,EAAE,aAAa,KAAK,CAAC,IAAN,CAAW,MAAM,EAD/B;AAEL,QAAA,KAAK,EAA8B,KAAM,CAAC,KAAP,CAAa,KAAb,CAAmB,QAAnB;AAF9B,OAAP;;AAIF,SAAK,MAAL;AACE;AACA,aAAO;AACL,QAAA,IAAI,EAAE,MADD;AAEL,QAAA,KAAK,EAA4B,KAAM,CAAC,KAAP,CAAa,SAAb,CAAuB,QAAvB;AAF5B,OAAP;;AAIF,SAAK,OAAL;AACE,cAAQ,KAAK,CAAC,IAAN,CAAW,IAAnB;AACE,aAAK,QAAL;AACE,iBAAO;AACL,YAAA,IAAI,EAAE,SADD;AAEL,YAAA,KAAK,EAA6B,KAAM,CAAC,KAAP,CAAa;AAF1C,WAAP;;AAIF,aAAK,SAAL;AACE,iBAAO;AACL,YAAA,IAAI,EAAE,OADD;AAEL,YAAA,KAAK,EAA6B,KAAM,CAAC,KAAP,CAAa;AAF1C,WAAP;AAPJ;;AAYF,SAAK,SAAL;AACE,aAAO;AACL,QAAA,IAAI,EAAE,SADD;AAEL,QAAA,KAAK,EAA+B,KAAM,CAAC,KAAP,CAAa;AAF5C,OAAP;;AAIF,SAAK,QAAL;AACE,UAAI,YAAY,GACd,KADF;;AAGA,cAAQ,YAAY,CAAC,KAAb,CAAmB,IAA3B;AACE,aAAK,OAAL;AACE,iBAAO;AACL,YAAA,IAAI,EAAE,QADD;AAEL,YAAA,KAAK,EAAE,YAAY,CAAC,KAAb,CAAmB;AAFrB,WAAP;;AAIF,aAAK,WAAL;AACE,iBAAO;AACL,YAAA,IAAI,EAAE,OADD;AAEL,YAAA,KAAK,EAAE,YAAY,CAAC,KAAb,CAAmB;AAFrB,WAAP;AAPJ;;AAYF;AA7DF;AA+DD","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.message = void 0;\n/**\n * @protected\n *\n * @packageDocumentation\n */\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:format:utils:exception\");\nconst Format = __importStar(require(\"../common\"));\nconst AstUtils = __importStar(require(\"../../ast/utils\"));\n//this function gives an error message\n//for those errors that are meant to possibly\n//be wrapped in a DecodingError and thrown\nfunction message(error) {\n    switch (error.kind) {\n        case \"UserDefinedTypeNotFoundError\":\n            let typeName = Format.Types.isContractDefinedType(error.type)\n                ? error.type.definingContractName + \".\" + error.type.typeName\n                : error.type.typeName;\n            return `Unknown ${error.type.typeClass} type ${typeName} of id ${error.type.id}`;\n        case \"UnsupportedConstantError\":\n            return `Unsupported constant type ${AstUtils.typeClass(error.definition)}`;\n        case \"UnusedImmutableError\":\n            return \"Cannot read unused immutable\";\n        case \"ReadErrorStack\":\n            return `Can't read stack from position ${error.from} to ${error.to}`;\n        case \"ReadErrorBytes\":\n            return `Can't read ${error.length} bytes from ${error.location} starting at ${error.start}`;\n        case \"ReadErrorStorage\":\n            if (error.range.length) {\n                return `Can't read ${error.range.length} bytes from storage starting at index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)}`;\n            }\n            else {\n                return `Can't read storage from index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)} to index ${error.range.to.index} in ${slotAddressPrintout(error.range.to.slot)}`;\n            }\n    }\n}\nexports.message = message;\nfunction slotAddressPrintout(slot) {\n    if (slot.key !== undefined && slot.path !== undefined) {\n        // mapping reference\n        let { type: keyEncoding, value: keyValue } = keyInfoForPrinting(slot.key);\n        return (\"keccak(\" +\n            keyValue +\n            \" as \" +\n            keyEncoding +\n            \", \" +\n            slotAddressPrintout(slot.path) +\n            \") + \" +\n            slot.offset.toString());\n    }\n    else if (slot.path !== undefined) {\n        const pathAddressPrintout = slotAddressPrintout(slot.path);\n        return slot.hashPath\n            ? \"keccak(\" + pathAddressPrintout + \")\" + slot.offset.toString()\n            : pathAddressPrintout + slot.offset.toString();\n    }\n    else {\n        return slot.offset.toString();\n    }\n}\n//this is like the old toSoliditySha3Input, but for debugging purposes ONLY\n//it will NOT produce correct input to soliditySha3\n//please use mappingKeyAsHex instead if you wish to encode a mapping key.\nfunction keyInfoForPrinting(input) {\n    switch (input.type.typeClass) {\n        case \"uint\":\n            return {\n                type: \"uint\",\n                value: input.value.asBN.toString()\n            };\n        case \"int\":\n            return {\n                type: \"int\",\n                value: input.value.asBN.toString()\n            };\n        case \"fixed\":\n            return {\n                type: `fixed256x${input.type.places}`,\n                value: input.value.asBig.toString()\n            };\n        case \"ufixed\":\n            return {\n                type: `ufixed256x${input.type.places}`,\n                value: input.value.asBig.toString()\n            };\n        case \"bool\":\n            //this is the case that won't work as valid input to soliditySha3 :)\n            return {\n                type: \"uint\",\n                value: input.value.asBoolean.toString()\n            };\n        case \"bytes\":\n            switch (input.type.kind) {\n                case \"static\":\n                    return {\n                        type: \"bytes32\",\n                        value: input.value.asHex\n                    };\n                case \"dynamic\":\n                    return {\n                        type: \"bytes\",\n                        value: input.value.asHex\n                    };\n            }\n        case \"address\":\n            return {\n                type: \"address\",\n                value: input.value.asAddress\n            };\n        case \"string\":\n            let coercedInput = (input);\n            switch (coercedInput.value.kind) {\n                case \"valid\":\n                    return {\n                        type: \"string\",\n                        value: coercedInput.value.asString\n                    };\n                case \"malformed\":\n                    return {\n                        type: \"bytes\",\n                        value: coercedInput.value.asHex\n                    };\n            }\n        //fixed and ufixed are skipped for now\n    }\n}\n//# sourceMappingURL=exception.js.map"]},"metadata":{},"sourceType":"script"}