{"ast":null,"code":"import { clone64, isEqual64 } from './ArrayInt64.js';\nconst INDEX_POSITIVE_INFINITY = {\n  sign: 1,\n  data: [2146435072, 0]\n};\nconst INDEX_NEGATIVE_INFINITY = {\n  sign: -1,\n  data: [2146435072, 1]\n};\nexport function decomposeDouble(d) {\n  const maxSignificand = 2 - Number.EPSILON;\n\n  for (let exponent = -1022; exponent !== 1024; ++exponent) {\n    const powExponent = 2 ** exponent;\n    const maxForExponent = maxSignificand * powExponent;\n\n    if (Math.abs(d) <= maxForExponent) {\n      return {\n        exponent,\n        significand: d / powExponent\n      };\n    }\n  }\n\n  return {\n    exponent: Number.NaN,\n    significand: Number.NaN\n  };\n}\n\nfunction positiveNumberToInt64(n) {\n  return [~~(n / 0x100000000), n >>> 0];\n}\n\nfunction indexInDoubleFromDecomp(exponent, significand) {\n  if (exponent === -1022) {\n    const rescaledSignificand = significand * 2 ** 52;\n    return positiveNumberToInt64(rescaledSignificand);\n  }\n\n  const rescaledSignificand = (significand - 1) * 2 ** 52;\n  const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;\n  const index = positiveNumberToInt64(rescaledSignificand);\n  index[0] += exponentOnlyHigh;\n  return index;\n}\n\nexport function doubleToIndex(d) {\n  if (d === Number.POSITIVE_INFINITY) {\n    return clone64(INDEX_POSITIVE_INFINITY);\n  }\n\n  if (d === Number.NEGATIVE_INFINITY) {\n    return clone64(INDEX_NEGATIVE_INFINITY);\n  }\n\n  const decomp = decomposeDouble(d);\n  const exponent = decomp.exponent;\n  const significand = decomp.significand;\n\n  if (d > 0 || d === 0 && 1 / d === Number.POSITIVE_INFINITY) {\n    return {\n      sign: 1,\n      data: indexInDoubleFromDecomp(exponent, significand)\n    };\n  } else {\n    const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);\n\n    if (indexOpposite[1] === 0xffffffff) {\n      indexOpposite[0] += 1;\n      indexOpposite[1] = 0;\n    } else {\n      indexOpposite[1] += 1;\n    }\n\n    return {\n      sign: -1,\n      data: indexOpposite\n    };\n  }\n}\nexport function indexToDouble(index) {\n  if (index.sign === -1) {\n    const indexOpposite = {\n      sign: 1,\n      data: [index.data[0], index.data[1]]\n    };\n\n    if (indexOpposite.data[1] === 0) {\n      indexOpposite.data[0] -= 1;\n      indexOpposite.data[1] = 0xffffffff;\n    } else {\n      indexOpposite.data[1] -= 1;\n    }\n\n    return -indexToDouble(indexOpposite);\n  }\n\n  if (isEqual64(index, INDEX_POSITIVE_INFINITY)) {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  if (index.data[0] < 0x200000) {\n    return (index.data[0] * 0x100000000 + index.data[1]) * 2 ** -1074;\n  }\n\n  const postIndexHigh = index.data[0] - 0x200000;\n  const exponent = -1021 + (postIndexHigh >> 20);\n  const significand = 1 + ((postIndexHigh & 0xfffff) * 2 ** 32 + index.data[1]) * Number.EPSILON;\n  return significand * 2 ** exponent;\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js"],"names":["clone64","isEqual64","INDEX_POSITIVE_INFINITY","sign","data","INDEX_NEGATIVE_INFINITY","decomposeDouble","d","maxSignificand","Number","EPSILON","exponent","powExponent","maxForExponent","Math","abs","significand","NaN","positiveNumberToInt64","n","indexInDoubleFromDecomp","rescaledSignificand","exponentOnlyHigh","index","doubleToIndex","POSITIVE_INFINITY","NEGATIVE_INFINITY","decomp","indexOpposite","indexToDouble","postIndexHigh"],"mappings":"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","sourcesContent":["import { clone64, isEqual64 } from './ArrayInt64.js';\nconst INDEX_POSITIVE_INFINITY = { sign: 1, data: [2146435072, 0] };\nconst INDEX_NEGATIVE_INFINITY = { sign: -1, data: [2146435072, 1] };\nexport function decomposeDouble(d) {\n    const maxSignificand = 2 - Number.EPSILON;\n    for (let exponent = -1022; exponent !== 1024; ++exponent) {\n        const powExponent = 2 ** exponent;\n        const maxForExponent = maxSignificand * powExponent;\n        if (Math.abs(d) <= maxForExponent) {\n            return { exponent, significand: d / powExponent };\n        }\n    }\n    return { exponent: Number.NaN, significand: Number.NaN };\n}\nfunction positiveNumberToInt64(n) {\n    return [~~(n / 0x100000000), n >>> 0];\n}\nfunction indexInDoubleFromDecomp(exponent, significand) {\n    if (exponent === -1022) {\n        const rescaledSignificand = significand * 2 ** 52;\n        return positiveNumberToInt64(rescaledSignificand);\n    }\n    const rescaledSignificand = (significand - 1) * 2 ** 52;\n    const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;\n    const index = positiveNumberToInt64(rescaledSignificand);\n    index[0] += exponentOnlyHigh;\n    return index;\n}\nexport function doubleToIndex(d) {\n    if (d === Number.POSITIVE_INFINITY) {\n        return clone64(INDEX_POSITIVE_INFINITY);\n    }\n    if (d === Number.NEGATIVE_INFINITY) {\n        return clone64(INDEX_NEGATIVE_INFINITY);\n    }\n    const decomp = decomposeDouble(d);\n    const exponent = decomp.exponent;\n    const significand = decomp.significand;\n    if (d > 0 || (d === 0 && 1 / d === Number.POSITIVE_INFINITY)) {\n        return { sign: 1, data: indexInDoubleFromDecomp(exponent, significand) };\n    }\n    else {\n        const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);\n        if (indexOpposite[1] === 0xffffffff) {\n            indexOpposite[0] += 1;\n            indexOpposite[1] = 0;\n        }\n        else {\n            indexOpposite[1] += 1;\n        }\n        return { sign: -1, data: indexOpposite };\n    }\n}\nexport function indexToDouble(index) {\n    if (index.sign === -1) {\n        const indexOpposite = { sign: 1, data: [index.data[0], index.data[1]] };\n        if (indexOpposite.data[1] === 0) {\n            indexOpposite.data[0] -= 1;\n            indexOpposite.data[1] = 0xffffffff;\n        }\n        else {\n            indexOpposite.data[1] -= 1;\n        }\n        return -indexToDouble(indexOpposite);\n    }\n    if (isEqual64(index, INDEX_POSITIVE_INFINITY)) {\n        return Number.POSITIVE_INFINITY;\n    }\n    if (index.data[0] < 0x200000) {\n        return (index.data[0] * 0x100000000 + index.data[1]) * 2 ** -1074;\n    }\n    const postIndexHigh = index.data[0] - 0x200000;\n    const exponent = -1021 + (postIndexHigh >> 20);\n    const significand = 1 + ((postIndexHigh & 0xfffff) * 2 ** 32 + index.data[1]) * Number.EPSILON;\n    return significand * 2 ** exponent;\n}\n"]},"metadata":{},"sourceType":"module"}