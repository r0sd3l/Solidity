{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:storage:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeStorage(dataType, pointer, info) {\n  if (Format.Types.isReferenceType(dataType)) {\n    return yield* decodeStorageReference(dataType, pointer, info);\n  } else {\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info);\n  }\n}\n\nexports.decodeStorage = decodeStorage; //decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.\n//NOTE: ONLY for use with pointers to reference types!\n//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...\n\nfunction* decodeStorageReferenceByAddress(dataType, pointer, info) {\n  const allocations = info.allocations.storage;\n  let rawValue;\n\n  try {\n    rawValue = yield* read_1.default(pointer, info.state);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error);\n  }\n\n  const startOffset = Conversion.toBN(rawValue);\n  let rawSize;\n\n  try {\n    rawSize = allocate_1.storageSize(dataType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error);\n  } //we *know* the type being decoded must be sized in words, because it's a\n  //reference type, but TypeScript doesn't, so we'll have to use a type\n  //coercion\n\n\n  const size = rawSize.words; //now, construct the storage pointer\n\n  const newPointer = {\n    location: \"storage\",\n    range: {\n      from: {\n        slot: {\n          offset: startOffset\n        },\n        index: 0\n      },\n      to: {\n        slot: {\n          offset: startOffset.addn(size - 1)\n        },\n        index: Evm.Utils.WORD_SIZE - 1\n      }\n    }\n  }; //dispatch to decodeStorageReference\n\n  return yield* decodeStorageReference(dataType, newPointer, info);\n}\n\nexports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;\n\nfunction* decodeStorageReference(dataType, pointer, info) {\n  var data;\n  var length;\n  const {\n    state\n  } = info;\n  const allocations = info.allocations.storage;\n\n  switch (dataType.typeClass) {\n    case \"array\":\n      {\n        debug(\"storage array! %o\", pointer);\n        let lengthAsBN;\n\n        switch (dataType.kind) {\n          case \"dynamic\":\n            debug(\"dynamic array\");\n            debug(\"type %O\", dataType);\n\n            try {\n              data = yield* read_1.default(pointer, state);\n            } catch (error) {\n              return errors_1.handleDecodingError(dataType, error);\n            }\n\n            lengthAsBN = Conversion.toBN(data);\n            break;\n\n          case \"static\":\n            debug(\"static array\");\n            lengthAsBN = dataType.length;\n            break;\n        }\n\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_a) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n\n        debug(\"length %o\", length);\n        debug(\"about to determine baseSize\");\n        let baseSize;\n\n        try {\n          baseSize = allocate_1.storageSize(dataType.baseType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error);\n        }\n\n        debug(\"baseSize %o\", baseSize); //we are going to make a list of child ranges, pushing them one by one onto\n        //this list, and then decode them; the first part will vary based on whether\n        //we're in the words case or the bytes case, the second will not\n\n        let ranges = [];\n\n        if (Utils.isWordsLength(baseSize)) {\n          //currentSlot will point to the start of the entry being decoded\n          let currentSlot = {\n            path: pointer.range.from.slot,\n            offset: new bn_js_1.default(0),\n            hashPath: dataType.kind === \"dynamic\"\n          };\n\n          for (let i = 0; i < length; i++) {\n            let childRange = {\n              from: {\n                slot: {\n                  path: currentSlot.path,\n                  offset: currentSlot.offset.clone(),\n                  hashPath: currentSlot.hashPath\n                },\n                index: 0\n              },\n              to: {\n                slot: {\n                  path: currentSlot.path,\n                  offset: currentSlot.offset.addn(baseSize.words - 1),\n                  hashPath: currentSlot.hashPath\n                },\n                index: Evm.Utils.WORD_SIZE - 1\n              }\n            };\n            ranges.push(childRange);\n            currentSlot.offset.iaddn(baseSize.words);\n          }\n        } else {\n          const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n          debug(\"perWord %d\", perWord); //currentPosition will point to the start of the entry being decoded\n          //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE\n\n          let currentPosition = {\n            slot: {\n              path: pointer.range.from.slot,\n              offset: new bn_js_1.default(0),\n              hashPath: dataType.kind === \"dynamic\"\n            },\n            index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!\n\n          };\n\n          for (let i = 0; i < length; i++) {\n            let childRange = {\n              from: {\n                slot: {\n                  path: currentPosition.slot.path,\n                  offset: currentPosition.slot.offset.clone(),\n                  hashPath: currentPosition.slot.hashPath\n                },\n                index: currentPosition.index\n              },\n              length: baseSize.bytes\n            };\n            ranges.push(childRange);\n            currentPosition.index -= baseSize.bytes;\n\n            if (currentPosition.index < 0) {\n              currentPosition.slot.offset.iaddn(1);\n              currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;\n            }\n          }\n        }\n\n        let decodedChildren = [];\n\n        for (let childRange of ranges) {\n          decodedChildren.push(yield* decodeStorage(dataType.baseType, {\n            location: \"storage\",\n            range: childRange\n          }, info));\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      }\n\n    case \"bytes\":\n    case \"string\":\n      {\n        try {\n          data = yield* read_1.default(pointer, state);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error);\n        }\n\n        let lengthByte = data[Evm.Utils.WORD_SIZE - 1];\n\n        if (lengthByte % 2 == 0) {\n          // string lives in word, length is last byte / 2\n          length = lengthByte / 2;\n          debug(\"in-word; length %o\", length);\n          return yield* Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: pointer.range.from.slot,\n                index: 0\n              },\n              to: {\n                slot: pointer.range.from.slot,\n                index: length - 1\n              }\n            }\n          }, info);\n        } else {\n          let lengthAsBN = Conversion.toBN(data).subn(1).divn(2);\n\n          try {\n            length = lengthAsBN.toNumber();\n          } catch (_b) {\n            return {\n              //again with the TS failures...\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"OverlongArraysAndStringsNotImplementedError\",\n                lengthAsBN\n              }\n            };\n          }\n\n          debug(\"new-word, length %o\", length);\n          return yield* Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: {\n                  path: pointer.range.from.slot,\n                  offset: new bn_js_1.default(0),\n                  hashPath: true\n                },\n                index: 0\n              },\n              length\n            }\n          }, info);\n        }\n      }\n\n    case \"struct\":\n      {\n        const typeId = dataType.id;\n        const structAllocation = allocations[typeId];\n\n        if (!structAllocation) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          };\n        }\n\n        let decodedMembers = [];\n        const members = structAllocation.members;\n\n        for (let index = 0; index < members.length; index++) {\n          const memberAllocation = members[index];\n          const memberPointer = memberAllocation.pointer; //the type system thinks memberPointer might also be a constant\n          //definition pointer.  However, structs can't contain constants,\n          //so *we* know it's not, and can safely coerce it.\n\n          debug(\"pointer %O\", pointer);\n          const childRange = {\n            from: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.from.slot.offset.clone() //note that memberPointer should have no path\n\n              },\n              index: memberPointer.range.from.index\n            },\n            to: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.to.slot.offset.clone() //note that memberPointer should have no path\n\n              },\n              index: memberPointer.range.to.index\n            }\n          };\n          let storedType = info.userDefinedTypes[typeId];\n\n          if (!storedType) {\n            return {\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"UserDefinedTypeNotFoundError\",\n                type: dataType\n              }\n            };\n          }\n\n          let storedMemberType = storedType.memberTypes[index].type;\n          let memberType = Format.Types.specifyLocation(storedMemberType, \"storage\");\n          decodedMembers.push({\n            name: memberAllocation.name,\n            value: yield* decodeStorage(memberType, {\n              location: \"storage\",\n              range: childRange\n            }, info)\n          });\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedMembers\n        };\n      }\n\n    case \"mapping\":\n      {\n        debug(\"decoding mapping\");\n        const valueType = dataType.valueType;\n        let valueSize;\n\n        try {\n          valueSize = allocate_1.storageSize(valueType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error);\n        }\n\n        let decodedEntries = [];\n        const baseSlot = pointer.range.from.slot;\n        debug(\"baseSlot %o\", baseSlot);\n        debug(\"base slot address %o\", Utils.slotAddress(baseSlot));\n        const keySlots = info.mappingKeys.filter(_ref => {\n          let {\n            path\n          } = _ref;\n          return Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path));\n        });\n\n        for (const {\n          key\n        } of keySlots) {\n          let valuePointer;\n\n          if (Utils.isWordsLength(valueSize)) {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: 0\n                },\n                to: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(valueSize.words - 1)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          } else {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - valueSize.bytes\n                },\n                to: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          }\n\n          decodedEntries.push({\n            key,\n            value: yield* decodeStorage(valueType, valuePointer, info)\n          });\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedEntries\n        };\n      }\n  }\n}\n\nexports.decodeStorageReference = decodeStorageReference;","map":{"version":3,"sources":["../../../../lib/storage/decode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:storage:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst errors_1 = require(\"../../errors\");\nfunction* decodeStorage(dataType, pointer, info) {\n    if (Format.Types.isReferenceType(dataType)) {\n        return yield* decodeStorageReference(dataType, pointer, info);\n    }\n    else {\n        return yield* Basic.Decode.decodeBasic(dataType, pointer, info);\n    }\n}\nexports.decodeStorage = decodeStorage;\n//decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.\n//NOTE: ONLY for use with pointers to reference types!\n//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...\nfunction* decodeStorageReferenceByAddress(dataType, pointer, info) {\n    const allocations = info.allocations.storage;\n    let rawValue;\n    try {\n        rawValue = yield* read_1.default(pointer, info.state);\n    }\n    catch (error) {\n        return errors_1.handleDecodingError(dataType, error);\n    }\n    const startOffset = Conversion.toBN(rawValue);\n    let rawSize;\n    try {\n        rawSize = allocate_1.storageSize(dataType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n    }\n    catch (error) {\n        return errors_1.handleDecodingError(dataType, error);\n    }\n    //we *know* the type being decoded must be sized in words, because it's a\n    //reference type, but TypeScript doesn't, so we'll have to use a type\n    //coercion\n    const size = rawSize.words;\n    //now, construct the storage pointer\n    const newPointer = {\n        location: \"storage\",\n        range: {\n            from: {\n                slot: {\n                    offset: startOffset\n                },\n                index: 0\n            },\n            to: {\n                slot: {\n                    offset: startOffset.addn(size - 1)\n                },\n                index: Evm.Utils.WORD_SIZE - 1\n            }\n        }\n    };\n    //dispatch to decodeStorageReference\n    return yield* decodeStorageReference(dataType, newPointer, info);\n}\nexports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;\nfunction* decodeStorageReference(dataType, pointer, info) {\n    var data;\n    var length;\n    const { state } = info;\n    const allocations = info.allocations.storage;\n    switch (dataType.typeClass) {\n        case \"array\": {\n            debug(\"storage array! %o\", pointer);\n            let lengthAsBN;\n            switch (dataType.kind) {\n                case \"dynamic\":\n                    debug(\"dynamic array\");\n                    debug(\"type %O\", dataType);\n                    try {\n                        data = yield* read_1.default(pointer, state);\n                    }\n                    catch (error) {\n                        return errors_1.handleDecodingError(dataType, error);\n                    }\n                    lengthAsBN = Conversion.toBN(data);\n                    break;\n                case \"static\":\n                    debug(\"static array\");\n                    lengthAsBN = dataType.length;\n                    break;\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_a) {\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            debug(\"length %o\", length);\n            debug(\"about to determine baseSize\");\n            let baseSize;\n            try {\n                baseSize = allocate_1.storageSize(dataType.baseType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n            }\n            catch (error) {\n                return errors_1.handleDecodingError(dataType, error);\n            }\n            debug(\"baseSize %o\", baseSize);\n            //we are going to make a list of child ranges, pushing them one by one onto\n            //this list, and then decode them; the first part will vary based on whether\n            //we're in the words case or the bytes case, the second will not\n            let ranges = [];\n            if (Utils.isWordsLength(baseSize)) {\n                //currentSlot will point to the start of the entry being decoded\n                let currentSlot = {\n                    path: pointer.range.from.slot,\n                    offset: new bn_js_1.default(0),\n                    hashPath: dataType.kind === \"dynamic\"\n                };\n                for (let i = 0; i < length; i++) {\n                    let childRange = {\n                        from: {\n                            slot: {\n                                path: currentSlot.path,\n                                offset: currentSlot.offset.clone(),\n                                hashPath: currentSlot.hashPath\n                            },\n                            index: 0\n                        },\n                        to: {\n                            slot: {\n                                path: currentSlot.path,\n                                offset: currentSlot.offset.addn(baseSize.words - 1),\n                                hashPath: currentSlot.hashPath\n                            },\n                            index: Evm.Utils.WORD_SIZE - 1\n                        }\n                    };\n                    ranges.push(childRange);\n                    currentSlot.offset.iaddn(baseSize.words);\n                }\n            }\n            else {\n                const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n                debug(\"perWord %d\", perWord);\n                //currentPosition will point to the start of the entry being decoded\n                //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE\n                let currentPosition = {\n                    slot: {\n                        path: pointer.range.from.slot,\n                        offset: new bn_js_1.default(0),\n                        hashPath: dataType.kind === \"dynamic\"\n                    },\n                    index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!\n                };\n                for (let i = 0; i < length; i++) {\n                    let childRange = {\n                        from: {\n                            slot: {\n                                path: currentPosition.slot.path,\n                                offset: currentPosition.slot.offset.clone(),\n                                hashPath: currentPosition.slot.hashPath\n                            },\n                            index: currentPosition.index\n                        },\n                        length: baseSize.bytes\n                    };\n                    ranges.push(childRange);\n                    currentPosition.index -= baseSize.bytes;\n                    if (currentPosition.index < 0) {\n                        currentPosition.slot.offset.iaddn(1);\n                        currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;\n                    }\n                }\n            }\n            let decodedChildren = [];\n            for (let childRange of ranges) {\n                decodedChildren.push(yield* decodeStorage(dataType.baseType, { location: \"storage\", range: childRange }, info));\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        }\n        case \"bytes\":\n        case \"string\": {\n            try {\n                data = yield* read_1.default(pointer, state);\n            }\n            catch (error) {\n                return errors_1.handleDecodingError(dataType, error);\n            }\n            let lengthByte = data[Evm.Utils.WORD_SIZE - 1];\n            if (lengthByte % 2 == 0) {\n                // string lives in word, length is last byte / 2\n                length = lengthByte / 2;\n                debug(\"in-word; length %o\", length);\n                return yield* Bytes.Decode.decodeBytes(dataType, {\n                    location: \"storage\",\n                    range: {\n                        from: { slot: pointer.range.from.slot, index: 0 },\n                        to: { slot: pointer.range.from.slot, index: length - 1 }\n                    }\n                }, info);\n            }\n            else {\n                let lengthAsBN = Conversion.toBN(data)\n                    .subn(1)\n                    .divn(2);\n                try {\n                    length = lengthAsBN.toNumber();\n                }\n                catch (_b) {\n                    return {\n                        //again with the TS failures...\n                        type: dataType,\n                        kind: \"error\",\n                        error: {\n                            kind: \"OverlongArraysAndStringsNotImplementedError\",\n                            lengthAsBN\n                        }\n                    };\n                }\n                debug(\"new-word, length %o\", length);\n                return yield* Bytes.Decode.decodeBytes(dataType, {\n                    location: \"storage\",\n                    range: {\n                        from: {\n                            slot: {\n                                path: pointer.range.from.slot,\n                                offset: new bn_js_1.default(0),\n                                hashPath: true\n                            },\n                            index: 0\n                        },\n                        length\n                    }\n                }, info);\n            }\n        }\n        case \"struct\": {\n            const typeId = dataType.id;\n            const structAllocation = allocations[typeId];\n            if (!structAllocation) {\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"UserDefinedTypeNotFoundError\",\n                        type: dataType\n                    }\n                };\n            }\n            let decodedMembers = [];\n            const members = structAllocation.members;\n            for (let index = 0; index < members.length; index++) {\n                const memberAllocation = members[index];\n                const memberPointer = memberAllocation.pointer;\n                //the type system thinks memberPointer might also be a constant\n                //definition pointer.  However, structs can't contain constants,\n                //so *we* know it's not, and can safely coerce it.\n                debug(\"pointer %O\", pointer);\n                const childRange = {\n                    from: {\n                        slot: {\n                            path: pointer.range.from.slot,\n                            offset: memberPointer.range.from.slot.offset.clone()\n                            //note that memberPointer should have no path\n                        },\n                        index: memberPointer.range.from.index\n                    },\n                    to: {\n                        slot: {\n                            path: pointer.range.from.slot,\n                            offset: memberPointer.range.to.slot.offset.clone()\n                            //note that memberPointer should have no path\n                        },\n                        index: memberPointer.range.to.index\n                    }\n                };\n                let storedType = info.userDefinedTypes[typeId];\n                if (!storedType) {\n                    return {\n                        type: dataType,\n                        kind: \"error\",\n                        error: {\n                            kind: \"UserDefinedTypeNotFoundError\",\n                            type: dataType\n                        }\n                    };\n                }\n                let storedMemberType = storedType.memberTypes[index].type;\n                let memberType = Format.Types.specifyLocation(storedMemberType, \"storage\");\n                decodedMembers.push({\n                    name: memberAllocation.name,\n                    value: yield* decodeStorage(memberType, { location: \"storage\", range: childRange }, info)\n                });\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedMembers\n            };\n        }\n        case \"mapping\": {\n            debug(\"decoding mapping\");\n            const valueType = dataType.valueType;\n            let valueSize;\n            try {\n                valueSize = allocate_1.storageSize(valueType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n            }\n            catch (error) {\n                return errors_1.handleDecodingError(dataType, error);\n            }\n            let decodedEntries = [];\n            const baseSlot = pointer.range.from.slot;\n            debug(\"baseSlot %o\", baseSlot);\n            debug(\"base slot address %o\", Utils.slotAddress(baseSlot));\n            const keySlots = info.mappingKeys.filter(({ path }) => Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path)));\n            for (const { key } of keySlots) {\n                let valuePointer;\n                if (Utils.isWordsLength(valueSize)) {\n                    valuePointer = {\n                        location: \"storage\",\n                        range: {\n                            from: {\n                                slot: {\n                                    key,\n                                    path: baseSlot,\n                                    offset: new bn_js_1.default(0)\n                                },\n                                index: 0\n                            },\n                            to: {\n                                slot: {\n                                    key,\n                                    path: baseSlot,\n                                    offset: new bn_js_1.default(valueSize.words - 1)\n                                },\n                                index: Evm.Utils.WORD_SIZE - 1\n                            }\n                        }\n                    };\n                }\n                else {\n                    valuePointer = {\n                        location: \"storage\",\n                        range: {\n                            from: {\n                                slot: {\n                                    key,\n                                    path: baseSlot,\n                                    offset: new bn_js_1.default(0)\n                                },\n                                index: Evm.Utils.WORD_SIZE - valueSize.bytes\n                            },\n                            to: {\n                                slot: {\n                                    key,\n                                    path: baseSlot,\n                                    offset: new bn_js_1.default(0)\n                                },\n                                index: Evm.Utils.WORD_SIZE - 1\n                            }\n                        }\n                    };\n                }\n                decodedEntries.push({\n                    key,\n                    value: yield* decodeStorage(valueType, valuePointer, info)\n                });\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedEntries\n            };\n        }\n    }\n}\nexports.decodeStorageReference = decodeStorageReference;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}