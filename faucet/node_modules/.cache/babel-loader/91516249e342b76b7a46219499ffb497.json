{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forBytecode = exports.forContract = exports.forContracts = void 0;\n\nfunction forContracts(contracts) {\n  // convert to list\n  return Object.values(contracts).map(forContract);\n}\n\nexports.forContracts = forContracts;\n\nfunction forContract(contract) {\n  const {\n    contractName,\n    contract_name,\n    sourcePath,\n    source,\n    sourceMap,\n    deployedSourceMap,\n    legacyAST,\n    ast,\n    abi,\n    metadata,\n    bytecode,\n    deployedBytecode,\n    compiler,\n    devdoc,\n    userdoc,\n    immutableReferences,\n    generatedSources,\n    deployedGeneratedSources,\n    db\n  } = contract;\n  return {\n    contractName: contract_name || contractName,\n    sourcePath,\n    source,\n    sourceMap,\n    deployedSourceMap,\n    legacyAST,\n    ast,\n    abi,\n    metadata,\n    bytecode: forBytecode(bytecode),\n    deployedBytecode: forBytecode(deployedBytecode),\n    compiler,\n    devdoc,\n    userdoc,\n    immutableReferences,\n    generatedSources,\n    deployedGeneratedSources,\n    db\n  };\n}\n\nexports.forContract = forContract;\n\nfunction forBytecode(bytecode) {\n  if (!bytecode) {\n    return undefined;\n  }\n\n  if (typeof bytecode === \"object\") {\n    return bytecode;\n  }\n\n  const linkReferences = [];\n  const bytes = bytecode.slice(2) // remove 0x prefix\n  .replace(/__[^_]+_*/g, (linkReference, characterOffset) => {\n    const [, name] = linkReference.match(/__([^_]+)_*/);\n    const characterLength = linkReference.length;\n    const offset = characterOffset / 2;\n    const length = characterLength / 2;\n    linkReferences.push({\n      offsets: [offset],\n      name,\n      length\n    });\n    return \"0\".repeat(characterLength);\n  });\n  return {\n    bytes,\n    linkReferences\n  };\n}\n\nexports.forBytecode = forBytecode;","map":{"version":3,"sources":["../../../src/shims/LegacyToNew.ts"],"names":[],"mappings":";;;;;;;AAEA,SAAgB,YAAhB,CAA6B,SAA7B,EAA6C;AAC3C;AACA,SAAO,MAAM,CAAC,MAAP,CAAc,SAAd,EAAyB,GAAzB,CAA6B,WAA7B,CAAP;AACD;;AAHD,OAAA,CAAA,YAAA,GAAA,YAAA;;AAKA,SAAgB,WAAhB,CAA4B,QAA5B,EAAyC;AACvC,QAAM;AACJ,IAAA,YADI;AAEJ,IAAA,aAFI;AAGJ,IAAA,UAHI;AAIJ,IAAA,MAJI;AAKJ,IAAA,SALI;AAMJ,IAAA,iBANI;AAOJ,IAAA,SAPI;AAQJ,IAAA,GARI;AASJ,IAAA,GATI;AAUJ,IAAA,QAVI;AAWJ,IAAA,QAXI;AAYJ,IAAA,gBAZI;AAaJ,IAAA,QAbI;AAcJ,IAAA,MAdI;AAeJ,IAAA,OAfI;AAgBJ,IAAA,mBAhBI;AAiBJ,IAAA,gBAjBI;AAkBJ,IAAA,wBAlBI;AAmBJ,IAAA;AAnBI,MAoBF,QApBJ;AAsBA,SAAO;AACL,IAAA,YAAY,EAAE,aAAa,IAAI,YAD1B;AAEL,IAAA,UAFK;AAGL,IAAA,MAHK;AAIL,IAAA,SAJK;AAKL,IAAA,iBALK;AAML,IAAA,SANK;AAOL,IAAA,GAPK;AAQL,IAAA,GARK;AASL,IAAA,QATK;AAUL,IAAA,QAAQ,EAAE,WAAW,CAAC,QAAD,CAVhB;AAWL,IAAA,gBAAgB,EAAE,WAAW,CAAC,gBAAD,CAXxB;AAYL,IAAA,QAZK;AAaL,IAAA,MAbK;AAcL,IAAA,OAdK;AAeL,IAAA,mBAfK;AAgBL,IAAA,gBAhBK;AAiBL,IAAA,wBAjBK;AAkBL,IAAA;AAlBK,GAAP;AAoBD;;AA3CD,OAAA,CAAA,WAAA,GAAA,WAAA;;AA6CA,SAAgB,WAAhB,CAA4B,QAA5B,EAA4C;AAC1C,MAAI,CAAC,QAAL,EAAe;AACb,WAAO,SAAP;AACD;;AACD,MAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,WAAO,QAAP;AACD;;AAED,QAAM,cAAc,GAAoB,EAAxC;AAEA,QAAM,KAAK,GAAG,QAAQ,CACnB,KADW,CACL,CADK,EACF;AADE,GAEX,OAFW,CAEH,YAFG,EAEW,CAAC,aAAD,EAAgB,eAAhB,KAAmC;AACxD,UAAM,GAAG,IAAH,IAAW,aAAa,CAAC,KAAd,CAAoB,aAApB,CAAjB;AAEA,UAAM,eAAe,GAAG,aAAa,CAAC,MAAtC;AAEA,UAAM,MAAM,GAAG,eAAe,GAAG,CAAjC;AACA,UAAM,MAAM,GAAG,eAAe,GAAG,CAAjC;AAEA,IAAA,cAAc,CAAC,IAAf,CAAoB;AAClB,MAAA,OAAO,EAAE,CAAC,MAAD,CADS;AAElB,MAAA,IAFkB;AAGlB,MAAA;AAHkB,KAApB;AAMA,WAAO,IAAI,MAAJ,CAAW,eAAX,CAAP;AACD,GAjBW,CAAd;AAmBA,SAAO;AAAE,IAAA,KAAF;AAAS,IAAA;AAAT,GAAP;AACD;;AA9BD,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.forBytecode = exports.forContract = exports.forContracts = void 0;\nfunction forContracts(contracts) {\n    // convert to list\n    return Object.values(contracts).map(forContract);\n}\nexports.forContracts = forContracts;\nfunction forContract(contract) {\n    const { contractName, contract_name, sourcePath, source, sourceMap, deployedSourceMap, legacyAST, ast, abi, metadata, bytecode, deployedBytecode, compiler, devdoc, userdoc, immutableReferences, generatedSources, deployedGeneratedSources, db } = contract;\n    return {\n        contractName: contract_name || contractName,\n        sourcePath,\n        source,\n        sourceMap,\n        deployedSourceMap,\n        legacyAST,\n        ast,\n        abi,\n        metadata,\n        bytecode: forBytecode(bytecode),\n        deployedBytecode: forBytecode(deployedBytecode),\n        compiler,\n        devdoc,\n        userdoc,\n        immutableReferences,\n        generatedSources,\n        deployedGeneratedSources,\n        db\n    };\n}\nexports.forContract = forContract;\nfunction forBytecode(bytecode) {\n    if (!bytecode) {\n        return undefined;\n    }\n    if (typeof bytecode === \"object\") {\n        return bytecode;\n    }\n    const linkReferences = [];\n    const bytes = bytecode\n        .slice(2) // remove 0x prefix\n        .replace(/__[^_]+_*/g, (linkReference, characterOffset) => {\n        const [, name] = linkReference.match(/__([^_]+)_*/);\n        const characterLength = linkReference.length;\n        const offset = characterOffset / 2;\n        const length = characterLength / 2;\n        linkReferences.push({\n            offsets: [offset],\n            name,\n            length\n        });\n        return \"0\".repeat(characterLength);\n    });\n    return { bytes, linkReferences };\n}\nexports.forBytecode = forBytecode;\n//# sourceMappingURL=LegacyToNew.js.map"]},"metadata":{},"sourceType":"script"}