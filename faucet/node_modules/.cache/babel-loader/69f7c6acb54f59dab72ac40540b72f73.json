{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectSources = void 0;\n\nconst path = __importStar(require(\"path\"));\n/**\n * Collects sources, targets into collections with OS-independent paths,\n * along with a reverse mapping to the original path (for post-processing)\n *\n * @param originalSources - { [originalSourcePath]: contents }\n * @param originalTargets - originalSourcePath[]\n * @param baseDirectory - a directory to remove as a prefix\n * @param replacement - what to replace it with\n * @return { sources, targets, originalSourcePaths }\n */\n\n\nfunction collectSources(originalSources) {\n  let originalTargets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let baseDirectory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let replacement = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"/\";\n  const mappedResults = Object.entries(originalSources).filter(_ref => {\n    let [originalSourcePath, _] = _ref;\n    return !path.isAbsolute(originalSourcePath) || originalSourcePath.startsWith(baseDirectory);\n  }).map(_ref2 => {\n    let [originalSourcePath, contents] = _ref2;\n    return {\n      originalSourcePath,\n      contents,\n      sourcePath: getPortableSourcePath(replaceRootDirectory(originalSourcePath, baseDirectory, replacement))\n    };\n  }).map(_ref3 => {\n    let {\n      originalSourcePath,\n      sourcePath,\n      contents\n    } = _ref3;\n    return {\n      sources: {\n        [sourcePath]: contents\n      },\n      // include transformed form as target if original is a target\n      targets: originalTargets.includes(originalSourcePath) ? [sourcePath] : [],\n      originalSourcePaths: {\n        [sourcePath]: originalSourcePath\n      }\n    };\n  });\n  const defaultAccumulator = {\n    sources: {},\n    targets: [],\n    originalSourcePaths: {}\n  };\n  return mappedResults.reduce((accumulator, result) => ({\n    sources: Object.assign({}, accumulator.sources, result.sources),\n    targets: [...accumulator.targets, ...result.targets],\n    originalSourcePaths: Object.assign({}, accumulator.originalSourcePaths, result.originalSourcePaths)\n  }), defaultAccumulator);\n}\n\nexports.collectSources = collectSources;\n/**\n * @param sourcePath - string\n * @return string - operating system independent path\n * @private\n */\n\nfunction getPortableSourcePath(sourcePath) {\n  let replacement = sourcePath; //on Windows, replace backslashes with forward slashes\n\n  if (path.sep === '\\\\') {\n    replacement = sourcePath.replace(/\\\\/g, \"/\");\n  } // Turn G:/.../ into /G/.../ for Windows\n\n\n  if (replacement.length >= 2 && replacement[1] === \":\") {\n    replacement = \"/\" + replacement;\n    replacement = replacement.replace(\":\", \"\");\n  }\n\n  return replacement;\n}\n\nfunction replaceRootDirectory(sourcePath, rootDirectory, replacement) {\n  //make sure root directory ends in a separator\n  if (!rootDirectory.endsWith(path.sep)) {\n    rootDirectory = rootDirectory + path.sep;\n  }\n\n  return sourcePath.startsWith(rootDirectory) ? replacement + sourcePath.slice(rootDirectory.length) //remove prefix\n  : sourcePath;\n}","map":{"version":3,"sources":["../../src/sources.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.collectSources = void 0;\nconst path = __importStar(require(\"path\"));\n/**\n * Collects sources, targets into collections with OS-independent paths,\n * along with a reverse mapping to the original path (for post-processing)\n *\n * @param originalSources - { [originalSourcePath]: contents }\n * @param originalTargets - originalSourcePath[]\n * @param baseDirectory - a directory to remove as a prefix\n * @param replacement - what to replace it with\n * @return { sources, targets, originalSourcePaths }\n */\nfunction collectSources(originalSources, originalTargets = [], baseDirectory = \"\", replacement = \"/\") {\n    const mappedResults = Object.entries(originalSources)\n        .filter(([originalSourcePath, _]) => !path.isAbsolute(originalSourcePath) ||\n        originalSourcePath.startsWith(baseDirectory))\n        .map(([originalSourcePath, contents]) => ({\n        originalSourcePath,\n        contents,\n        sourcePath: getPortableSourcePath(replaceRootDirectory(originalSourcePath, baseDirectory, replacement))\n    }))\n        .map(({ originalSourcePath, sourcePath, contents }) => ({\n        sources: {\n            [sourcePath]: contents\n        },\n        // include transformed form as target if original is a target\n        targets: originalTargets.includes(originalSourcePath) ? [sourcePath] : [],\n        originalSourcePaths: {\n            [sourcePath]: originalSourcePath\n        }\n    }));\n    const defaultAccumulator = {\n        sources: {},\n        targets: [],\n        originalSourcePaths: {}\n    };\n    return mappedResults.reduce((accumulator, result) => ({\n        sources: Object.assign({}, accumulator.sources, result.sources),\n        targets: [...accumulator.targets, ...result.targets],\n        originalSourcePaths: Object.assign({}, accumulator.originalSourcePaths, result.originalSourcePaths)\n    }), defaultAccumulator);\n}\nexports.collectSources = collectSources;\n/**\n * @param sourcePath - string\n * @return string - operating system independent path\n * @private\n */\nfunction getPortableSourcePath(sourcePath) {\n    let replacement = sourcePath;\n    //on Windows, replace backslashes with forward slashes\n    if (path.sep === '\\\\') {\n        replacement = sourcePath.replace(/\\\\/g, \"/\");\n    }\n    // Turn G:/.../ into /G/.../ for Windows\n    if (replacement.length >= 2 && replacement[1] === \":\") {\n        replacement = \"/\" + replacement;\n        replacement = replacement.replace(\":\", \"\");\n    }\n    return replacement;\n}\nfunction replaceRootDirectory(sourcePath, rootDirectory, replacement) {\n    //make sure root directory ends in a separator\n    if (!rootDirectory.endsWith(path.sep)) {\n        rootDirectory = rootDirectory + path.sep;\n    }\n    return sourcePath.startsWith(rootDirectory)\n        ? replacement + sourcePath.slice(rootDirectory.length) //remove prefix\n        : sourcePath;\n}\n//# sourceMappingURL=sources.js.map"]},"metadata":{},"sourceType":"script"}