{"ast":null,"code":"const OS = require(\"os\");\n\nconst debug = require(\"debug\")(\"debug-utils\");\n\nconst util = require(\"util\");\n\nconst Codec = require(\"@truffle/codec\");\n\nconst BN = require(\"bn.js\");\n\nconst chromafi = require(\"@trufflesuite/chromafi\");\n\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\n\nhljsDefineSolidity(chromafi.hljs);\n\nconst chalk = require(\"chalk\");\n\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\nconst commandReference = {\n  o: \"step over\",\n  i: \"step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  p: \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  l: \"print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)\",\n  h: \"print this help\",\n  v: \"print variables and values (`v [bui|glo|con|loc]*`)\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  b: \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  B: \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  c: \"continue until breakpoint\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load new transaction\",\n  T: \"unload transaction\",\n  s: \"print stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources except via `;`\",\n  y: \"(if at end) reset & continue to final error\",\n  Y: \"reset & continue to previous error\"\n};\nconst shortCommandReference = {\n  o: \"step over\",\n  i: \"step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction\",\n  p: \"print state\",\n  l: \"print context\",\n  h: \"print help\",\n  v: \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  b: \"add breakpoint\",\n  B: \"remove breakpoint\",\n  c: \"continue\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load\",\n  T: \"unload\",\n  s: \"stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources\",\n  y: \"reset & go to final error\",\n  Y: \"reset & go to previous error\"\n};\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\nconst DEFAULT_TAB_WIDTH = 8;\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  base: chalk,\n  lineNumbers: chalk,\n  trailingSpace: chalk,\n\n  /* classes hljs-solidity actually uses */\n  keyword: truffleColors.mint,\n  number: truffleColors.red,\n  string: truffleColors.green,\n  params: truffleColors.pink,\n  builtIn: truffleColors.watermelon,\n  built_in: truffleColors.watermelon,\n  //just to be sure\n  literal: truffleColors.watermelon,\n  function: truffleColors.orange,\n  title: truffleColors.orange,\n  class: truffleColors.orange,\n  comment: truffleColors.comment,\n  doctag: truffleColors.comment,\n  operator: truffleColors.blue,\n  punctuation: truffleColors.purple,\n\n  /* classes it might soon use! */\n  meta: truffleColors.pink,\n  metaString: truffleColors.green,\n  \"meta-string\": truffleColors.green,\n  //similar\n\n  /* classes it doesn't currently use but notionally could */\n  type: truffleColors.orange,\n  symbol: truffleColors.orange,\n  metaKeyword: truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint,\n  //again, to be sure\n  property: chalk,\n  //not putting any highlighting here for now\n\n  /* classes that don't make sense for Solidity */\n  regexp: chalk,\n  //solidity does not have regexps\n  subst: chalk,\n  //or string interpolation\n  name: chalk,\n  //or s-expressions\n  builtInName: chalk,\n  //or s-expressions, again\n  \"builtin-name\": chalk,\n  //just to be sure\n\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  section: chalk,\n  tag: chalk,\n  attr: chalk,\n  attribute: chalk,\n  variable: chalk,\n  bullet: chalk,\n  code: chalk,\n  emphasis: chalk,\n  strong: chalk,\n  formula: chalk,\n  link: chalk,\n  quote: chalk,\n  selectorAttr: chalk,\n  //lotta redundancy follows\n  \"selector-attr\": chalk,\n  selectorClass: chalk,\n  \"selector-class\": chalk,\n  selectorId: chalk,\n  \"selector-id\": chalk,\n  selectorPseudo: chalk,\n  \"selector-pseudo\": chalk,\n  selectorTag: chalk,\n  \"selector-tag\": chalk,\n  templateTag: chalk,\n  \"template-tag\": chalk,\n  templateVariable: chalk,\n  \"template-variable\": chalk,\n  addition: chalk,\n  deletion: chalk\n};\nvar DebugUtils = {\n  truffleColors,\n  //make these externally available\n  //panicCode may be either a number or a BN\n  panicString: function (panicCode) {\n    let verbose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n\n    return verbose ? verbosePanicTable[panicCode] || verboseUnknownString : panicTable[panicCode] || unknownString;\n  },\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    } //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n\n\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    const lowestInternalIndex = Math.min(...compilation.contracts.map(contract => {\n      //find first defined index\n      let lowestConstructor = (contract.generatedSources || []).findIndex(x => x !== undefined);\n\n      if (lowestConstructor === -1) {\n        lowestConstructor = Infinity;\n      }\n\n      let lowestDeployed = (contract.deployedGeneratedSources || []).findIndex(x => x !== undefined);\n\n      if (lowestDeployed === -1) {\n        lowestDeployed = Infinity;\n      }\n\n      return Math.min(lowestConstructor, lowestDeployed);\n    }));\n\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    } //check #4: are there any AST ID collisions?\n\n\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occured twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    }; //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n\n\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(source => !source || source.language !== \"Solidity\" || allIDsUnseenSoFar(source.ast));\n  },\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n  formatCommandDescription: function (commandId) {\n    return truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId];\n  },\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined ? `debug(${network}:${txHash.substring(0, 10)}...)> ` : `debug(${network})> `;\n  },\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(`${chalk.bold(\"Warning:\")} The source code for one or more contracts could not be found.`);\n    }\n\n    return lines.join(OS.EOL);\n  },\n  formatHelp: function () {\n    let lastCommand = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"n\";\n    var prefix = [\"Commands:\", truffleColors.mint(\"(enter)\") + \" last command entered (\" + shortCommandReference[lastCommand] + \")\"];\n    var commandSections = [[\"o\", \"i\", \"u\", \"n\"], [\"c\", \"Y\"], [\"y\"], [\";\"], [\"g\", \"G\"], [\"p\"], [\"l\"], [\"s\", \"h\"], [\"q\", \"r\", \"t\", \"T\"], [\"b\"], [\"B\"], [\"+\", \"-\"], [\"?\"], [\"v\"], [\":\"]].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n    var suffix = [\"\"];\n    var lines = prefix.concat(commandSections).concat(suffix);\n    return lines.join(OS.EOL);\n  },\n  tabsToSpaces: function (inputLine) {\n    let tabLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_TAB_WIDTH;\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n\n    return line;\n  },\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n    return prefix + line;\n  },\n  formatLinePointer: function (line, startCol, endCol, padding) {\n    let tabLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_TAB_WIDTH;\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n      let additional;\n\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (source, range, uncolorizedSource) {\n    let contextBefore = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    let contextAfter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n    //note: beforeLines now includes the line itself\n\n    var beforeLines = source.slice(startIndex, range.start.line + 1).map((line, index) => {\n      let number = startIndex + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var afterLines = source.slice(range.start.line + 1, endIndex + 1).map((line, index) => {\n      let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var pointerStart = range.start.column;\n    var pointerEnd;\n    let uncolorizedLine = uncolorizedSource[range.start.line]; // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat([DebugUtils.formatLinePointer( //the line-pointer formatter doesn't work right with colorized\n    //lines, so we pass in the uncolored version\n    uncolorizedLine, pointerStart, pointerEnd, prefixLength)], afterLines);\n    return allLines.join(OS.EOL);\n  },\n  formatBreakpointLocation: function (breakpoint, here, currentSourceId, sourceNames) {\n    let baseMessage;\n\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here ? `this point in line ${breakpoint.line + 1}` : `a point in line ${breakpoint.line + 1}`; //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n  formatCurrentInstruction: function (instruction) {\n    const pc = this.formatPC(instruction.pc);\n    const formattedInstruction = this.formatInstruction(instruction);\n    return \"-> \" + truffleColors.mint(formattedInstruction) + pc;\n  },\n  formatInstruction: function (instruction) {\n    return truffleColors.mint(instruction.name + \" \" + (instruction.pushData || \"\"));\n  },\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n\n    return \" (PC=\" + pc.toString() + \", 0x\" + hex + \")\";\n  },\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(2, ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n    let formatted = slots.map((slot, index) => {\n      if (index === 0 || !Codec.Conversion.toBN(slot).eq(Codec.Conversion.toBN(slots[index - 1]).addn(1))) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n\n    for (let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE; wordIndex < calldata.length; wordIndex += Codec.Evm.Utils.WORD_SIZE) {\n      words.push(calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE));\n    }\n\n    let maxWordIndex = (words.length - 1) * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n\n    let formattedSelector;\n\n    if (selector.length > 0) {\n      formattedSelector = \"Calldata:\\n\" + `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` + truffleColors.pink(Codec.Conversion.toHexString(selector).slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \"));\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word).slice(2).padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n    formatted.unshift(formattedSelector);\n    return formatted.join(OS.EOL);\n  },\n  formatValue: function (value) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let nativized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized ? value : new Codec.Format.Utils.Inspect.ResultInspector(value);\n    return util.inspect(valueToInspect, inspectOptions).split(/\\r?\\n/g).map((line, i) => {\n      // don't indent first line\n      const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n      return padding + line;\n    }).join(OS.EOL);\n  },\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const name = decoding.definedIn ? `${decoding.definedIn.typeName}.${decoding.abi.name}` : decoding.abi.name;\n\n    if (decoding.arguments.length === 0) {\n      return `${name}()`;\n    }\n\n    const prefix = `${name}(`;\n    const formattedValues = decoding.arguments.map(_ref => {\n      let {\n        name,\n        value\n      } = _ref;\n      const argumentPrefix = name ? `${name}: ` : \"\";\n      const typeString = ` (type: ${Codec.Format.Types.typeStringWithoutLocation(value.type)})`;\n      return (DebugUtils.formatValue(value, argumentPrefix.length) + typeString + \",\").split(/\\r?\\n/g).map(line => \" \".repeat(indent) + line).join(OS.EOL);\n    });\n    return [prefix, ...formattedValues, \")\"].join(OS.EOL);\n  },\n  formatStacktrace: function (stacktrace) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    //get message or panic code from stacktrace\n    const {\n      message,\n      panic,\n      custom\n    } = stacktrace[0]; //we want to print inner to outer, so first, let's\n    //reverse\n\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n\n    let lines = stacktrace.map(_ref2 => {\n      let {\n        functionName,\n        contractName,\n        address,\n        location,\n        type\n      } = _ref2;\n      let name;\n\n      if (contractName && functionName) {\n        name = `${contractName}.${functionName}`;\n      } else if (contractName) {\n        name = contractName;\n      } else if (functionName) {\n        name = functionName;\n      } else {\n        name = \"unknown function\";\n      }\n\n      let locationString;\n\n      if (location) {\n        let {\n          source: {\n            sourcePath\n          },\n          sourceRange: {\n            lines: {\n              start: {\n                line,\n                column\n              }\n            }\n          }\n        } = location;\n        locationString = sourcePath ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n        : \"unknown location\";\n      } else {\n        locationString = \"unknown location\";\n      }\n\n      let addressString = type === \"external\" ? address !== undefined ? ` [address ${address}]` : \" [unknown address]\" : \"\";\n      return `at ${name}${addressString} (${locationString})`;\n    });\n    let status = stacktrace[0].status;\n\n    if (status != undefined) {\n      let statusLine;\n\n      if (message !== undefined) {\n        statusLine = status ? `Error: Improper return (caused message: ${message})` : `Error: Revert (message: ${message})`;\n      } else if (panic !== undefined) {\n        statusLine = status ? `Panic: Improper return (caused ${DebugUtils.panicString(panic).toLowerCase()} (code 0x${panic.toString(16)}))` : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(16)})`;\n      } else if (custom !== undefined) {\n        statusLine = status ? `Error: Improper return (caused custom error)` : `Error: Revert (custom error)`;\n      } else {\n        statusLine = status ? \"Error: Improper return (may be an unexpected self-destruct)\" : \"Error: Revert or exceptional halt\";\n      }\n\n      lines.unshift(statusLine);\n    }\n\n    let indented = lines.map((line, index) => index === 0 ? line : \" \".repeat(indent) + line);\n    return indented.join(OS.EOL);\n  },\n  colorize: function (code) {\n    let language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Solidity\";\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false,\n      //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false //NOTE: you might think you should pass highlight: true,\n      //but you'd be wrong!  I don't understand this either\n\n    };\n\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n\n        return chromafi(code, options);\n\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n\n        return chromafi(code, options);\n\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign({}, ...Object.entries(variables).map(_ref3 => {\n      let [variable, value] = _ref3;\n      return variable === \"this\" ? {\n        [replacement]: value\n      } : {\n        [variable]: value\n      };\n    }));\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const {\n      controller\n    } = bugger.selectors;\n\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const {\n        compilationId,\n        id,\n        internal\n      } = source; //stepInto should skip internal sources, but there still might be\n      //one at the end\n\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = { ...sources[compilationId],\n          [id]: source\n        };\n      }\n\n      await bugger.stepInto();\n    }\n\n    await bugger.reset(); //flatten sources before returning\n\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\nmodule.exports = DebugUtils;","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/@truffle/debug-utils/index.js"],"names":["OS","require","debug","util","Codec","BN","chromafi","hljsDefineSolidity","hljs","chalk","panicTable","verbosePanicTable","commandReference","o","i","u","n","p","l","h","v","b","B","c","q","r","t","T","s","g","G","y","Y","shortCommandReference","truffleColors","mint","hex","orange","pink","purple","green","red","yellow","blue","comment","hsl","watermelon","periwinkle","DEFAULT_TAB_WIDTH","trufflePalette","base","lineNumbers","trailingSpace","keyword","number","string","params","builtIn","built_in","literal","function","title","class","doctag","operator","punctuation","meta","metaString","type","symbol","metaKeyword","property","regexp","subst","name","builtInName","section","tag","attr","attribute","variable","bullet","code","emphasis","strong","formula","link","quote","selectorAttr","selectorClass","selectorId","selectorPseudo","selectorTag","templateTag","templateVariable","addition","deletion","DebugUtils","panicString","panicCode","verbose","unknownString","verboseUnknownString","isBN","toNumber","_","isUsableCompilation","compilation","unreliableSourceOrder","sources","includes","undefined","lowestInternalIndex","Math","min","contracts","map","contract","lowestConstructor","generatedSources","findIndex","x","Infinity","lowestDeployed","deployedGeneratedSources","length","astIds","Set","allIDsUnseenSoFar","node","Array","isArray","every","id","has","add","Object","values","source","language","ast","formatStartMessage","withTransaction","formatTransactionStartMessage","formatCommandDescription","commandId","formatPrompt","network","txHash","substring","formatAffectedInstances","instances","hasAllSource","lines","keys","address","instance","contractName","push","bold","join","EOL","formatHelp","lastCommand","prefix","commandSections","shortcuts","suffix","concat","tabsToSpaces","inputLine","tabLength","line","counter","remaining","repeat","formatLineNumberPrefix","cols","String","padStart","formatLinePointer","startCol","endCol","padding","output","pointedAt","additional","replace","formatRangeLines","range","uncolorizedSource","contextBefore","contextAfter","startIndex","max","start","endIndex","prefixLength","beforeLines","slice","index","afterLines","pointerStart","column","pointerEnd","uncolorizedLine","end","allLines","formatBreakpointLocation","breakpoint","here","currentSourceId","sourceNames","baseMessage","sourceId","sourceName","formatCurrentInstruction","instruction","pc","formatPC","formattedInstruction","formatInstruction","pushData","toString","formatStack","stack","formatted","item","unshift","formatMemory","memory","maxPrefixLength","Evm","Utils","WORD_SIZE","word","formatStorage","storage","slots","sort","slot","Conversion","toBN","eq","addn","formatCalldata","calldata","selector","SELECTOR_SIZE","words","wordIndex","maxWordIndex","formattedSelector","toHexString","data","padEnd","formatValue","value","indent","nativized","inspectOptions","colors","depth","maxArrayLength","breakLength","valueToInspect","Format","Inspect","ResultInspector","inspect","split","formatCustomError","decoding","definedIn","typeName","abi","arguments","formattedValues","argumentPrefix","typeString","Types","typeStringWithoutLocation","formatStacktrace","stacktrace","message","panic","custom","reverse","functionName","location","locationString","sourcePath","sourceRange","addressString","status","statusLine","toLowerCase","indented","colorize","options","lang","stripIndent","codePad","lineEndPad","cleanThis","variables","replacement","assign","entries","getTransactionSourcesBeforeStarting","bugger","reset","controller","selectors","view","current","trace","finished","compilationId","internal","stepInto","module","exports"],"mappings":"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","sourcesContent":["const OS = require(\"os\");\nconst debug = require(\"debug\")(\"debug-utils\");\nconst util = require(\"util\");\nconst Codec = require(\"@truffle/codec\");\nconst BN = require(\"bn.js\");\n\nconst chromafi = require(\"@trufflesuite/chromafi\");\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\nhljsDefineSolidity(chromafi.hljs);\nconst chalk = require(\"chalk\");\n\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\n\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\n\nconst commandReference = {\n  o: \"step over\",\n  i: \"step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  p: \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  l: \"print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)\",\n  h: \"print this help\",\n  v: \"print variables and values (`v [bui|glo|con|loc]*`)\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  b: \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  B: \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  c: \"continue until breakpoint\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load new transaction\",\n  T: \"unload transaction\",\n  s: \"print stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources except via `;`\",\n  y: \"(if at end) reset & continue to final error\",\n  Y: \"reset & continue to previous error\"\n};\n\nconst shortCommandReference = {\n  o: \"step over\",\n  i: \"step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction\",\n  p: \"print state\",\n  l: \"print context\",\n  h: \"print help\",\n  v: \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  b: \"add breakpoint\",\n  B: \"remove breakpoint\",\n  c: \"continue\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load\",\n  T: \"unload\",\n  s: \"stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources\",\n  y: \"reset & go to final error\",\n  Y: \"reset & go to previous error\"\n};\n\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\n\nconst DEFAULT_TAB_WIDTH = 8;\n\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  base: chalk,\n  lineNumbers: chalk,\n  trailingSpace: chalk,\n  /* classes hljs-solidity actually uses */\n  keyword: truffleColors.mint,\n  number: truffleColors.red,\n  string: truffleColors.green,\n  params: truffleColors.pink,\n  builtIn: truffleColors.watermelon,\n  built_in: truffleColors.watermelon, //just to be sure\n  literal: truffleColors.watermelon,\n  function: truffleColors.orange,\n  title: truffleColors.orange,\n  class: truffleColors.orange,\n  comment: truffleColors.comment,\n  doctag: truffleColors.comment,\n  operator: truffleColors.blue,\n  punctuation: truffleColors.purple,\n  /* classes it might soon use! */\n  meta: truffleColors.pink,\n  metaString: truffleColors.green,\n  \"meta-string\": truffleColors.green, //similar\n  /* classes it doesn't currently use but notionally could */\n  type: truffleColors.orange,\n  symbol: truffleColors.orange,\n  metaKeyword: truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint, //again, to be sure\n  property: chalk, //not putting any highlighting here for now\n  /* classes that don't make sense for Solidity */\n  regexp: chalk, //solidity does not have regexps\n  subst: chalk, //or string interpolation\n  name: chalk, //or s-expressions\n  builtInName: chalk, //or s-expressions, again\n  \"builtin-name\": chalk, //just to be sure\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  section: chalk,\n  tag: chalk,\n  attr: chalk,\n  attribute: chalk,\n  variable: chalk,\n  bullet: chalk,\n  code: chalk,\n  emphasis: chalk,\n  strong: chalk,\n  formula: chalk,\n  link: chalk,\n  quote: chalk,\n  selectorAttr: chalk, //lotta redundancy follows\n  \"selector-attr\": chalk,\n  selectorClass: chalk,\n  \"selector-class\": chalk,\n  selectorId: chalk,\n  \"selector-id\": chalk,\n  selectorPseudo: chalk,\n  \"selector-pseudo\": chalk,\n  selectorTag: chalk,\n  \"selector-tag\": chalk,\n  templateTag: chalk,\n  \"template-tag\": chalk,\n  templateVariable: chalk,\n  \"template-variable\": chalk,\n  addition: chalk,\n  deletion: chalk\n};\n\nvar DebugUtils = {\n  truffleColors, //make these externally available\n\n  //panicCode may be either a number or a BN\n  panicString: function (panicCode, verbose = false) {\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n    return verbose\n      ? verbosePanicTable[panicCode] || verboseUnknownString\n      : panicTable[panicCode] || unknownString;\n  },\n\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    }\n\n    //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    const lowestInternalIndex = Math.min(\n      ...compilation.contracts.map(contract => {\n        //find first defined index\n        let lowestConstructor = (contract.generatedSources || []).findIndex(\n          x => x !== undefined\n        );\n        if (lowestConstructor === -1) {\n          lowestConstructor = Infinity;\n        }\n        let lowestDeployed = (\n          contract.deployedGeneratedSources || []\n        ).findIndex(x => x !== undefined);\n        if (lowestDeployed === -1) {\n          lowestDeployed = Infinity;\n        }\n        return Math.min(lowestConstructor, lowestDeployed);\n      })\n    );\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    }\n\n    //check #4: are there any AST ID collisions?\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occured twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    };\n\n    //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(\n      source =>\n        !source ||\n        source.language !== \"Solidity\" ||\n        allIDsUnseenSoFar(source.ast)\n    );\n  },\n\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n\n  formatCommandDescription: function (commandId) {\n    return (\n      truffleColors.mint(`(${commandId})`) + \" \" + commandReference[commandId]\n    );\n  },\n\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined\n      ? `debug(${network}:${txHash.substring(0, 10)}...)> `\n      : `debug(${network})> `;\n  },\n\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(\n        `${chalk.bold(\n          \"Warning:\"\n        )} The source code for one or more contracts could not be found.`\n      );\n    }\n\n    return lines.join(OS.EOL);\n  },\n\n  formatHelp: function (lastCommand = \"n\") {\n    var prefix = [\n      \"Commands:\",\n      truffleColors.mint(\"(enter)\") +\n        \" last command entered (\" +\n        shortCommandReference[lastCommand] +\n        \")\"\n    ];\n\n    var commandSections = [\n      [\"o\", \"i\", \"u\", \"n\"],\n      [\"c\", \"Y\"],\n      [\"y\"],\n      [\";\"],\n      [\"g\", \"G\"],\n      [\"p\"],\n      [\"l\"],\n      [\"s\", \"h\"],\n      [\"q\", \"r\", \"t\", \"T\"],\n      [\"b\"],\n      [\"B\"],\n      [\"+\", \"-\"],\n      [\"?\"],\n      [\"v\"],\n      [\":\"]\n    ].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n\n    var suffix = [\"\"];\n\n    var lines = prefix.concat(commandSections).concat(suffix);\n\n    return lines.join(OS.EOL);\n  },\n\n  tabsToSpaces: function (inputLine, tabLength = DEFAULT_TAB_WIDTH) {\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n    return line;\n  },\n\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n\n    return prefix + line;\n  },\n\n  formatLinePointer: function (\n    line,\n    startCol,\n    endCol,\n    padding,\n    tabLength = DEFAULT_TAB_WIDTH\n  ) {\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n\n      let additional;\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n        counter++;\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (\n    source,\n    range,\n    uncolorizedSource,\n    contextBefore = 2,\n    contextAfter = 0\n  ) {\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n\n    //note: beforeLines now includes the line itself\n    var beforeLines = source\n      .slice(startIndex, range.start.line + 1)\n      .map((line, index) => {\n        let number = startIndex + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n    var afterLines = source\n      .slice(range.start.line + 1, endIndex + 1)\n      .map((line, index) => {\n        let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n      });\n\n    var pointerStart = range.start.column;\n    var pointerEnd;\n\n    let uncolorizedLine = uncolorizedSource[range.start.line];\n\n    // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat(\n      [\n        DebugUtils.formatLinePointer(\n          //the line-pointer formatter doesn't work right with colorized\n          //lines, so we pass in the uncolored version\n          uncolorizedLine,\n          pointerStart,\n          pointerEnd,\n          prefixLength\n        )\n      ],\n      afterLines\n    );\n\n    return allLines.join(OS.EOL);\n  },\n\n  formatBreakpointLocation: function (\n    breakpoint,\n    here,\n    currentSourceId,\n    sourceNames\n  ) {\n    let baseMessage;\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here\n        ? `this point in line ${breakpoint.line + 1}`\n        : `a point in line ${breakpoint.line + 1}`;\n      //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = `line ${breakpoint.line + 1}`;\n    }\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + ` in ${sourceName}`;\n    } else {\n      return baseMessage;\n    }\n  },\n\n  formatCurrentInstruction: function (instruction) {\n    const pc = this.formatPC(instruction.pc);\n    const formattedInstruction = this.formatInstruction(instruction);\n    return \"-> \" + truffleColors.mint(formattedInstruction) + pc;\n  },\n\n  formatInstruction: function (instruction) {\n    return truffleColors.mint(\n      instruction.name + \" \" + (instruction.pushData || \"\")\n    );\n  },\n\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n    return \" (PC=\" + pc.toString() + \", 0x\" + hex + \")\";\n  },\n\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += ` (${stack.length - index - 1} from top)`;\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(\n      2,\n      ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length\n    );\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE)\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      return `  0x${address}:  ${truffleColors.pink(word)}`;\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n\n    let formatted = slots.map((slot, index) => {\n      if (\n        index === 0 ||\n        !Codec.Conversion.toBN(slot).eq(\n          Codec.Conversion.toBN(slots[index - 1]).addn(1)\n        )\n      ) {\n        return `0x${slot}:\\n` + `  ${truffleColors.blue(storage[slot])}`;\n      } else {\n        return `  ${truffleColors.blue(storage[slot])}`;\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n    for (\n      let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE;\n      wordIndex < calldata.length;\n      wordIndex += Codec.Evm.Utils.WORD_SIZE\n    ) {\n      words.push(\n        calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE)\n      );\n    }\n    let maxWordIndex =\n      (words.length - 1) * Codec.Evm.Utils.WORD_SIZE +\n      Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n    let formattedSelector;\n    if (selector.length > 0) {\n      formattedSelector =\n        \"Calldata:\\n\" +\n        `  0x${\"00\".padStart(maxPrefixLength, \"0\")}:  ` +\n        truffleColors.pink(\n          Codec.Conversion.toHexString(selector)\n            .slice(2)\n            .padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \")\n        );\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (\n        index * Codec.Evm.Utils.WORD_SIZE +\n        Codec.Evm.Utils.SELECTOR_SIZE\n      )\n        .toString(16)\n        .padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word)\n        .slice(2)\n        .padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return `  0x${address}:  ${truffleColors.pink(data)}`;\n    });\n\n    formatted.unshift(formattedSelector);\n\n    return formatted.join(OS.EOL);\n  },\n\n  formatValue: function (value, indent = 0, nativized = false) {\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized\n      ? value\n      : new Codec.Format.Utils.Inspect.ResultInspector(value);\n    return util\n      .inspect(valueToInspect, inspectOptions)\n      .split(/\\r?\\n/g)\n      .map((line, i) => {\n        // don't indent first line\n        const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n        return padding + line;\n      })\n      .join(OS.EOL);\n  },\n\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding, indent = 0) {\n    const name = decoding.definedIn\n      ? `${decoding.definedIn.typeName}.${decoding.abi.name}`\n      : decoding.abi.name;\n    if (decoding.arguments.length === 0) {\n      return `${name}()`;\n    }\n    const prefix = `${name}(`;\n    const formattedValues = decoding.arguments.map(({ name, value }) => {\n      const argumentPrefix = name ? `${name}: ` : \"\";\n      const typeString = ` (type: ${Codec.Format.Types.typeStringWithoutLocation(\n        value.type\n      )})`;\n      return (\n        DebugUtils.formatValue(value, argumentPrefix.length) +\n        typeString +\n        \",\"\n      )\n        .split(/\\r?\\n/g)\n        .map(line => \" \".repeat(indent) + line)\n        .join(OS.EOL);\n    });\n    return [prefix, ...formattedValues, \")\"].join(OS.EOL);\n  },\n\n  formatStacktrace: function (stacktrace, indent = 2) {\n    //get message or panic code from stacktrace\n    const { message, panic, custom } = stacktrace[0];\n    //we want to print inner to outer, so first, let's\n    //reverse\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n    let lines = stacktrace.map(\n      ({ functionName, contractName, address, location, type }) => {\n        let name;\n        if (contractName && functionName) {\n          name = `${contractName}.${functionName}`;\n        } else if (contractName) {\n          name = contractName;\n        } else if (functionName) {\n          name = functionName;\n        } else {\n          name = \"unknown function\";\n        }\n        let locationString;\n        if (location) {\n          let {\n            source: { sourcePath },\n            sourceRange: {\n              lines: {\n                start: { line, column }\n              }\n            }\n          } = location;\n          locationString = sourcePath\n            ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing\n            : \"unknown location\";\n        } else {\n          locationString = \"unknown location\";\n        }\n        let addressString =\n          type === \"external\"\n            ? address !== undefined\n              ? ` [address ${address}]`\n              : \" [unknown address]\"\n            : \"\";\n        return `at ${name}${addressString} (${locationString})`;\n      }\n    );\n    let status = stacktrace[0].status;\n    if (status != undefined) {\n      let statusLine;\n      if (message !== undefined) {\n        statusLine = status\n          ? `Error: Improper return (caused message: ${message})`\n          : `Error: Revert (message: ${message})`;\n      } else if (panic !== undefined) {\n        statusLine = status\n          ? `Panic: Improper return (caused ${DebugUtils.panicString(\n              panic\n            ).toLowerCase()} (code 0x${panic.toString(16)}))`\n          : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(\n              16\n            )})`;\n      } else if (custom !== undefined) {\n        statusLine = status\n          ? `Error: Improper return (caused custom error)`\n          : `Error: Revert (custom error)`;\n      } else {\n        statusLine = status\n          ? \"Error: Improper return (may be an unexpected self-destruct)\"\n          : \"Error: Revert or exceptional halt\";\n      }\n      lines.unshift(statusLine);\n    }\n    let indented = lines.map((line, index) =>\n      index === 0 ? line : \" \".repeat(indent) + line\n    );\n    return indented.join(OS.EOL);\n  },\n\n  colorize: function (code, language = \"Solidity\") {\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false, //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false\n      //NOTE: you might think you should pass highlight: true,\n      //but you'd be wrong!  I don't understand this either\n    };\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n        return chromafi(code, options);\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n        return chromafi(code, options);\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign(\n      {},\n      ...Object.entries(variables).map(([variable, value]) =>\n        variable === \"this\" ? { [replacement]: value } : { [variable]: value }\n      )\n    );\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const { controller } = bugger.selectors;\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const { compilationId, id, internal } = source;\n      //stepInto should skip internal sources, but there still might be\n      //one at the end\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = {\n          ...sources[compilationId],\n          [id]: source\n        };\n      }\n      await bugger.stepInto();\n    }\n    await bugger.reset();\n    //flatten sources before returning\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\n\nmodule.exports = DebugUtils;\n"]},"metadata":{},"sourceType":"script"}