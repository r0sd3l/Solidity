{"ast":null,"code":"import { convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { CommandsIterable } from '../../check/model/commands/CommandsIterable.js';\nimport { CommandWrapper } from '../../check/model/commands/CommandWrapper.js';\nimport { ReplayPath } from '../../check/model/ReplayPath.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { oneof } from '../oneof.js';\nimport { restrictedIntegerArbitraryBuilder } from './builders/RestrictedIntegerArbitraryBuilder.js';\nexport class CommandsArbitrary extends NextArbitrary {\n  constructor(commandArbs, maxGeneratedCommands, maxCommands, sourceReplayPath, disableReplayLog) {\n    super();\n    this.sourceReplayPath = sourceReplayPath;\n    this.disableReplayLog = disableReplayLog;\n    this.oneCommandArb = convertToNext(oneof(...commandArbs).map(c => new CommandWrapper(c)));\n    this.lengthArb = convertToNext(restrictedIntegerArbitraryBuilder(0, maxGeneratedCommands, maxCommands));\n    this.replayPath = [];\n    this.replayPathPosition = 0;\n  }\n\n  metadataForReplay() {\n    return this.disableReplayLog ? '' : `replayPath=${JSON.stringify(ReplayPath.stringify(this.replayPath))}`;\n  }\n\n  buildNextValueFor(items, shrunkOnce) {\n    const commands = items.map(item => item.value_);\n    const context = {\n      shrunkOnce,\n      items\n    };\n    return new NextValue(new CommandsIterable(commands, () => this.metadataForReplay()), context);\n  }\n\n  generate(mrng) {\n    const size = this.lengthArb.generate(mrng, undefined);\n    const sizeValue = size.value;\n    const items = Array(sizeValue);\n\n    for (let idx = 0; idx !== sizeValue; ++idx) {\n      const item = this.oneCommandArb.generate(mrng, undefined);\n      items[idx] = item;\n    }\n\n    this.replayPathPosition = 0;\n    return this.buildNextValueFor(items, false);\n  }\n\n  canShrinkWithoutContext(value) {\n    return false;\n  }\n\n  filterOnExecution(itemsRaw) {\n    const items = [];\n\n    for (const c of itemsRaw) {\n      if (c.value_.hasRan) {\n        this.replayPath.push(true);\n        items.push(c);\n      } else this.replayPath.push(false);\n    }\n\n    return items;\n  }\n\n  filterOnReplay(itemsRaw) {\n    return itemsRaw.filter((c, idx) => {\n      const state = this.replayPath[this.replayPathPosition + idx];\n      if (state === undefined) throw new Error(`Too short replayPath`);\n      if (!state && c.value_.hasRan) throw new Error(`Mismatch between replayPath and real execution`);\n      return state;\n    });\n  }\n\n  filterForShrinkImpl(itemsRaw) {\n    if (this.replayPathPosition === 0) {\n      this.replayPath = this.sourceReplayPath !== null ? ReplayPath.parse(this.sourceReplayPath) : [];\n    }\n\n    const items = this.replayPathPosition < this.replayPath.length ? this.filterOnReplay(itemsRaw) : this.filterOnExecution(itemsRaw);\n    this.replayPathPosition += itemsRaw.length;\n    return items;\n  }\n\n  shrink(_value, context) {\n    if (context === undefined) {\n      return Stream.nil();\n    }\n\n    const safeContext = context;\n    const shrunkOnce = safeContext.shrunkOnce;\n    const itemsRaw = safeContext.items;\n    const items = this.filterForShrinkImpl(itemsRaw);\n\n    if (items.length === 0) {\n      return Stream.nil();\n    }\n\n    const rootShrink = shrunkOnce ? Stream.nil() : new Stream([[]][Symbol.iterator]());\n    const nextShrinks = [];\n\n    for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {\n      nextShrinks.push(makeLazy(() => {\n        const fixedStart = items.slice(0, numToKeep);\n        return this.lengthArb.shrink(items.length - 1 - numToKeep, undefined).map(l => fixedStart.concat(items.slice(items.length - (l.value + 1))));\n      }));\n    }\n\n    for (let itemAt = 0; itemAt !== items.length; ++itemAt) {\n      nextShrinks.push(makeLazy(() => this.oneCommandArb.shrink(items[itemAt].value_, items[itemAt].context).map(v => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));\n    }\n\n    return rootShrink.join(...nextShrinks).map(shrinkables => {\n      return this.buildNextValueFor(shrinkables.map(c => new NextValue(c.value_.clone(), c.context)), true);\n    });\n  }\n\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/CommandsArbitrary.js"],"names":["convertToNext","NextArbitrary","NextValue","CommandsIterable","CommandWrapper","ReplayPath","makeLazy","Stream","oneof","restrictedIntegerArbitraryBuilder","CommandsArbitrary","constructor","commandArbs","maxGeneratedCommands","maxCommands","sourceReplayPath","disableReplayLog","oneCommandArb","map","c","lengthArb","replayPath","replayPathPosition","metadataForReplay","JSON","stringify","buildNextValueFor","items","shrunkOnce","commands","item","value_","context","generate","mrng","size","undefined","sizeValue","value","Array","idx","canShrinkWithoutContext","filterOnExecution","itemsRaw","hasRan","push","filterOnReplay","filter","state","Error","filterForShrinkImpl","parse","length","shrink","_value","nil","safeContext","rootShrink","Symbol","iterator","nextShrinks","numToKeep","fixedStart","slice","l","concat","itemAt","v","join","shrinkables","clone"],"mappings":"AAAA,SAASA,aAAT,QAA8B,gDAA9B;AACA,SAASC,aAAT,QAA8B,mDAA9B;AACA,SAASC,SAAT,QAA0B,+CAA1B;AACA,SAASC,gBAAT,QAAiC,gDAAjC;AACA,SAASC,cAAT,QAA+B,8CAA/B;AACA,SAASC,UAAT,QAA2B,iCAA3B;AACA,SAASC,QAAT,QAAyB,sCAAzB;AACA,SAASC,MAAT,QAAuB,wBAAvB;AACA,SAASC,KAAT,QAAsB,aAAtB;AACA,SAASC,iCAAT,QAAkD,iDAAlD;AACA,OAAO,MAAMC,iBAAN,SAAgCT,aAAhC,CAA8C;AACjDU,EAAAA,WAAW,CAACC,WAAD,EAAcC,oBAAd,EAAoCC,WAApC,EAAiDC,gBAAjD,EAAmEC,gBAAnE,EAAqF;AAC5F;AACA,SAAKD,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,gBAAL,GAAwBA,gBAAxB;AACA,SAAKC,aAAL,GAAqBjB,aAAa,CAACQ,KAAK,CAAC,GAAGI,WAAJ,CAAL,CAAsBM,GAAtB,CAA2BC,CAAD,IAAO,IAAIf,cAAJ,CAAmBe,CAAnB,CAAjC,CAAD,CAAlC;AACA,SAAKC,SAAL,GAAiBpB,aAAa,CAACS,iCAAiC,CAAC,CAAD,EAAII,oBAAJ,EAA0BC,WAA1B,CAAlC,CAA9B;AACA,SAAKO,UAAL,GAAkB,EAAlB;AACA,SAAKC,kBAAL,GAA0B,CAA1B;AACH;;AACDC,EAAAA,iBAAiB,GAAG;AAChB,WAAO,KAAKP,gBAAL,GAAwB,EAAxB,GAA8B,cAAaQ,IAAI,CAACC,SAAL,CAAepB,UAAU,CAACoB,SAAX,CAAqB,KAAKJ,UAA1B,CAAf,CAAsD,EAAxG;AACH;;AACDK,EAAAA,iBAAiB,CAACC,KAAD,EAAQC,UAAR,EAAoB;AACjC,UAAMC,QAAQ,GAAGF,KAAK,CAACT,GAAN,CAAWY,IAAD,IAAUA,IAAI,CAACC,MAAzB,CAAjB;AACA,UAAMC,OAAO,GAAG;AAAEJ,MAAAA,UAAF;AAAcD,MAAAA;AAAd,KAAhB;AACA,WAAO,IAAIzB,SAAJ,CAAc,IAAIC,gBAAJ,CAAqB0B,QAArB,EAA+B,MAAM,KAAKN,iBAAL,EAArC,CAAd,EAA8ES,OAA9E,CAAP;AACH;;AACDC,EAAAA,QAAQ,CAACC,IAAD,EAAO;AACX,UAAMC,IAAI,GAAG,KAAKf,SAAL,CAAea,QAAf,CAAwBC,IAAxB,EAA8BE,SAA9B,CAAb;AACA,UAAMC,SAAS,GAAGF,IAAI,CAACG,KAAvB;AACA,UAAMX,KAAK,GAAGY,KAAK,CAACF,SAAD,CAAnB;;AACA,SAAK,IAAIG,GAAG,GAAG,CAAf,EAAkBA,GAAG,KAAKH,SAA1B,EAAqC,EAAEG,GAAvC,EAA4C;AACxC,YAAMV,IAAI,GAAG,KAAKb,aAAL,CAAmBgB,QAAnB,CAA4BC,IAA5B,EAAkCE,SAAlC,CAAb;AACAT,MAAAA,KAAK,CAACa,GAAD,CAAL,GAAaV,IAAb;AACH;;AACD,SAAKR,kBAAL,GAA0B,CAA1B;AACA,WAAO,KAAKI,iBAAL,CAAuBC,KAAvB,EAA8B,KAA9B,CAAP;AACH;;AACDc,EAAAA,uBAAuB,CAACH,KAAD,EAAQ;AAC3B,WAAO,KAAP;AACH;;AACDI,EAAAA,iBAAiB,CAACC,QAAD,EAAW;AACxB,UAAMhB,KAAK,GAAG,EAAd;;AACA,SAAK,MAAMR,CAAX,IAAgBwB,QAAhB,EAA0B;AACtB,UAAIxB,CAAC,CAACY,MAAF,CAASa,MAAb,EAAqB;AACjB,aAAKvB,UAAL,CAAgBwB,IAAhB,CAAqB,IAArB;AACAlB,QAAAA,KAAK,CAACkB,IAAN,CAAW1B,CAAX;AACH,OAHD,MAKI,KAAKE,UAAL,CAAgBwB,IAAhB,CAAqB,KAArB;AACP;;AACD,WAAOlB,KAAP;AACH;;AACDmB,EAAAA,cAAc,CAACH,QAAD,EAAW;AACrB,WAAOA,QAAQ,CAACI,MAAT,CAAgB,CAAC5B,CAAD,EAAIqB,GAAJ,KAAY;AAC/B,YAAMQ,KAAK,GAAG,KAAK3B,UAAL,CAAgB,KAAKC,kBAAL,GAA0BkB,GAA1C,CAAd;AACA,UAAIQ,KAAK,KAAKZ,SAAd,EACI,MAAM,IAAIa,KAAJ,CAAW,sBAAX,CAAN;AACJ,UAAI,CAACD,KAAD,IAAU7B,CAAC,CAACY,MAAF,CAASa,MAAvB,EACI,MAAM,IAAIK,KAAJ,CAAW,gDAAX,CAAN;AACJ,aAAOD,KAAP;AACH,KAPM,CAAP;AAQH;;AACDE,EAAAA,mBAAmB,CAACP,QAAD,EAAW;AAC1B,QAAI,KAAKrB,kBAAL,KAA4B,CAAhC,EAAmC;AAC/B,WAAKD,UAAL,GAAkB,KAAKN,gBAAL,KAA0B,IAA1B,GAAiCV,UAAU,CAAC8C,KAAX,CAAiB,KAAKpC,gBAAtB,CAAjC,GAA2E,EAA7F;AACH;;AACD,UAAMY,KAAK,GAAG,KAAKL,kBAAL,GAA0B,KAAKD,UAAL,CAAgB+B,MAA1C,GACR,KAAKN,cAAL,CAAoBH,QAApB,CADQ,GAER,KAAKD,iBAAL,CAAuBC,QAAvB,CAFN;AAGA,SAAKrB,kBAAL,IAA2BqB,QAAQ,CAACS,MAApC;AACA,WAAOzB,KAAP;AACH;;AACD0B,EAAAA,MAAM,CAACC,MAAD,EAAStB,OAAT,EAAkB;AACpB,QAAIA,OAAO,KAAKI,SAAhB,EAA2B;AACvB,aAAO7B,MAAM,CAACgD,GAAP,EAAP;AACH;;AACD,UAAMC,WAAW,GAAGxB,OAApB;AACA,UAAMJ,UAAU,GAAG4B,WAAW,CAAC5B,UAA/B;AACA,UAAMe,QAAQ,GAAGa,WAAW,CAAC7B,KAA7B;AACA,UAAMA,KAAK,GAAG,KAAKuB,mBAAL,CAAyBP,QAAzB,CAAd;;AACA,QAAIhB,KAAK,CAACyB,MAAN,KAAiB,CAArB,EAAwB;AACpB,aAAO7C,MAAM,CAACgD,GAAP,EAAP;AACH;;AACD,UAAME,UAAU,GAAG7B,UAAU,GACvBrB,MAAM,CAACgD,GAAP,EADuB,GAEvB,IAAIhD,MAAJ,CAAW,CAAC,EAAD,EAAKmD,MAAM,CAACC,QAAZ,GAAX,CAFN;AAGA,UAAMC,WAAW,GAAG,EAApB;;AACA,SAAK,IAAIC,SAAS,GAAG,CAArB,EAAwBA,SAAS,KAAKlC,KAAK,CAACyB,MAA5C,EAAoD,EAAES,SAAtD,EAAiE;AAC7DD,MAAAA,WAAW,CAACf,IAAZ,CAAiBvC,QAAQ,CAAC,MAAM;AAC5B,cAAMwD,UAAU,GAAGnC,KAAK,CAACoC,KAAN,CAAY,CAAZ,EAAeF,SAAf,CAAnB;AACA,eAAO,KAAKzC,SAAL,CACFiC,MADE,CACK1B,KAAK,CAACyB,MAAN,GAAe,CAAf,GAAmBS,SADxB,EACmCzB,SADnC,EAEFlB,GAFE,CAEG8C,CAAD,IAAOF,UAAU,CAACG,MAAX,CAAkBtC,KAAK,CAACoC,KAAN,CAAYpC,KAAK,CAACyB,MAAN,IAAgBY,CAAC,CAAC1B,KAAF,GAAU,CAA1B,CAAZ,CAAlB,CAFT,CAAP;AAGH,OALwB,CAAzB;AAMH;;AACD,SAAK,IAAI4B,MAAM,GAAG,CAAlB,EAAqBA,MAAM,KAAKvC,KAAK,CAACyB,MAAtC,EAA8C,EAAEc,MAAhD,EAAwD;AACpDN,MAAAA,WAAW,CAACf,IAAZ,CAAiBvC,QAAQ,CAAC,MAAM,KAAKW,aAAL,CAC3BoC,MAD2B,CACpB1B,KAAK,CAACuC,MAAD,CAAL,CAAcnC,MADM,EACEJ,KAAK,CAACuC,MAAD,CAAL,CAAclC,OADhB,EAE3Bd,GAF2B,CAEtBiD,CAAD,IAAOxC,KAAK,CAACoC,KAAN,CAAY,CAAZ,EAAeG,MAAf,EAAuBD,MAAvB,CAA8B,CAACE,CAAD,CAA9B,EAAmCxC,KAAK,CAACoC,KAAN,CAAYG,MAAM,GAAG,CAArB,CAAnC,CAFgB,CAAP,CAAzB;AAGH;;AACD,WAAOT,UAAU,CAACW,IAAX,CAAgB,GAAGR,WAAnB,EAAgC1C,GAAhC,CAAqCmD,WAAD,IAAiB;AACxD,aAAO,KAAK3C,iBAAL,CAAuB2C,WAAW,CAACnD,GAAZ,CAAiBC,CAAD,IAAO,IAAIjB,SAAJ,CAAciB,CAAC,CAACY,MAAF,CAASuC,KAAT,EAAd,EAAgCnD,CAAC,CAACa,OAAlC,CAAvB,CAAvB,EAA2F,IAA3F,CAAP;AACH,KAFM,CAAP;AAGH;;AA/FgD","sourcesContent":["import { convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { CommandsIterable } from '../../check/model/commands/CommandsIterable.js';\nimport { CommandWrapper } from '../../check/model/commands/CommandWrapper.js';\nimport { ReplayPath } from '../../check/model/ReplayPath.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { oneof } from '../oneof.js';\nimport { restrictedIntegerArbitraryBuilder } from './builders/RestrictedIntegerArbitraryBuilder.js';\nexport class CommandsArbitrary extends NextArbitrary {\n    constructor(commandArbs, maxGeneratedCommands, maxCommands, sourceReplayPath, disableReplayLog) {\n        super();\n        this.sourceReplayPath = sourceReplayPath;\n        this.disableReplayLog = disableReplayLog;\n        this.oneCommandArb = convertToNext(oneof(...commandArbs).map((c) => new CommandWrapper(c)));\n        this.lengthArb = convertToNext(restrictedIntegerArbitraryBuilder(0, maxGeneratedCommands, maxCommands));\n        this.replayPath = [];\n        this.replayPathPosition = 0;\n    }\n    metadataForReplay() {\n        return this.disableReplayLog ? '' : `replayPath=${JSON.stringify(ReplayPath.stringify(this.replayPath))}`;\n    }\n    buildNextValueFor(items, shrunkOnce) {\n        const commands = items.map((item) => item.value_);\n        const context = { shrunkOnce, items };\n        return new NextValue(new CommandsIterable(commands, () => this.metadataForReplay()), context);\n    }\n    generate(mrng) {\n        const size = this.lengthArb.generate(mrng, undefined);\n        const sizeValue = size.value;\n        const items = Array(sizeValue);\n        for (let idx = 0; idx !== sizeValue; ++idx) {\n            const item = this.oneCommandArb.generate(mrng, undefined);\n            items[idx] = item;\n        }\n        this.replayPathPosition = 0;\n        return this.buildNextValueFor(items, false);\n    }\n    canShrinkWithoutContext(value) {\n        return false;\n    }\n    filterOnExecution(itemsRaw) {\n        const items = [];\n        for (const c of itemsRaw) {\n            if (c.value_.hasRan) {\n                this.replayPath.push(true);\n                items.push(c);\n            }\n            else\n                this.replayPath.push(false);\n        }\n        return items;\n    }\n    filterOnReplay(itemsRaw) {\n        return itemsRaw.filter((c, idx) => {\n            const state = this.replayPath[this.replayPathPosition + idx];\n            if (state === undefined)\n                throw new Error(`Too short replayPath`);\n            if (!state && c.value_.hasRan)\n                throw new Error(`Mismatch between replayPath and real execution`);\n            return state;\n        });\n    }\n    filterForShrinkImpl(itemsRaw) {\n        if (this.replayPathPosition === 0) {\n            this.replayPath = this.sourceReplayPath !== null ? ReplayPath.parse(this.sourceReplayPath) : [];\n        }\n        const items = this.replayPathPosition < this.replayPath.length\n            ? this.filterOnReplay(itemsRaw)\n            : this.filterOnExecution(itemsRaw);\n        this.replayPathPosition += itemsRaw.length;\n        return items;\n    }\n    shrink(_value, context) {\n        if (context === undefined) {\n            return Stream.nil();\n        }\n        const safeContext = context;\n        const shrunkOnce = safeContext.shrunkOnce;\n        const itemsRaw = safeContext.items;\n        const items = this.filterForShrinkImpl(itemsRaw);\n        if (items.length === 0) {\n            return Stream.nil();\n        }\n        const rootShrink = shrunkOnce\n            ? Stream.nil()\n            : new Stream([[]][Symbol.iterator]());\n        const nextShrinks = [];\n        for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {\n            nextShrinks.push(makeLazy(() => {\n                const fixedStart = items.slice(0, numToKeep);\n                return this.lengthArb\n                    .shrink(items.length - 1 - numToKeep, undefined)\n                    .map((l) => fixedStart.concat(items.slice(items.length - (l.value + 1))));\n            }));\n        }\n        for (let itemAt = 0; itemAt !== items.length; ++itemAt) {\n            nextShrinks.push(makeLazy(() => this.oneCommandArb\n                .shrink(items[itemAt].value_, items[itemAt].context)\n                .map((v) => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));\n        }\n        return rootShrink.join(...nextShrinks).map((shrinkables) => {\n            return this.buildNextValueFor(shrinkables.map((c) => new NextValue(c.value_.clone(), c.context)), true);\n        });\n    }\n}\n"]},"metadata":{},"sourceType":"module"}