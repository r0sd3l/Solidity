{"ast":null,"code":"import { Stream } from '../../stream/Stream.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { getDepthContextFor } from './helpers/DepthContext.js';\nexport class FrequencyArbitrary extends NextArbitrary {\n  constructor(warbs, constraints, context) {\n    super();\n    this.warbs = warbs;\n    this.constraints = constraints;\n    this.context = context;\n    let currentWeight = 0;\n    this.cumulatedWeights = [];\n\n    for (let idx = 0; idx !== warbs.length; ++idx) {\n      currentWeight += warbs[idx].weight;\n      this.cumulatedWeights.push(currentWeight);\n    }\n\n    this.totalWeight = currentWeight;\n  }\n\n  static fromOld(warbs, constraints, label) {\n    return convertFromNext(FrequencyArbitrary.from(warbs.map(w => Object.assign(Object.assign({}, w), {\n      arbitrary: convertToNext(w.arbitrary)\n    })), constraints, label));\n  }\n\n  static from(warbs, constraints, label) {\n    if (warbs.length === 0) {\n      throw new Error(`${label} expects at least one weighted arbitrary`);\n    }\n\n    let totalWeight = 0;\n\n    for (let idx = 0; idx !== warbs.length; ++idx) {\n      const currentArbitrary = warbs[idx].arbitrary;\n\n      if (currentArbitrary === undefined) {\n        throw new Error(`${label} expects arbitraries to be specified`);\n      }\n\n      const currentWeight = warbs[idx].weight;\n      totalWeight += currentWeight;\n\n      if (!Number.isInteger(currentWeight)) {\n        throw new Error(`${label} expects weights to be integer values`);\n      }\n\n      if (currentWeight < 0) {\n        throw new Error(`${label} expects weights to be superior or equal to 0`);\n      }\n    }\n\n    if (totalWeight <= 0) {\n      throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);\n    }\n\n    return new FrequencyArbitrary(warbs, constraints, getDepthContextFor(constraints.depthIdentifier));\n  }\n\n  generate(mrng, biasFactor) {\n    if (this.mustGenerateFirst()) {\n      return this.safeGenerateForIndex(mrng, 0, biasFactor);\n    }\n\n    const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);\n\n    for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {\n      if (selected < this.cumulatedWeights[idx]) {\n        return this.safeGenerateForIndex(mrng, idx, biasFactor);\n      }\n    }\n\n    throw new Error(`Unable to generate from fc.frequency`);\n  }\n\n  canShrinkWithoutContext(value) {\n    return this.canShrinkWithoutContextIndex(value) !== -1;\n  }\n\n  shrink(value, context) {\n    if (context !== undefined) {\n      const safeContext = context;\n      const selectedIndex = safeContext.selectedIndex;\n      const originalBias = safeContext.originalBias;\n      const originalArbitrary = this.warbs[selectedIndex].arbitrary;\n      const originalShrinks = originalArbitrary.shrink(value, safeContext.originalContext).map(v => this.mapIntoNextValue(selectedIndex, v, null, originalBias));\n\n      if (safeContext.clonedMrngForFallbackFirst !== null) {\n        if (safeContext.cachedGeneratedForFirst === undefined) {\n          safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);\n        }\n\n        const valueFromFirst = safeContext.cachedGeneratedForFirst;\n        return Stream.of(valueFromFirst).join(originalShrinks);\n      }\n\n      return originalShrinks;\n    }\n\n    const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);\n\n    if (potentialSelectedIndex === -1) {\n      return Stream.nil();\n    }\n\n    return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary.shrink(value, undefined).map(v => this.mapIntoNextValue(potentialSelectedIndex, v, null, undefined)));\n  }\n\n  defaultShrinkForFirst(selectedIndex) {\n    ++this.context.depth;\n\n    try {\n      if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {\n        return Stream.nil();\n      }\n    } finally {\n      --this.context.depth;\n    }\n\n    const rawShrinkValue = new NextValue(this.warbs[0].fallbackValue.default, undefined);\n    return Stream.of(this.mapIntoNextValue(0, rawShrinkValue, null, undefined));\n  }\n\n  canShrinkWithoutContextIndex(value) {\n    if (this.mustGenerateFirst()) {\n      return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;\n    }\n\n    try {\n      ++this.context.depth;\n\n      for (let idx = 0; idx !== this.warbs.length; ++idx) {\n        const warb = this.warbs[idx];\n\n        if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {\n          return idx;\n        }\n      }\n\n      return -1;\n    } finally {\n      --this.context.depth;\n    }\n  }\n\n  mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {\n    const context = {\n      selectedIndex: idx,\n      originalBias: biasFactor,\n      originalContext: value.context,\n      clonedMrngForFallbackFirst\n    };\n    return new NextValue(value.value, context);\n  }\n\n  safeGenerateForIndex(mrng, idx, biasFactor) {\n    ++this.context.depth;\n\n    try {\n      const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);\n      const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;\n      return this.mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor);\n    } finally {\n      --this.context.depth;\n    }\n  }\n\n  mustGenerateFirst() {\n    return this.constraints.maxDepth !== undefined && this.constraints.maxDepth <= this.context.depth;\n  }\n\n  mustFallbackToFirstInShrink(idx) {\n    return idx !== 0 && !!this.constraints.withCrossShrink && this.warbs[0].weight !== 0;\n  }\n\n  computeNegDepthBenefit() {\n    const depthFactor = this.constraints.depthFactor;\n\n    if (depthFactor === undefined || depthFactor <= 0) {\n      return 0;\n    }\n\n    const depthBenefit = Math.floor(Math.pow(1 + depthFactor, this.context.depth)) - 1;\n    return -Math.min(this.warbs[0].weight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js"],"names":["Stream","convertFromNext","convertToNext","NextArbitrary","NextValue","getDepthContextFor","FrequencyArbitrary","constructor","warbs","constraints","context","currentWeight","cumulatedWeights","idx","length","weight","push","totalWeight","fromOld","label","from","map","w","Object","assign","arbitrary","Error","currentArbitrary","undefined","Number","isInteger","depthIdentifier","generate","mrng","biasFactor","mustGenerateFirst","safeGenerateForIndex","selected","nextInt","computeNegDepthBenefit","canShrinkWithoutContext","value","canShrinkWithoutContextIndex","shrink","safeContext","selectedIndex","originalBias","originalArbitrary","originalShrinks","originalContext","v","mapIntoNextValue","clonedMrngForFallbackFirst","cachedGeneratedForFirst","valueFromFirst","of","join","potentialSelectedIndex","nil","defaultShrinkForFirst","depth","mustFallbackToFirstInShrink","fallbackValue","rawShrinkValue","default","warb","clone","maxDepth","withCrossShrink","depthFactor","depthBenefit","Math","floor","pow","min","MAX_SAFE_INTEGER"],"mappings":"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","sourcesContent":["import { Stream } from '../../stream/Stream.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { getDepthContextFor } from './helpers/DepthContext.js';\nexport class FrequencyArbitrary extends NextArbitrary {\n    constructor(warbs, constraints, context) {\n        super();\n        this.warbs = warbs;\n        this.constraints = constraints;\n        this.context = context;\n        let currentWeight = 0;\n        this.cumulatedWeights = [];\n        for (let idx = 0; idx !== warbs.length; ++idx) {\n            currentWeight += warbs[idx].weight;\n            this.cumulatedWeights.push(currentWeight);\n        }\n        this.totalWeight = currentWeight;\n    }\n    static fromOld(warbs, constraints, label) {\n        return convertFromNext(FrequencyArbitrary.from(warbs.map((w) => (Object.assign(Object.assign({}, w), { arbitrary: convertToNext(w.arbitrary) }))), constraints, label));\n    }\n    static from(warbs, constraints, label) {\n        if (warbs.length === 0) {\n            throw new Error(`${label} expects at least one weighted arbitrary`);\n        }\n        let totalWeight = 0;\n        for (let idx = 0; idx !== warbs.length; ++idx) {\n            const currentArbitrary = warbs[idx].arbitrary;\n            if (currentArbitrary === undefined) {\n                throw new Error(`${label} expects arbitraries to be specified`);\n            }\n            const currentWeight = warbs[idx].weight;\n            totalWeight += currentWeight;\n            if (!Number.isInteger(currentWeight)) {\n                throw new Error(`${label} expects weights to be integer values`);\n            }\n            if (currentWeight < 0) {\n                throw new Error(`${label} expects weights to be superior or equal to 0`);\n            }\n        }\n        if (totalWeight <= 0) {\n            throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);\n        }\n        return new FrequencyArbitrary(warbs, constraints, getDepthContextFor(constraints.depthIdentifier));\n    }\n    generate(mrng, biasFactor) {\n        if (this.mustGenerateFirst()) {\n            return this.safeGenerateForIndex(mrng, 0, biasFactor);\n        }\n        const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);\n        for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {\n            if (selected < this.cumulatedWeights[idx]) {\n                return this.safeGenerateForIndex(mrng, idx, biasFactor);\n            }\n        }\n        throw new Error(`Unable to generate from fc.frequency`);\n    }\n    canShrinkWithoutContext(value) {\n        return this.canShrinkWithoutContextIndex(value) !== -1;\n    }\n    shrink(value, context) {\n        if (context !== undefined) {\n            const safeContext = context;\n            const selectedIndex = safeContext.selectedIndex;\n            const originalBias = safeContext.originalBias;\n            const originalArbitrary = this.warbs[selectedIndex].arbitrary;\n            const originalShrinks = originalArbitrary\n                .shrink(value, safeContext.originalContext)\n                .map((v) => this.mapIntoNextValue(selectedIndex, v, null, originalBias));\n            if (safeContext.clonedMrngForFallbackFirst !== null) {\n                if (safeContext.cachedGeneratedForFirst === undefined) {\n                    safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);\n                }\n                const valueFromFirst = safeContext.cachedGeneratedForFirst;\n                return Stream.of(valueFromFirst).join(originalShrinks);\n            }\n            return originalShrinks;\n        }\n        const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);\n        if (potentialSelectedIndex === -1) {\n            return Stream.nil();\n        }\n        return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary\n            .shrink(value, undefined)\n            .map((v) => this.mapIntoNextValue(potentialSelectedIndex, v, null, undefined)));\n    }\n    defaultShrinkForFirst(selectedIndex) {\n        ++this.context.depth;\n        try {\n            if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {\n                return Stream.nil();\n            }\n        }\n        finally {\n            --this.context.depth;\n        }\n        const rawShrinkValue = new NextValue(this.warbs[0].fallbackValue.default, undefined);\n        return Stream.of(this.mapIntoNextValue(0, rawShrinkValue, null, undefined));\n    }\n    canShrinkWithoutContextIndex(value) {\n        if (this.mustGenerateFirst()) {\n            return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;\n        }\n        try {\n            ++this.context.depth;\n            for (let idx = 0; idx !== this.warbs.length; ++idx) {\n                const warb = this.warbs[idx];\n                if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {\n                    return idx;\n                }\n            }\n            return -1;\n        }\n        finally {\n            --this.context.depth;\n        }\n    }\n    mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {\n        const context = {\n            selectedIndex: idx,\n            originalBias: biasFactor,\n            originalContext: value.context,\n            clonedMrngForFallbackFirst,\n        };\n        return new NextValue(value.value, context);\n    }\n    safeGenerateForIndex(mrng, idx, biasFactor) {\n        ++this.context.depth;\n        try {\n            const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);\n            const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;\n            return this.mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor);\n        }\n        finally {\n            --this.context.depth;\n        }\n    }\n    mustGenerateFirst() {\n        return this.constraints.maxDepth !== undefined && this.constraints.maxDepth <= this.context.depth;\n    }\n    mustFallbackToFirstInShrink(idx) {\n        return idx !== 0 && !!this.constraints.withCrossShrink && this.warbs[0].weight !== 0;\n    }\n    computeNegDepthBenefit() {\n        const depthFactor = this.constraints.depthFactor;\n        if (depthFactor === undefined || depthFactor <= 0) {\n            return 0;\n        }\n        const depthBenefit = Math.floor(Math.pow(1 + depthFactor, this.context.depth)) - 1;\n        return -Math.min(this.warbs[0].weight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}