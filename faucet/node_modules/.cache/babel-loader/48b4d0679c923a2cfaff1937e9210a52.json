{"ast":null,"code":"import { escapeForTemplateString } from '../helpers/TextEscaper.js';\nimport { cloneMethod } from '../../../check/symbols.js';\nimport { stringify } from '../../../utils/stringify.js';\nexport class SchedulerImplem {\n  constructor(act, taskSelector) {\n    this.act = act;\n    this.taskSelector = taskSelector;\n    this.lastTaskId = 0;\n    this.sourceTaskSelector = taskSelector.clone();\n    this.scheduledTasks = [];\n    this.triggeredTasks = [];\n  }\n\n  static buildLog(reportItem) {\n    return `[task\\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== undefined ? ` with value ${escapeForTemplateString(reportItem.outputValue)}` : ''}`;\n  }\n\n  log(schedulingType, taskId, label, metadata, status, data) {\n    this.triggeredTasks.push({\n      status,\n      schedulingType,\n      taskId,\n      label,\n      metadata,\n      outputValue: data !== undefined ? stringify(data) : undefined\n    });\n  }\n\n  scheduleInternal(schedulingType, label, task, metadata, thenTaskToBeAwaited) {\n    let trigger = null;\n    const taskId = ++this.lastTaskId;\n    const scheduledPromise = new Promise((resolve, reject) => {\n      trigger = () => {\n        (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then(data => {\n          this.log(schedulingType, taskId, label, metadata, 'resolved', data);\n          return resolve(data);\n        }, err => {\n          this.log(schedulingType, taskId, label, metadata, 'rejected', err);\n          return reject(err);\n        });\n      };\n    });\n    this.scheduledTasks.push({\n      original: task,\n      scheduled: scheduledPromise,\n      trigger: trigger,\n      schedulingType,\n      taskId,\n      label,\n      metadata\n    });\n    return scheduledPromise;\n  }\n\n  schedule(task, label, metadata) {\n    return this.scheduleInternal('promise', label || '', task, metadata);\n  }\n\n  scheduleFunction(asyncFunction) {\n    var _this = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _this.scheduleInternal('function', `${asyncFunction.name}(${args.map(stringify).join(',')})`, asyncFunction(...args), undefined);\n    };\n  }\n\n  scheduleSequence(sequenceBuilders) {\n    const status = {\n      done: false,\n      faulty: false\n    };\n    const dummyResolvedPromise = {\n      then: f => f()\n    };\n\n    let resolveSequenceTask = () => {};\n\n    const sequenceTask = new Promise(resolve => resolveSequenceTask = resolve);\n    sequenceBuilders.reduce((previouslyScheduled, item) => {\n      const [builder, label, metadata] = typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata];\n      return previouslyScheduled.then(() => {\n        const scheduled = this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, () => builder());\n        scheduled.catch(() => {\n          status.faulty = true;\n          resolveSequenceTask();\n        });\n        return scheduled;\n      });\n    }, dummyResolvedPromise).then(() => {\n      status.done = true;\n      resolveSequenceTask();\n    }, () => {});\n    return Object.assign(status, {\n      task: Promise.resolve(sequenceTask).then(() => {\n        return {\n          done: status.done,\n          faulty: status.faulty\n        };\n      })\n    });\n  }\n\n  count() {\n    return this.scheduledTasks.length;\n  }\n\n  async internalWaitOne() {\n    if (this.scheduledTasks.length === 0) {\n      throw new Error('No task scheduled');\n    }\n\n    const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);\n    const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);\n    scheduledTask.trigger();\n\n    try {\n      await scheduledTask.scheduled;\n    } catch (_err) {}\n  }\n\n  async waitOne() {\n    await this.act(async () => await this.internalWaitOne());\n  }\n\n  async waitAll() {\n    while (this.scheduledTasks.length > 0) {\n      await this.waitOne();\n    }\n  }\n\n  report() {\n    return [...this.triggeredTasks, ...this.scheduledTasks.map(t => ({\n      status: 'pending',\n      schedulingType: t.schedulingType,\n      taskId: t.taskId,\n      label: t.label,\n      metadata: t.metadata\n    }))];\n  }\n\n  toString() {\n    return 'schedulerFor()`\\n' + this.report().map(SchedulerImplem.buildLog).map(log => `-> ${log}`).join('\\n') + '`';\n  }\n\n  [cloneMethod]() {\n    return new SchedulerImplem(this.act, this.sourceTaskSelector);\n  }\n\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SchedulerImplem.js"],"names":["escapeForTemplateString","cloneMethod","stringify","SchedulerImplem","constructor","act","taskSelector","lastTaskId","sourceTaskSelector","clone","scheduledTasks","triggeredTasks","buildLog","reportItem","taskId","label","length","schedulingType","status","outputValue","undefined","log","metadata","data","push","scheduleInternal","task","thenTaskToBeAwaited","trigger","scheduledPromise","Promise","resolve","reject","then","err","original","scheduled","schedule","scheduleFunction","asyncFunction","args","name","map","join","scheduleSequence","sequenceBuilders","done","faulty","dummyResolvedPromise","f","resolveSequenceTask","sequenceTask","reduce","previouslyScheduled","item","builder","catch","Object","assign","count","internalWaitOne","Error","taskIndex","nextTaskIndex","scheduledTask","splice","_err","waitOne","waitAll","report","t","toString"],"mappings":"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","sourcesContent":["import { escapeForTemplateString } from '../helpers/TextEscaper.js';\nimport { cloneMethod } from '../../../check/symbols.js';\nimport { stringify } from '../../../utils/stringify.js';\nexport class SchedulerImplem {\n    constructor(act, taskSelector) {\n        this.act = act;\n        this.taskSelector = taskSelector;\n        this.lastTaskId = 0;\n        this.sourceTaskSelector = taskSelector.clone();\n        this.scheduledTasks = [];\n        this.triggeredTasks = [];\n    }\n    static buildLog(reportItem) {\n        return `[task\\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== undefined ? ` with value ${escapeForTemplateString(reportItem.outputValue)}` : ''}`;\n    }\n    log(schedulingType, taskId, label, metadata, status, data) {\n        this.triggeredTasks.push({\n            status,\n            schedulingType,\n            taskId,\n            label,\n            metadata,\n            outputValue: data !== undefined ? stringify(data) : undefined,\n        });\n    }\n    scheduleInternal(schedulingType, label, task, metadata, thenTaskToBeAwaited) {\n        let trigger = null;\n        const taskId = ++this.lastTaskId;\n        const scheduledPromise = new Promise((resolve, reject) => {\n            trigger = () => {\n                (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {\n                    this.log(schedulingType, taskId, label, metadata, 'resolved', data);\n                    return resolve(data);\n                }, (err) => {\n                    this.log(schedulingType, taskId, label, metadata, 'rejected', err);\n                    return reject(err);\n                });\n            };\n        });\n        this.scheduledTasks.push({\n            original: task,\n            scheduled: scheduledPromise,\n            trigger: trigger,\n            schedulingType,\n            taskId,\n            label,\n            metadata,\n        });\n        return scheduledPromise;\n    }\n    schedule(task, label, metadata) {\n        return this.scheduleInternal('promise', label || '', task, metadata);\n    }\n    scheduleFunction(asyncFunction) {\n        return (...args) => this.scheduleInternal('function', `${asyncFunction.name}(${args.map(stringify).join(',')})`, asyncFunction(...args), undefined);\n    }\n    scheduleSequence(sequenceBuilders) {\n        const status = { done: false, faulty: false };\n        const dummyResolvedPromise = { then: (f) => f() };\n        let resolveSequenceTask = () => { };\n        const sequenceTask = new Promise((resolve) => (resolveSequenceTask = resolve));\n        sequenceBuilders\n            .reduce((previouslyScheduled, item) => {\n            const [builder, label, metadata] = typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata];\n            return previouslyScheduled.then(() => {\n                const scheduled = this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, () => builder());\n                scheduled.catch(() => {\n                    status.faulty = true;\n                    resolveSequenceTask();\n                });\n                return scheduled;\n            });\n        }, dummyResolvedPromise)\n            .then(() => {\n            status.done = true;\n            resolveSequenceTask();\n        }, () => {\n        });\n        return Object.assign(status, {\n            task: Promise.resolve(sequenceTask).then(() => {\n                return { done: status.done, faulty: status.faulty };\n            }),\n        });\n    }\n    count() {\n        return this.scheduledTasks.length;\n    }\n    async internalWaitOne() {\n        if (this.scheduledTasks.length === 0) {\n            throw new Error('No task scheduled');\n        }\n        const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);\n        const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);\n        scheduledTask.trigger();\n        try {\n            await scheduledTask.scheduled;\n        }\n        catch (_err) {\n        }\n    }\n    async waitOne() {\n        await this.act(async () => await this.internalWaitOne());\n    }\n    async waitAll() {\n        while (this.scheduledTasks.length > 0) {\n            await this.waitOne();\n        }\n    }\n    report() {\n        return [\n            ...this.triggeredTasks,\n            ...this.scheduledTasks.map((t) => ({\n                status: 'pending',\n                schedulingType: t.schedulingType,\n                taskId: t.taskId,\n                label: t.label,\n                metadata: t.metadata,\n            })),\n        ];\n    }\n    toString() {\n        return ('schedulerFor()`\\n' +\n            this.report()\n                .map(SchedulerImplem.buildLog)\n                .map((log) => `-> ${log}`)\n                .join('\\n') +\n            '`');\n    }\n    [cloneMethod]() {\n        return new SchedulerImplem(this.act, this.sourceTaskSelector);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}