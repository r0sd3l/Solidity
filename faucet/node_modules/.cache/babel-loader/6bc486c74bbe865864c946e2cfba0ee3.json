{"ast":null,"code":"import { MaxLengthUpperBound } from '../helpers/MaxLengthFromMinLength.js';\nexport function patternsToStringMapper(tab) {\n  return tab.join('');\n}\nexport function patternsToStringUnmapperFor(patternsArb, constraints) {\n  return function patternsToStringUnmapper(value) {\n    if (typeof value !== 'string') {\n      throw new Error('Unsupported value');\n    }\n\n    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthUpperBound;\n\n    if (value.length === 0) {\n      if (minLength > 0) {\n        throw new Error('Unable to unmap received string');\n      }\n\n      return [];\n    }\n\n    const stack = [{\n      endIndexChunks: 0,\n      nextStartIndex: 1,\n      chunks: []\n    }];\n\n    while (stack.length > 0) {\n      const last = stack.pop();\n\n      for (let index = last.nextStartIndex; index <= value.length; ++index) {\n        const chunk = value.substring(last.endIndexChunks, index);\n\n        if (patternsArb.canShrinkWithoutContext(chunk)) {\n          const newChunks = last.chunks.concat([chunk]);\n\n          if (index === value.length) {\n            if (newChunks.length < minLength || newChunks.length > maxLength) {\n              break;\n            }\n\n            return newChunks;\n          }\n\n          stack.push({\n            endIndexChunks: last.endIndexChunks,\n            nextStartIndex: index + 1,\n            chunks: last.chunks\n          });\n          stack.push({\n            endIndexChunks: index,\n            nextStartIndex: index + 1,\n            chunks: newChunks\n          });\n          break;\n        }\n      }\n    }\n\n    throw new Error('Unable to unmap received string');\n  };\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js"],"names":["MaxLengthUpperBound","patternsToStringMapper","tab","join","patternsToStringUnmapperFor","patternsArb","constraints","patternsToStringUnmapper","value","Error","minLength","undefined","maxLength","length","stack","endIndexChunks","nextStartIndex","chunks","last","pop","index","chunk","substring","canShrinkWithoutContext","newChunks","concat","push"],"mappings":"AAAA,SAASA,mBAAT,QAAoC,sCAApC;AACA,OAAO,SAASC,sBAAT,CAAgCC,GAAhC,EAAqC;AACxC,SAAOA,GAAG,CAACC,IAAJ,CAAS,EAAT,CAAP;AACH;AACD,OAAO,SAASC,2BAAT,CAAqCC,WAArC,EAAkDC,WAAlD,EAA+D;AAClE,SAAO,SAASC,wBAAT,CAAkCC,KAAlC,EAAyC;AAC5C,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,YAAM,IAAIC,KAAJ,CAAU,mBAAV,CAAN;AACH;;AACD,UAAMC,SAAS,GAAGJ,WAAW,CAACI,SAAZ,KAA0BC,SAA1B,GAAsCL,WAAW,CAACI,SAAlD,GAA8D,CAAhF;AACA,UAAME,SAAS,GAAGN,WAAW,CAACM,SAAZ,KAA0BD,SAA1B,GAAsCL,WAAW,CAACM,SAAlD,GAA8DZ,mBAAhF;;AACA,QAAIQ,KAAK,CAACK,MAAN,KAAiB,CAArB,EAAwB;AACpB,UAAIH,SAAS,GAAG,CAAhB,EAAmB;AACf,cAAM,IAAID,KAAJ,CAAU,iCAAV,CAAN;AACH;;AACD,aAAO,EAAP;AACH;;AACD,UAAMK,KAAK,GAAG,CAAC;AAAEC,MAAAA,cAAc,EAAE,CAAlB;AAAqBC,MAAAA,cAAc,EAAE,CAArC;AAAwCC,MAAAA,MAAM,EAAE;AAAhD,KAAD,CAAd;;AACA,WAAOH,KAAK,CAACD,MAAN,GAAe,CAAtB,EAAyB;AACrB,YAAMK,IAAI,GAAGJ,KAAK,CAACK,GAAN,EAAb;;AACA,WAAK,IAAIC,KAAK,GAAGF,IAAI,CAACF,cAAtB,EAAsCI,KAAK,IAAIZ,KAAK,CAACK,MAArD,EAA6D,EAAEO,KAA/D,EAAsE;AAClE,cAAMC,KAAK,GAAGb,KAAK,CAACc,SAAN,CAAgBJ,IAAI,CAACH,cAArB,EAAqCK,KAArC,CAAd;;AACA,YAAIf,WAAW,CAACkB,uBAAZ,CAAoCF,KAApC,CAAJ,EAAgD;AAC5C,gBAAMG,SAAS,GAAGN,IAAI,CAACD,MAAL,CAAYQ,MAAZ,CAAmB,CAACJ,KAAD,CAAnB,CAAlB;;AACA,cAAID,KAAK,KAAKZ,KAAK,CAACK,MAApB,EAA4B;AACxB,gBAAIW,SAAS,CAACX,MAAV,GAAmBH,SAAnB,IAAgCc,SAAS,CAACX,MAAV,GAAmBD,SAAvD,EAAkE;AAC9D;AACH;;AACD,mBAAOY,SAAP;AACH;;AACDV,UAAAA,KAAK,CAACY,IAAN,CAAW;AAAEX,YAAAA,cAAc,EAAEG,IAAI,CAACH,cAAvB;AAAuCC,YAAAA,cAAc,EAAEI,KAAK,GAAG,CAA/D;AAAkEH,YAAAA,MAAM,EAAEC,IAAI,CAACD;AAA/E,WAAX;AACAH,UAAAA,KAAK,CAACY,IAAN,CAAW;AAAEX,YAAAA,cAAc,EAAEK,KAAlB;AAAyBJ,YAAAA,cAAc,EAAEI,KAAK,GAAG,CAAjD;AAAoDH,YAAAA,MAAM,EAAEO;AAA5D,WAAX;AACA;AACH;AACJ;AACJ;;AACD,UAAM,IAAIf,KAAJ,CAAU,iCAAV,CAAN;AACH,GAhCD;AAiCH","sourcesContent":["import { MaxLengthUpperBound } from '../helpers/MaxLengthFromMinLength.js';\nexport function patternsToStringMapper(tab) {\n    return tab.join('');\n}\nexport function patternsToStringUnmapperFor(patternsArb, constraints) {\n    return function patternsToStringUnmapper(value) {\n        if (typeof value !== 'string') {\n            throw new Error('Unsupported value');\n        }\n        const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n        const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthUpperBound;\n        if (value.length === 0) {\n            if (minLength > 0) {\n                throw new Error('Unable to unmap received string');\n            }\n            return [];\n        }\n        const stack = [{ endIndexChunks: 0, nextStartIndex: 1, chunks: [] }];\n        while (stack.length > 0) {\n            const last = stack.pop();\n            for (let index = last.nextStartIndex; index <= value.length; ++index) {\n                const chunk = value.substring(last.endIndexChunks, index);\n                if (patternsArb.canShrinkWithoutContext(chunk)) {\n                    const newChunks = last.chunks.concat([chunk]);\n                    if (index === value.length) {\n                        if (newChunks.length < minLength || newChunks.length > maxLength) {\n                            break;\n                        }\n                        return newChunks;\n                    }\n                    stack.push({ endIndexChunks: last.endIndexChunks, nextStartIndex: index + 1, chunks: last.chunks });\n                    stack.push({ endIndexChunks: index, nextStartIndex: index + 1, chunks: newChunks });\n                    break;\n                }\n            }\n        }\n        throw new Error('Unable to unmap received string');\n    };\n}\n"]},"metadata":{},"sourceType":"module"}