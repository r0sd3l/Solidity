{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.abifyResult = exports.abifyType = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abify\");\n\nconst Format = __importStar(require(\"./format\"));\n\nconst Common = __importStar(require(\"./common\"));\n\nconst Conversion = __importStar(require(\"./conversion\"));\n/** @category ABIfication */\n\n\nfunction abifyType(dataType, userDefinedTypes) {\n  switch (dataType.typeClass) {\n    //we only need to specially handle types that don't go in\n    //the ABI, or that have some information loss when going\n    //in the ABI\n    //note that we do need to handle arrays, due to recursion!\n    //First: types that do not go in the ABI\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n      return undefined;\n    //Next: address & contract, these can get handled together\n\n    case \"address\":\n    case \"contract\":\n      return {\n        typeClass: \"address\",\n        kind: \"general\",\n        typeHint: Format.Types.typeString(dataType)\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            typeClass: \"function\",\n            visibility: \"external\",\n            kind: \"general\",\n            typeHint: Format.Types.typeString(dataType)\n          };\n\n        case \"internal\":\n          //these don't go in the ABI\n          return undefined;\n      }\n\n      break;\n    //to satisfy TypeScript\n    //the complex cases: struct & enum\n\n    case \"struct\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n\n        if (!fullType.memberTypes) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n\n        const memberTypes = fullType.memberTypes.map(_ref => {\n          let {\n            name,\n            type: memberType\n          } = _ref;\n          return {\n            name,\n            type: abifyType(memberType, userDefinedTypes)\n          };\n        });\n        return {\n          typeClass: \"tuple\",\n          typeHint: Format.Types.typeString(fullType),\n          memberTypes\n        };\n      }\n\n    case \"enum\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n\n        if (!fullType.options) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n\n        let numOptions = fullType.options.length;\n        let bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n        return {\n          typeClass: \"uint\",\n          bits,\n          typeHint: Format.Types.typeString(fullType)\n        };\n      }\n\n    case \"userDefinedValueType\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n\n        if (!fullType.underlyingType) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n\n        const abifiedUnderlying = abifyType(fullType.underlyingType, userDefinedTypes);\n        return Object.assign(Object.assign({}, abifiedUnderlying), {\n          typeHint: Format.Types.typeStringWithoutLocation(dataType)\n        });\n      }\n    //finally: arrays\n\n    case \"array\":\n      return Object.assign(Object.assign({}, dataType), {\n        typeHint: Format.Types.typeString(dataType),\n        baseType: abifyType(dataType.baseType, userDefinedTypes)\n      });\n    //default case: just leave as-is\n\n    default:\n      return dataType;\n  }\n}\n\nexports.abifyType = abifyType;\n/** @category ABIfication */\n\nfunction abifyResult(result, userDefinedTypes) {\n  switch (result.type.typeClass) {\n    case \"mapping\": //doesn't go in ABI\n\n    case \"magic\": //doesn't go in ABI\n\n    case \"type\":\n      //doesn't go in ABI\n      return undefined;\n\n    case \"address\":\n      //abify the type but leave the value alone\n      return Object.assign(Object.assign({}, result), {\n        type: abifyType(result.type, userDefinedTypes)\n      });\n\n    case \"contract\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            return {\n              type: abifyType(result.type, userDefinedTypes),\n              kind: \"value\",\n              value: {\n                asAddress: coercedResult.value.address,\n                rawAsHex: coercedResult.value.rawAddress\n              }\n            };\n\n          case \"error\":\n            switch (coercedResult.error.kind) {\n              case \"ContractPaddingError\":\n                return {\n                  type: abifyType(result.type, userDefinedTypes),\n                  kind: \"error\",\n                  error: {\n                    kind: \"AddressPaddingError\",\n                    paddingType: coercedResult.error.paddingType,\n                    raw: coercedResult.error.raw\n                  }\n                };\n\n              default:\n                //other contract errors are generic errors!\n                //but TS doesn't know this so we coerce\n                return Object.assign(Object.assign({}, coercedResult), {\n                  type: abifyType(result.type, userDefinedTypes)\n                });\n            }\n\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"function\":\n      switch (result.type.visibility) {\n        case \"external\":\n          {\n            let coercedResult = result;\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n          }\n\n        case \"internal\":\n          //these don't go in the ABI\n          return undefined;\n      }\n\n      break;\n    //to satisfy TypeScript\n\n    case \"struct\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            if (coercedResult.reference !== undefined) {\n              return undefined; //no circular values in the ABI!\n            }\n\n            let abifiedMembers = coercedResult.value.map(_ref2 => {\n              let {\n                name,\n                value: member\n              } = _ref2;\n              return {\n                name,\n                value: abifyResult(member, userDefinedTypes)\n              };\n            });\n            return {\n              kind: \"value\",\n              type: abifyType(result.type, userDefinedTypes),\n              value: abifiedMembers\n            };\n\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes) //note: may throw exception\n\n            });\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        const coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            return abifyResult(coercedResult.value, userDefinedTypes);\n\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n        }\n\n        break; //to satisfy TS :P\n      }\n\n    case \"enum\":\n      {\n        //NOTE: this is the one case where errors are converted to non-error values!!\n        //(other than recursively, I mean)\n        //be aware!\n        let coercedResult = result;\n        let uintType = abifyType(result.type, userDefinedTypes); //may throw exception\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            return {\n              type: uintType,\n              kind: \"value\",\n              value: {\n                asBN: coercedResult.value.numericAsBN.clone()\n              }\n            };\n\n          case \"error\":\n            switch (coercedResult.error.kind) {\n              case \"EnumOutOfRangeError\":\n                return {\n                  type: uintType,\n                  kind: \"value\",\n                  value: {\n                    asBN: coercedResult.error.rawAsBN.clone()\n                  }\n                };\n\n              case \"EnumPaddingError\":\n                return {\n                  type: uintType,\n                  kind: \"error\",\n                  error: {\n                    kind: \"UintPaddingError\",\n                    paddingType: coercedResult.error.paddingType,\n                    raw: coercedResult.error.raw\n                  }\n                };\n\n              case \"EnumNotFoundDecodingError\":\n                let numericValue = coercedResult.error.rawAsBN.clone();\n\n                if (numericValue.bitLength() <= uintType.bits) {\n                  return {\n                    type: uintType,\n                    kind: \"value\",\n                    value: {\n                      asBN: numericValue\n                    }\n                  };\n                } else {\n                  return {\n                    type: uintType,\n                    kind: \"error\",\n                    error: {\n                      kind: \"UintPaddingError\",\n                      paddingType: \"left\",\n                      raw: Conversion.toHexString(numericValue)\n                    }\n                  };\n                }\n\n              default:\n                return {\n                  type: uintType,\n                  kind: \"error\",\n                  error: coercedResult.error\n                };\n            }\n\n        }\n      }\n\n    case \"array\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            if (coercedResult.reference !== undefined) {\n              return undefined; //no circular values in the ABI!\n            }\n\n            let abifiedMembers = coercedResult.value.map(member => abifyResult(member, userDefinedTypes));\n            return {\n              kind: \"value\",\n              type: abifyType(result.type, userDefinedTypes),\n              value: abifiedMembers\n            };\n\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n        }\n      }\n\n    default:\n      return result;\n    //just coerce :-/\n  }\n}\n\nexports.abifyResult = abifyResult;\n/** @category ABIfication */\n\nfunction abifyCalldataDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n\n  switch (decoding.kind) {\n    case \"function\":\n    case \"constructor\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n          value: abifyResult(argument.value, userDefinedTypes)\n        }))\n      });\n\n    default:\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\"\n      });\n  }\n}\n\nexports.abifyCalldataDecoding = abifyCalldataDecoding;\n/** @category ABIfication */\n\nfunction abifyLogDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n\n  return Object.assign(Object.assign({}, decoding), {\n    decodingMode: \"abi\",\n    arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n      value: abifyResult(argument.value, userDefinedTypes)\n    }))\n  });\n}\n\nexports.abifyLogDecoding = abifyLogDecoding;\n/** @category ABIfication */\n\nfunction abifyReturndataDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n\n  switch (decoding.kind) {\n    case \"return\":\n    case \"revert\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n          value: abifyResult(argument.value, userDefinedTypes)\n        }))\n      });\n\n    case \"bytecode\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        immutables: undefined\n      });\n\n    default:\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\"\n      });\n  }\n}\n\nexports.abifyReturndataDecoding = abifyReturndataDecoding;","map":{"version":3,"sources":["../../lib/abify.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.abifyResult = exports.abifyType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:abify\");\nconst Format = __importStar(require(\"./format\"));\nconst Common = __importStar(require(\"./common\"));\nconst Conversion = __importStar(require(\"./conversion\"));\n/** @category ABIfication */\nfunction abifyType(dataType, userDefinedTypes) {\n    switch (dataType.typeClass) {\n        //we only need to specially handle types that don't go in\n        //the ABI, or that have some information loss when going\n        //in the ABI\n        //note that we do need to handle arrays, due to recursion!\n        //First: types that do not go in the ABI\n        case \"mapping\":\n        case \"magic\":\n        case \"type\":\n            return undefined;\n        //Next: address & contract, these can get handled together\n        case \"address\":\n        case \"contract\":\n            return {\n                typeClass: \"address\",\n                kind: \"general\",\n                typeHint: Format.Types.typeString(dataType)\n            };\n        case \"function\":\n            switch (dataType.visibility) {\n                case \"external\":\n                    return {\n                        typeClass: \"function\",\n                        visibility: \"external\",\n                        kind: \"general\",\n                        typeHint: Format.Types.typeString(dataType)\n                    };\n                case \"internal\": //these don't go in the ABI\n                    return undefined;\n            }\n            break; //to satisfy TypeScript\n        //the complex cases: struct & enum\n        case \"struct\": {\n            const fullType = (Format.Types.fullType(dataType, userDefinedTypes));\n            if (!fullType.memberTypes) {\n                let typeToDisplay = Format.Types.typeString(dataType);\n                throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n            }\n            const memberTypes = fullType.memberTypes.map(({ name, type: memberType }) => ({\n                name,\n                type: abifyType(memberType, userDefinedTypes)\n            }));\n            return {\n                typeClass: \"tuple\",\n                typeHint: Format.Types.typeString(fullType),\n                memberTypes\n            };\n        }\n        case \"enum\": {\n            const fullType = (Format.Types.fullType(dataType, userDefinedTypes));\n            if (!fullType.options) {\n                let typeToDisplay = Format.Types.typeString(dataType);\n                throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n            }\n            let numOptions = fullType.options.length;\n            let bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n            return {\n                typeClass: \"uint\",\n                bits,\n                typeHint: Format.Types.typeString(fullType)\n            };\n        }\n        case \"userDefinedValueType\": {\n            const fullType = (Format.Types.fullType(dataType, userDefinedTypes));\n            if (!fullType.underlyingType) {\n                let typeToDisplay = Format.Types.typeString(dataType);\n                throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n            }\n            const abifiedUnderlying = abifyType(fullType.underlyingType, userDefinedTypes);\n            return Object.assign(Object.assign({}, abifiedUnderlying), { typeHint: Format.Types.typeStringWithoutLocation(dataType) });\n        }\n        //finally: arrays\n        case \"array\":\n            return Object.assign(Object.assign({}, dataType), { typeHint: Format.Types.typeString(dataType), baseType: abifyType(dataType.baseType, userDefinedTypes) });\n        //default case: just leave as-is\n        default:\n            return dataType;\n    }\n}\nexports.abifyType = abifyType;\n/** @category ABIfication */\nfunction abifyResult(result, userDefinedTypes) {\n    switch (result.type.typeClass) {\n        case \"mapping\": //doesn't go in ABI\n        case \"magic\": //doesn't go in ABI\n        case \"type\": //doesn't go in ABI\n            return undefined;\n        case \"address\":\n            //abify the type but leave the value alone\n            return Object.assign(Object.assign({}, result), { type: abifyType(result.type, userDefinedTypes) });\n        case \"contract\": {\n            let coercedResult = result;\n            switch (coercedResult.kind) {\n                case \"value\":\n                    return {\n                        type: (abifyType(result.type, userDefinedTypes)),\n                        kind: \"value\",\n                        value: {\n                            asAddress: coercedResult.value.address,\n                            rawAsHex: coercedResult.value.rawAddress\n                        }\n                    };\n                case \"error\":\n                    switch (coercedResult.error.kind) {\n                        case \"ContractPaddingError\":\n                            return {\n                                type: (abifyType(result.type, userDefinedTypes)),\n                                kind: \"error\",\n                                error: {\n                                    kind: \"AddressPaddingError\",\n                                    paddingType: coercedResult.error.paddingType,\n                                    raw: coercedResult.error.raw\n                                }\n                            };\n                        default:\n                            //other contract errors are generic errors!\n                            //but TS doesn't know this so we coerce\n                            return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) });\n                    }\n            }\n            break; //to satisfy typescript\n        }\n        case \"function\":\n            switch (result.type.visibility) {\n                case \"external\": {\n                    let coercedResult = result;\n                    return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) });\n                }\n                case \"internal\": //these don't go in the ABI\n                    return undefined;\n            }\n            break; //to satisfy TypeScript\n        case \"struct\": {\n            let coercedResult = result;\n            switch (coercedResult.kind) {\n                case \"value\":\n                    if (coercedResult.reference !== undefined) {\n                        return undefined; //no circular values in the ABI!\n                    }\n                    let abifiedMembers = coercedResult.value.map(({ name, value: member }) => ({\n                        name,\n                        value: abifyResult(member, userDefinedTypes)\n                    }));\n                    return {\n                        kind: \"value\",\n                        type: (abifyType(result.type, userDefinedTypes)),\n                        value: abifiedMembers\n                    };\n                case \"error\":\n                    return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) //note: may throw exception\n                     });\n            }\n        }\n        case \"userDefinedValueType\": {\n            const coercedResult = result;\n            switch (coercedResult.kind) {\n                case \"value\":\n                    return abifyResult(coercedResult.value, userDefinedTypes);\n                case \"error\":\n                    return Object.assign(Object.assign({}, coercedResult), { type: abifyType(result.type, userDefinedTypes) });\n            }\n            break; //to satisfy TS :P\n        }\n        case \"enum\": {\n            //NOTE: this is the one case where errors are converted to non-error values!!\n            //(other than recursively, I mean)\n            //be aware!\n            let coercedResult = result;\n            let uintType = (abifyType(result.type, userDefinedTypes)); //may throw exception\n            switch (coercedResult.kind) {\n                case \"value\":\n                    return {\n                        type: uintType,\n                        kind: \"value\",\n                        value: {\n                            asBN: coercedResult.value.numericAsBN.clone()\n                        }\n                    };\n                case \"error\":\n                    switch (coercedResult.error.kind) {\n                        case \"EnumOutOfRangeError\":\n                            return {\n                                type: uintType,\n                                kind: \"value\",\n                                value: {\n                                    asBN: coercedResult.error.rawAsBN.clone()\n                                }\n                            };\n                        case \"EnumPaddingError\":\n                            return {\n                                type: uintType,\n                                kind: \"error\",\n                                error: {\n                                    kind: \"UintPaddingError\",\n                                    paddingType: coercedResult.error.paddingType,\n                                    raw: coercedResult.error.raw\n                                }\n                            };\n                        case \"EnumNotFoundDecodingError\":\n                            let numericValue = coercedResult.error.rawAsBN.clone();\n                            if (numericValue.bitLength() <= uintType.bits) {\n                                return {\n                                    type: uintType,\n                                    kind: \"value\",\n                                    value: {\n                                        asBN: numericValue\n                                    }\n                                };\n                            }\n                            else {\n                                return {\n                                    type: uintType,\n                                    kind: \"error\",\n                                    error: {\n                                        kind: \"UintPaddingError\",\n                                        paddingType: \"left\",\n                                        raw: Conversion.toHexString(numericValue)\n                                    }\n                                };\n                            }\n                        default:\n                            return {\n                                type: uintType,\n                                kind: \"error\",\n                                error: coercedResult.error\n                            };\n                    }\n            }\n        }\n        case \"array\": {\n            let coercedResult = result;\n            switch (coercedResult.kind) {\n                case \"value\":\n                    if (coercedResult.reference !== undefined) {\n                        return undefined; //no circular values in the ABI!\n                    }\n                    let abifiedMembers = coercedResult.value.map(member => abifyResult(member, userDefinedTypes));\n                    return {\n                        kind: \"value\",\n                        type: (abifyType(result.type, userDefinedTypes)),\n                        value: abifiedMembers\n                    };\n                case \"error\":\n                    return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) });\n            }\n        }\n        default:\n            return result; //just coerce :-/\n    }\n}\nexports.abifyResult = abifyResult;\n/** @category ABIfication */\nfunction abifyCalldataDecoding(decoding, userDefinedTypes) {\n    if (decoding.decodingMode === \"abi\") {\n        return decoding;\n    }\n    switch (decoding.kind) {\n        case \"function\":\n        case \"constructor\":\n            return Object.assign(Object.assign({}, decoding), { decodingMode: \"abi\", arguments: decoding.arguments.map(argument => (Object.assign(Object.assign({}, argument), { value: abifyResult(argument.value, userDefinedTypes) }))) });\n        default:\n            return Object.assign(Object.assign({}, decoding), { decodingMode: \"abi\" });\n    }\n}\nexports.abifyCalldataDecoding = abifyCalldataDecoding;\n/** @category ABIfication */\nfunction abifyLogDecoding(decoding, userDefinedTypes) {\n    if (decoding.decodingMode === \"abi\") {\n        return decoding;\n    }\n    return Object.assign(Object.assign({}, decoding), { decodingMode: \"abi\", arguments: decoding.arguments.map(argument => (Object.assign(Object.assign({}, argument), { value: abifyResult(argument.value, userDefinedTypes) }))) });\n}\nexports.abifyLogDecoding = abifyLogDecoding;\n/** @category ABIfication */\nfunction abifyReturndataDecoding(decoding, userDefinedTypes) {\n    if (decoding.decodingMode === \"abi\") {\n        return decoding;\n    }\n    switch (decoding.kind) {\n        case \"return\":\n        case \"revert\":\n            return Object.assign(Object.assign({}, decoding), { decodingMode: \"abi\", arguments: decoding.arguments.map(argument => (Object.assign(Object.assign({}, argument), { value: abifyResult(argument.value, userDefinedTypes) }))) });\n        case \"bytecode\":\n            return Object.assign(Object.assign({}, decoding), { decodingMode: \"abi\", immutables: undefined });\n        default:\n            return Object.assign(Object.assign({}, decoding), { decodingMode: \"abi\" });\n    }\n}\nexports.abifyReturndataDecoding = abifyReturndataDecoding;\n//# sourceMappingURL=abify.js.map"]},"metadata":{},"sourceType":"script"}