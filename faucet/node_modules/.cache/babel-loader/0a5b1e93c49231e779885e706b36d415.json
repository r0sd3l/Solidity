{"ast":null,"code":"import { stream, Stream } from '../../stream/Stream.js';\nimport { convertFromNextWithShrunkOnce } from '../../check/arbitrary/definition/Converters.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { add64, halve64, isEqual64, isStrictlyNegative64, isStrictlyPositive64, isStrictlySmaller64, isZero64, logLike64, substract64, Unit64, Zero64 } from './helpers/ArrayInt64.js';\n\nclass ArrayInt64Arbitrary extends NextArbitrary {\n  constructor(min, max) {\n    super();\n    this.min = min;\n    this.max = max;\n    this.biasedRanges = null;\n  }\n\n  generate(mrng, biasFactor) {\n    const range = this.computeGenerateRange(mrng, biasFactor);\n    const uncheckedValue = mrng.nextArrayInt(range.min, range.max);\n\n    if (uncheckedValue.data.length === 1) {\n      uncheckedValue.data.unshift(0);\n    }\n\n    return new NextValue(uncheckedValue, undefined);\n  }\n\n  computeGenerateRange(mrng, biasFactor) {\n    if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {\n      return {\n        min: this.min,\n        max: this.max\n      };\n    }\n\n    const ranges = this.retrieveBiasedRanges();\n\n    if (ranges.length === 1) {\n      return ranges[0];\n    }\n\n    const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);\n    return id < 0 ? ranges[0] : ranges[id + 1];\n  }\n\n  canShrinkWithoutContext(value) {\n    const unsafeValue = value;\n    return typeof value === 'object' && value !== null && (unsafeValue.sign === -1 || unsafeValue.sign === 1) && Array.isArray(unsafeValue.data) && unsafeValue.data.length === 2 && (isStrictlySmaller64(this.min, unsafeValue) && isStrictlySmaller64(unsafeValue, this.max) || isEqual64(this.min, unsafeValue) || isEqual64(this.max, unsafeValue));\n  }\n\n  shrinkArrayInt64(value, target, tryTargetAsap) {\n    const realGap = substract64(value, target);\n\n    function* shrinkGen() {\n      let previous = tryTargetAsap ? undefined : target;\n      const gap = tryTargetAsap ? realGap : halve64(realGap);\n\n      for (let toremove = gap; !isZero64(toremove); toremove = halve64(toremove)) {\n        const next = substract64(value, toremove);\n        yield new NextValue(next, previous);\n        previous = next;\n      }\n    }\n\n    return stream(shrinkGen());\n  }\n\n  shrink(current, context) {\n    if (!ArrayInt64Arbitrary.isValidContext(current, context)) {\n      const target = this.defaultTarget();\n      return this.shrinkArrayInt64(current, target, true);\n    }\n\n    if (this.isLastChanceTry(current, context)) {\n      return Stream.of(new NextValue(context, undefined));\n    }\n\n    return this.shrinkArrayInt64(current, context, false);\n  }\n\n  defaultTarget() {\n    if (!isStrictlyPositive64(this.min) && !isStrictlyNegative64(this.max)) {\n      return Zero64;\n    }\n\n    return isStrictlyNegative64(this.min) ? this.max : this.min;\n  }\n\n  isLastChanceTry(current, context) {\n    if (isZero64(current)) {\n      return false;\n    }\n\n    if (current.sign === 1) {\n      return isEqual64(current, add64(context, Unit64)) && isStrictlyPositive64(substract64(current, this.min));\n    } else {\n      return isEqual64(current, substract64(context, Unit64)) && isStrictlyNegative64(substract64(current, this.max));\n    }\n  }\n\n  static isValidContext(_current, context) {\n    if (context === undefined) {\n      return false;\n    }\n\n    if (typeof context !== 'object' || context === null || !('sign' in context) || !('data' in context)) {\n      throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);\n    }\n\n    return true;\n  }\n\n  retrieveBiasedRanges() {\n    if (this.biasedRanges != null) {\n      return this.biasedRanges;\n    }\n\n    if (isEqual64(this.min, this.max)) {\n      this.biasedRanges = [{\n        min: this.min,\n        max: this.max\n      }];\n      return this.biasedRanges;\n    }\n\n    const minStrictlySmallerZero = isStrictlyNegative64(this.min);\n    const maxStrictlyGreaterZero = isStrictlyPositive64(this.max);\n\n    if (minStrictlySmallerZero && maxStrictlyGreaterZero) {\n      const logMin = logLike64(this.min);\n      const logMax = logLike64(this.max);\n      this.biasedRanges = [{\n        min: logMin,\n        max: logMax\n      }, {\n        min: substract64(this.max, logMax),\n        max: this.max\n      }, {\n        min: this.min,\n        max: substract64(this.min, logMin)\n      }];\n    } else {\n      const logGap = logLike64(substract64(this.max, this.min));\n      const arbCloseToMin = {\n        min: this.min,\n        max: add64(this.min, logGap)\n      };\n      const arbCloseToMax = {\n        min: substract64(this.max, logGap),\n        max: this.max\n      };\n      this.biasedRanges = minStrictlySmallerZero ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];\n    }\n\n    return this.biasedRanges;\n  }\n\n}\n\nexport function arrayInt64(min, max) {\n  const arb = new ArrayInt64Arbitrary(min, max);\n  return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayInt64Arbitrary.js"],"names":["stream","Stream","convertFromNextWithShrunkOnce","NextArbitrary","NextValue","add64","halve64","isEqual64","isStrictlyNegative64","isStrictlyPositive64","isStrictlySmaller64","isZero64","logLike64","substract64","Unit64","Zero64","ArrayInt64Arbitrary","constructor","min","max","biasedRanges","generate","mrng","biasFactor","range","computeGenerateRange","uncheckedValue","nextArrayInt","data","length","unshift","undefined","nextInt","ranges","retrieveBiasedRanges","id","canShrinkWithoutContext","value","unsafeValue","sign","Array","isArray","shrinkArrayInt64","target","tryTargetAsap","realGap","shrinkGen","previous","gap","toremove","next","shrink","current","context","isValidContext","defaultTarget","isLastChanceTry","of","_current","Error","minStrictlySmallerZero","maxStrictlyGreaterZero","logMin","logMax","logGap","arbCloseToMin","arbCloseToMax","arrayInt64","arb"],"mappings":"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","sourcesContent":["import { stream, Stream } from '../../stream/Stream.js';\nimport { convertFromNextWithShrunkOnce } from '../../check/arbitrary/definition/Converters.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { add64, halve64, isEqual64, isStrictlyNegative64, isStrictlyPositive64, isStrictlySmaller64, isZero64, logLike64, substract64, Unit64, Zero64, } from './helpers/ArrayInt64.js';\nclass ArrayInt64Arbitrary extends NextArbitrary {\n    constructor(min, max) {\n        super();\n        this.min = min;\n        this.max = max;\n        this.biasedRanges = null;\n    }\n    generate(mrng, biasFactor) {\n        const range = this.computeGenerateRange(mrng, biasFactor);\n        const uncheckedValue = mrng.nextArrayInt(range.min, range.max);\n        if (uncheckedValue.data.length === 1) {\n            uncheckedValue.data.unshift(0);\n        }\n        return new NextValue(uncheckedValue, undefined);\n    }\n    computeGenerateRange(mrng, biasFactor) {\n        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {\n            return { min: this.min, max: this.max };\n        }\n        const ranges = this.retrieveBiasedRanges();\n        if (ranges.length === 1) {\n            return ranges[0];\n        }\n        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);\n        return id < 0 ? ranges[0] : ranges[id + 1];\n    }\n    canShrinkWithoutContext(value) {\n        const unsafeValue = value;\n        return (typeof value === 'object' &&\n            value !== null &&\n            (unsafeValue.sign === -1 || unsafeValue.sign === 1) &&\n            Array.isArray(unsafeValue.data) &&\n            unsafeValue.data.length === 2 &&\n            ((isStrictlySmaller64(this.min, unsafeValue) && isStrictlySmaller64(unsafeValue, this.max)) ||\n                isEqual64(this.min, unsafeValue) ||\n                isEqual64(this.max, unsafeValue)));\n    }\n    shrinkArrayInt64(value, target, tryTargetAsap) {\n        const realGap = substract64(value, target);\n        function* shrinkGen() {\n            let previous = tryTargetAsap ? undefined : target;\n            const gap = tryTargetAsap ? realGap : halve64(realGap);\n            for (let toremove = gap; !isZero64(toremove); toremove = halve64(toremove)) {\n                const next = substract64(value, toremove);\n                yield new NextValue(next, previous);\n                previous = next;\n            }\n        }\n        return stream(shrinkGen());\n    }\n    shrink(current, context) {\n        if (!ArrayInt64Arbitrary.isValidContext(current, context)) {\n            const target = this.defaultTarget();\n            return this.shrinkArrayInt64(current, target, true);\n        }\n        if (this.isLastChanceTry(current, context)) {\n            return Stream.of(new NextValue(context, undefined));\n        }\n        return this.shrinkArrayInt64(current, context, false);\n    }\n    defaultTarget() {\n        if (!isStrictlyPositive64(this.min) && !isStrictlyNegative64(this.max)) {\n            return Zero64;\n        }\n        return isStrictlyNegative64(this.min) ? this.max : this.min;\n    }\n    isLastChanceTry(current, context) {\n        if (isZero64(current)) {\n            return false;\n        }\n        if (current.sign === 1) {\n            return isEqual64(current, add64(context, Unit64)) && isStrictlyPositive64(substract64(current, this.min));\n        }\n        else {\n            return isEqual64(current, substract64(context, Unit64)) && isStrictlyNegative64(substract64(current, this.max));\n        }\n    }\n    static isValidContext(_current, context) {\n        if (context === undefined) {\n            return false;\n        }\n        if (typeof context !== 'object' || context === null || !('sign' in context) || !('data' in context)) {\n            throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);\n        }\n        return true;\n    }\n    retrieveBiasedRanges() {\n        if (this.biasedRanges != null) {\n            return this.biasedRanges;\n        }\n        if (isEqual64(this.min, this.max)) {\n            this.biasedRanges = [{ min: this.min, max: this.max }];\n            return this.biasedRanges;\n        }\n        const minStrictlySmallerZero = isStrictlyNegative64(this.min);\n        const maxStrictlyGreaterZero = isStrictlyPositive64(this.max);\n        if (minStrictlySmallerZero && maxStrictlyGreaterZero) {\n            const logMin = logLike64(this.min);\n            const logMax = logLike64(this.max);\n            this.biasedRanges = [\n                { min: logMin, max: logMax },\n                { min: substract64(this.max, logMax), max: this.max },\n                { min: this.min, max: substract64(this.min, logMin) },\n            ];\n        }\n        else {\n            const logGap = logLike64(substract64(this.max, this.min));\n            const arbCloseToMin = { min: this.min, max: add64(this.min, logGap) };\n            const arbCloseToMax = { min: substract64(this.max, logGap), max: this.max };\n            this.biasedRanges = minStrictlySmallerZero\n                ? [arbCloseToMax, arbCloseToMin]\n                : [arbCloseToMin, arbCloseToMax];\n        }\n        return this.biasedRanges;\n    }\n}\nexport function arrayInt64(min, max) {\n    const arb = new ArrayInt64Arbitrary(min, max);\n    return convertFromNextWithShrunkOnce(arb, arb.defaultTarget());\n}\n"]},"metadata":{},"sourceType":"module"}