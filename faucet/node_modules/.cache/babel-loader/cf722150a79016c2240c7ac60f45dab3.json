{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:memory:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeMemory(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (Format.Types.isReferenceType(dataType)) {\n    if (allocate_1.isSkippedInMemoryStructs(dataType)) {\n      //special case; these types are always empty in memory\n      return decodeMemorySkippedType(dataType);\n    } else {\n      return yield* decodeMemoryReferenceByAddress(dataType, pointer, info, options);\n    }\n  } else {\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n  }\n}\n\nexports.decodeMemory = decodeMemory;\n\nfunction decodeMemorySkippedType(dataType) {\n  switch (dataType.typeClass) {\n    case \"mapping\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n\n    case \"array\":\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: []\n      };\n    //other cases should not arise!\n  }\n}\n\nfunction* decodeMemoryReferenceByAddress(dataType, pointer, info) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    state\n  } = info;\n  const memoryVisited = options.memoryVisited || [];\n  debug(\"pointer %o\", pointer);\n  let rawValue;\n\n  try {\n    rawValue = yield* read_1.default(pointer, state);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error);\n  }\n\n  let startPositionAsBN = Conversion.toBN(rawValue);\n  let startPosition;\n\n  try {\n    startPosition = startPositionAsBN.toNumber();\n  } catch (_a) {\n    return {\n      //again with the TS failures...\n      type: dataType,\n      kind: \"error\",\n      error: {\n        kind: \"OverlargePointersNotImplementedError\",\n        pointerAsBN: startPositionAsBN\n      }\n    };\n  } //startPosition may get modified later, so let's save the current\n  //value for circularity detection purposes\n\n\n  const objectPosition = startPosition;\n  let rawLength;\n  let lengthAsBN;\n  let length;\n  let seenPreviously;\n\n  switch (dataType.typeClass) {\n    case \"bytes\":\n    case \"string\":\n      //initial word contains length\n      try {\n        rawLength = yield* read_1.default({\n          location: \"memory\",\n          start: startPosition,\n          length: Evm.Utils.WORD_SIZE\n        }, state);\n      } catch (error) {\n        return errors_1.handleDecodingError(dataType, error);\n      }\n\n      lengthAsBN = Conversion.toBN(rawLength);\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_b) {\n        return {\n          //again with the TS failures...\n          type: dataType,\n          kind: \"error\",\n          error: {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          }\n        };\n      }\n\n      let childPointer = {\n        location: \"memory\",\n        start: startPosition + Evm.Utils.WORD_SIZE,\n        length\n      };\n      return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info);\n\n    case \"array\":\n      {\n        //first: circularity check!\n        seenPreviously = memoryVisited.indexOf(objectPosition);\n\n        if (seenPreviously !== -1) {\n          return {\n            type: dataType,\n            kind: \"value\",\n            reference: seenPreviously + 1,\n            value: [] //will be fixed later by the tie function\n\n          };\n        } //otherwise, decode as normal\n\n\n        if (dataType.kind === \"dynamic\") {\n          //initial word contains array length\n          try {\n            rawLength = yield* read_1.default({\n              location: \"memory\",\n              start: startPosition,\n              length: Evm.Utils.WORD_SIZE\n            }, state);\n          } catch (error) {\n            return errors_1.handleDecodingError(dataType, error);\n          }\n\n          lengthAsBN = Conversion.toBN(rawLength);\n          startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n          //to next word, as first word was used for length\n        } else {\n          lengthAsBN = dataType.length;\n        }\n\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_c) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n\n        let memoryNowVisited = [objectPosition, ...memoryVisited];\n        let baseType = dataType.baseType;\n        let decodedChildren = [];\n\n        for (let index = 0; index < length; index++) {\n          decodedChildren.push(yield* decodeMemory(baseType, {\n            location: \"memory\",\n            start: startPosition + index * Evm.Utils.WORD_SIZE,\n            length: Evm.Utils.WORD_SIZE\n          }, info, {\n            memoryVisited: memoryNowVisited\n          }));\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      }\n\n    case \"struct\":\n      {\n        //first: circularity check!\n        seenPreviously = memoryVisited.indexOf(objectPosition);\n\n        if (seenPreviously !== -1) {\n          return {\n            type: dataType,\n            kind: \"value\",\n            reference: seenPreviously + 1,\n            value: [] //will be fixed later by the tie function\n\n          };\n        } //otherwise, decode as normal\n\n\n        const {\n          allocations: {\n            memory: allocations\n          }\n        } = info;\n        const typeId = dataType.id;\n        const structAllocation = allocations[typeId];\n\n        if (!structAllocation) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          };\n        }\n\n        debug(\"structAllocation %O\", structAllocation);\n        let memoryNowVisited = [objectPosition, ...memoryVisited];\n        let decodedMembers = [];\n\n        for (let index = 0; index < structAllocation.members.length; index++) {\n          const memberAllocation = structAllocation.members[index];\n          const memberPointer = memberAllocation.pointer;\n          const childPointer = {\n            location: \"memory\",\n            start: startPosition + memberPointer.start,\n            length: memberPointer.length //always equals WORD_SIZE or 0\n\n          };\n          let memberName = memberAllocation.name;\n          let memberType = Format.Types.specifyLocation(memberAllocation.type, \"memory\");\n          decodedMembers.push({\n            name: memberName,\n            value: yield* decodeMemory(memberType, childPointer, info, {\n              memoryVisited: memoryNowVisited\n            })\n          });\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedMembers\n        };\n      }\n  }\n}\n\nexports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;","map":{"version":3,"sources":["../../../../lib/memory/decode/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:memory:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Format = __importStar(require(\"../../format\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst allocate_1 = require(\"../allocate\");\nconst errors_1 = require(\"../../errors\");\nfunction* decodeMemory(dataType, pointer, info, options = {}) {\n    if (Format.Types.isReferenceType(dataType)) {\n        if (allocate_1.isSkippedInMemoryStructs(dataType)) {\n            //special case; these types are always empty in memory\n            return decodeMemorySkippedType(dataType);\n        }\n        else {\n            return yield* decodeMemoryReferenceByAddress(dataType, pointer, info, options);\n        }\n    }\n    else {\n        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n    }\n}\nexports.decodeMemory = decodeMemory;\nfunction decodeMemorySkippedType(dataType) {\n    switch (dataType.typeClass) {\n        case \"mapping\":\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: []\n            };\n        case \"array\":\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: []\n            };\n        //other cases should not arise!\n    }\n}\nfunction* decodeMemoryReferenceByAddress(dataType, pointer, info, options = {}) {\n    const { state } = info;\n    const memoryVisited = options.memoryVisited || [];\n    debug(\"pointer %o\", pointer);\n    let rawValue;\n    try {\n        rawValue = yield* read_1.default(pointer, state);\n    }\n    catch (error) {\n        return errors_1.handleDecodingError(dataType, error);\n    }\n    let startPositionAsBN = Conversion.toBN(rawValue);\n    let startPosition;\n    try {\n        startPosition = startPositionAsBN.toNumber();\n    }\n    catch (_a) {\n        return {\n            //again with the TS failures...\n            type: dataType,\n            kind: \"error\",\n            error: {\n                kind: \"OverlargePointersNotImplementedError\",\n                pointerAsBN: startPositionAsBN\n            }\n        };\n    }\n    //startPosition may get modified later, so let's save the current\n    //value for circularity detection purposes\n    const objectPosition = startPosition;\n    let rawLength;\n    let lengthAsBN;\n    let length;\n    let seenPreviously;\n    switch (dataType.typeClass) {\n        case \"bytes\":\n        case \"string\":\n            //initial word contains length\n            try {\n                rawLength = yield* read_1.default({\n                    location: \"memory\",\n                    start: startPosition,\n                    length: Evm.Utils.WORD_SIZE\n                }, state);\n            }\n            catch (error) {\n                return errors_1.handleDecodingError(dataType, error);\n            }\n            lengthAsBN = Conversion.toBN(rawLength);\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_b) {\n                return {\n                    //again with the TS failures...\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            let childPointer = {\n                location: \"memory\",\n                start: startPosition + Evm.Utils.WORD_SIZE,\n                length\n            };\n            return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info);\n        case \"array\": {\n            //first: circularity check!\n            seenPreviously = memoryVisited.indexOf(objectPosition);\n            if (seenPreviously !== -1) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    reference: seenPreviously + 1,\n                    value: [] //will be fixed later by the tie function\n                };\n            }\n            //otherwise, decode as normal\n            if (dataType.kind === \"dynamic\") {\n                //initial word contains array length\n                try {\n                    rawLength = yield* read_1.default({\n                        location: \"memory\",\n                        start: startPosition,\n                        length: Evm.Utils.WORD_SIZE\n                    }, state);\n                }\n                catch (error) {\n                    return errors_1.handleDecodingError(dataType, error);\n                }\n                lengthAsBN = Conversion.toBN(rawLength);\n                startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n                //to next word, as first word was used for length\n            }\n            else {\n                lengthAsBN = dataType.length;\n            }\n            try {\n                length = lengthAsBN.toNumber();\n            }\n            catch (_c) {\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"OverlongArraysAndStringsNotImplementedError\",\n                        lengthAsBN\n                    }\n                };\n            }\n            let memoryNowVisited = [objectPosition, ...memoryVisited];\n            let baseType = dataType.baseType;\n            let decodedChildren = [];\n            for (let index = 0; index < length; index++) {\n                decodedChildren.push(yield* decodeMemory(baseType, {\n                    location: \"memory\",\n                    start: startPosition + index * Evm.Utils.WORD_SIZE,\n                    length: Evm.Utils.WORD_SIZE\n                }, info, { memoryVisited: memoryNowVisited }));\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedChildren\n            };\n        }\n        case \"struct\": {\n            //first: circularity check!\n            seenPreviously = memoryVisited.indexOf(objectPosition);\n            if (seenPreviously !== -1) {\n                return {\n                    type: dataType,\n                    kind: \"value\",\n                    reference: seenPreviously + 1,\n                    value: [] //will be fixed later by the tie function\n                };\n            }\n            //otherwise, decode as normal\n            const { allocations: { memory: allocations } } = info;\n            const typeId = dataType.id;\n            const structAllocation = allocations[typeId];\n            if (!structAllocation) {\n                return {\n                    type: dataType,\n                    kind: \"error\",\n                    error: {\n                        kind: \"UserDefinedTypeNotFoundError\",\n                        type: dataType\n                    }\n                };\n            }\n            debug(\"structAllocation %O\", structAllocation);\n            let memoryNowVisited = [objectPosition, ...memoryVisited];\n            let decodedMembers = [];\n            for (let index = 0; index < structAllocation.members.length; index++) {\n                const memberAllocation = structAllocation.members[index];\n                const memberPointer = memberAllocation.pointer;\n                const childPointer = {\n                    location: \"memory\",\n                    start: startPosition + memberPointer.start,\n                    length: memberPointer.length //always equals WORD_SIZE or 0\n                };\n                let memberName = memberAllocation.name;\n                let memberType = Format.Types.specifyLocation(memberAllocation.type, \"memory\");\n                decodedMembers.push({\n                    name: memberName,\n                    value: yield* decodeMemory(memberType, childPointer, info, {\n                        memoryVisited: memoryNowVisited\n                    })\n                });\n            }\n            return {\n                type: dataType,\n                kind: \"value\",\n                value: decodedMembers\n            };\n        }\n    }\n}\nexports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}