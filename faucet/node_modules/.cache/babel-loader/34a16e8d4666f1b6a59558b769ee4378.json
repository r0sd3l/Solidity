{"ast":null,"code":"import { integer } from '../integer.js';\nimport { floatToIndex, indexToFloat, MAX_VALUE_32 } from '../_internals/helpers/FloatHelpers.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\n\nfunction safeFloatToIndex(f, constraintsLabel) {\n  const conversionTrick = 'you can convert any double to a 32-bit float by using `new Float32Array([myDouble])[0]`';\n  const errorMessage = 'fc.floatNext constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;\n\n  if (Number.isNaN(f) || Number.isFinite(f) && (f < -MAX_VALUE_32 || f > MAX_VALUE_32)) {\n    throw new Error(errorMessage);\n  }\n\n  const index = floatToIndex(f);\n\n  if (!Number.isInteger(index)) {\n    throw new Error(errorMessage);\n  }\n\n  return index;\n}\n\nfunction unmapperFloatToIndex(value) {\n  if (typeof value !== 'number') throw new Error('Unsupported type');\n  return floatToIndex(value);\n}\n\nexport function floatNext() {\n  let constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    noDefaultInfinity = false,\n    noNaN = false,\n    min = noDefaultInfinity ? -MAX_VALUE_32 : Number.NEGATIVE_INFINITY,\n    max = noDefaultInfinity ? MAX_VALUE_32 : Number.POSITIVE_INFINITY\n  } = constraints;\n  const minIndex = safeFloatToIndex(min, 'min');\n  const maxIndex = safeFloatToIndex(max, 'max');\n\n  if (minIndex > maxIndex) {\n    throw new Error('fc.floatNext constraints.min must be smaller or equal to constraints.max');\n  }\n\n  if (noNaN) {\n    return convertFromNext(convertToNext(integer({\n      min: minIndex,\n      max: maxIndex\n    })).map(indexToFloat, unmapperFloatToIndex));\n  }\n\n  const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;\n  const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;\n  return convertFromNext(convertToNext(integer({\n    min: minIndexWithNaN,\n    max: maxIndexWithNaN\n  })).map(index => {\n    if (index > maxIndex || index < minIndex) return Number.NaN;else return indexToFloat(index);\n  }, value => {\n    if (typeof value !== 'number') throw new Error('Unsupported type');\n    if (Number.isNaN(value)) return maxIndex !== maxIndexWithNaN ? maxIndexWithNaN : minIndexWithNaN;\n    return floatToIndex(value);\n  }));\n}","map":{"version":3,"sources":["C:/Users/rodri/Solidity/solidity/faucet/node_modules/fast-check/lib/esm/arbitrary/_next/floatNext.js"],"names":["integer","floatToIndex","indexToFloat","MAX_VALUE_32","convertFromNext","convertToNext","safeFloatToIndex","f","constraintsLabel","conversionTrick","errorMessage","Number","isNaN","isFinite","Error","index","isInteger","unmapperFloatToIndex","value","floatNext","constraints","noDefaultInfinity","noNaN","min","NEGATIVE_INFINITY","max","POSITIVE_INFINITY","minIndex","maxIndex","map","minIndexWithNaN","maxIndexWithNaN","NaN"],"mappings":"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","sourcesContent":["import { integer } from '../integer.js';\nimport { floatToIndex, indexToFloat, MAX_VALUE_32 } from '../_internals/helpers/FloatHelpers.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\nfunction safeFloatToIndex(f, constraintsLabel) {\n    const conversionTrick = 'you can convert any double to a 32-bit float by using `new Float32Array([myDouble])[0]`';\n    const errorMessage = 'fc.floatNext constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;\n    if (Number.isNaN(f) || (Number.isFinite(f) && (f < -MAX_VALUE_32 || f > MAX_VALUE_32))) {\n        throw new Error(errorMessage);\n    }\n    const index = floatToIndex(f);\n    if (!Number.isInteger(index)) {\n        throw new Error(errorMessage);\n    }\n    return index;\n}\nfunction unmapperFloatToIndex(value) {\n    if (typeof value !== 'number')\n        throw new Error('Unsupported type');\n    return floatToIndex(value);\n}\nexport function floatNext(constraints = {}) {\n    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -MAX_VALUE_32 : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? MAX_VALUE_32 : Number.POSITIVE_INFINITY, } = constraints;\n    const minIndex = safeFloatToIndex(min, 'min');\n    const maxIndex = safeFloatToIndex(max, 'max');\n    if (minIndex > maxIndex) {\n        throw new Error('fc.floatNext constraints.min must be smaller or equal to constraints.max');\n    }\n    if (noNaN) {\n        return convertFromNext(convertToNext(integer({ min: minIndex, max: maxIndex })).map(indexToFloat, unmapperFloatToIndex));\n    }\n    const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;\n    const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;\n    return convertFromNext(convertToNext(integer({ min: minIndexWithNaN, max: maxIndexWithNaN })).map((index) => {\n        if (index > maxIndex || index < minIndex)\n            return Number.NaN;\n        else\n            return indexToFloat(index);\n    }, (value) => {\n        if (typeof value !== 'number')\n            throw new Error('Unsupported type');\n        if (Number.isNaN(value))\n            return maxIndex !== maxIndexWithNaN ? maxIndexWithNaN : minIndexWithNaN;\n        return floatToIndex(value);\n    }));\n}\n"]},"metadata":{},"sourceType":"module"}