{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:storage:allocate\");\n\nconst Compiler = __importStar(require(\"../../compiler\"));\n\nconst Common = __importStar(require(\"../../common\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst Ast = __importStar(require(\"../../ast\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst lodash_partition_1 = __importDefault(require(\"lodash.partition\"));\n\nclass UnknownBaseContractIdError extends Error {\n  constructor(derivedId, derivedName, derivedKind, baseId) {\n    const message = `Cannot locate base contract ID ${baseId} of ${derivedKind} ${derivedName} (ID ${derivedId})`;\n    super(message);\n    this.name = \"UnknownBaseContractIdError\";\n    this.derivedId = derivedId;\n    this.derivedName = derivedName;\n    this.derivedKind = derivedKind;\n    this.baseId = baseId;\n  }\n\n}\n\nexports.UnknownBaseContractIdError = UnknownBaseContractIdError; //contracts contains only the contracts to be allocated; any base classes not\n//being allocated should just be in referenceDeclarations\n\nfunction getStorageAllocations(userDefinedTypesByCompilation) {\n  let allocations = {};\n\n  for (const compilation of Object.values(userDefinedTypesByCompilation)) {\n    const {\n      compiler,\n      types: userDefinedTypes\n    } = compilation;\n\n    for (const dataType of Object.values(compilation.types)) {\n      if (dataType.typeClass === \"struct\") {\n        try {\n          allocations = allocateStruct(dataType, userDefinedTypes, allocations, compiler);\n        } catch (_a) {//if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n          //note: a better way of handling this would probably be to *mark* it\n          //as failed rather than throwing an exception as that would lead to less\n          //recomputation, but this is simpler and I don't think the recomputation\n          //should really be a problem\n        }\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getStorageAllocations = getStorageAllocations;\n/**\n * This function gets allocations for the state variables of the contracts;\n * this is distinct from getStorageAllocations, which gets allocations for\n * storage structs.\n *\n * While mostly state variables are kept in storage, constant ones are not.\n * And immutable ones, once those are introduced, will be kept in code!\n * (But those don't exist yet so this function doesn't handle them yet.)\n */\n\nfunction getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  let existingAllocations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  let allocations = existingAllocations;\n\n  for (const contractInfo of contracts) {\n    let {\n      contractNode: contract,\n      immutableReferences,\n      compiler,\n      compilationId\n    } = contractInfo;\n\n    try {\n      allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);\n    } catch (_a) {//we're just going to allow failure here and catch the problem elsewhere\n    }\n  }\n\n  return allocations;\n}\n\nexports.getStateAllocations = getStateAllocations;\n\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations, compiler);\n}\n\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations, compiler) {\n  let offset = 0; //will convert to BN when placing in slot\n\n  let index = Evm.Utils.WORD_SIZE - 1; //don't allocate things that have already been allocated\n\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n\n  let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n  //otherwise, we need to allocate\n\n  let memberAllocations = [];\n\n  for (const member of members) {\n    let size;\n    ({\n      size,\n      allocations\n    } = storageSizeAndAllocate(member.type, userDefinedTypes, allocations, compiler)); //if it's sized in words (and we're not at the start of slot) we need to start on a new slot\n    //if it's sized in bytes but there's not enough room, we also need a new slot\n\n    if (Utils.isWordsLength(size) ? index < Evm.Utils.WORD_SIZE - 1 : size.bytes > index + 1) {\n      index = Evm.Utils.WORD_SIZE - 1;\n      offset += 1;\n    } //otherwise, we remain in place\n\n\n    let range;\n\n    if (Utils.isWordsLength(size)) {\n      //words case\n      range = {\n        from: {\n          slot: {\n            offset: new bn_js_1.default(offset) //start at the current slot...\n\n          },\n          index: 0 //...at the beginning of the word.\n\n        },\n        to: {\n          slot: {\n            offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...\n\n          },\n          index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.\n\n        }\n      };\n    } else {\n      //bytes case\n      range = {\n        from: {\n          slot: {\n            offset: new bn_js_1.default(offset) //start at the current slot...\n\n          },\n          index: index - (size.bytes - 1) //...early enough to fit what's being allocated.\n\n        },\n        to: {\n          slot: {\n            offset: new bn_js_1.default(offset) //end at the current slot...\n\n          },\n          index: index //...at the current position.\n\n        }\n      };\n    }\n\n    memberAllocations.push({\n      name: member.name,\n      type: member.type,\n      pointer: {\n        location: \"storage\",\n        range\n      }\n    }); //finally, adjust the current position.\n    //if it was sized in words, move down that many slots and reset position w/in slot\n\n    if (Utils.isWordsLength(size)) {\n      offset += size.words;\n      index = Evm.Utils.WORD_SIZE - 1;\n    } //if it was sized in bytes, move down an appropriate number of bytes.\n    else {\n      index -= size.bytes; //but if this puts us into the next word, move to the next word.\n\n      if (index < 0) {\n        index = Evm.Utils.WORD_SIZE - 1;\n        offset += 1;\n      }\n    }\n  } //finally, let's determine the overall siz; we're dealing with a struct, so\n  //the size is measured in words\n  //it's one plus the last word used, i.e. one plus the current word... unless the\n  //current word remains entirely unused, then it's just the current word\n  //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how\n  //empty structs behave in versions where they're legal)\n\n\n  let totalSize;\n\n  if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {\n    totalSize = {\n      words: offset\n    };\n  } else {\n    totalSize = {\n      words: offset + 1\n    };\n  } //having made our allocation, let's add it to allocations!\n\n\n  allocations[parentId] = {\n    members: memberAllocations,\n    size: totalSize\n  }; //...and we're done!\n\n  return allocations;\n}\n\nfunction getStateVariables(contractNode) {\n  // process for state variables\n  return contractNode.nodes.filter(node => node.nodeType === \"VariableDeclaration\" && node.stateVariable);\n}\n\nfunction allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations) {\n  let existingAllocations = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n  //we're going to do a 2-deep clone here\n  let allocations = Object.assign({}, ...Object.entries(existingAllocations).map(_ref => {\n    let [compilationId, compilationAllocations] = _ref;\n    return {\n      [compilationId]: Object.assign({}, compilationAllocations)\n    };\n  }));\n\n  if (!immutableReferences) {\n    immutableReferences = {}; //also, let's set this up for convenience\n  } //base contracts are listed from most derived to most base, so we\n  //have to reverse before processing, but reverse() is in place, so we\n  //clone with slice first\n\n\n  let linearizedBaseContractsFromBase = contract.linearizedBaseContracts.slice().reverse(); //first, let's get all the variables under consideration\n\n  let variables = [].concat(...linearizedBaseContractsFromBase.map(id => {\n    let baseNode = referenceDeclarations[id];\n\n    if (baseNode === undefined) {\n      throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);\n    }\n\n    return getStateVariables(baseNode).map(definition => ({\n      definition,\n      definedIn: baseNode\n    }));\n  })); //just in case the constant field ever gets removed\n\n  const isConstant = definition => definition.constant || definition.mutability === \"constant\"; //now: we split the variables into storage, constant, and code\n\n\n  let [constantVariables, variableVariables] = lodash_partition_1.default(variables, variable => isConstant(variable.definition)); //why use this function instead of just checking\n  //definition.mutability?\n  //because of a bug in Solidity 0.6.5 that causes the mutability field\n  //not to exist.  So, we also have to check against immutableReferences.\n\n  const isImmutable = definition => definition.mutability === \"immutable\" || definition.id.toString() in immutableReferences;\n\n  let [immutableVariables, storageVariables] = lodash_partition_1.default(variableVariables, variable => isImmutable(variable.definition)); //transform storage variables into data types\n\n  const storageVariableTypes = storageVariables.map(variable => ({\n    name: variable.definition.name,\n    type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)\n  })); //let's allocate the storage variables using a fictitious ID\n\n  const id = \"-1\";\n  const storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations, compiler)[id]; //transform to new format\n\n  const storageVariableAllocations = storageVariables.map((_ref2, index) => {\n    let {\n      definition,\n      definedIn\n    } = _ref2;\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer: storageVariableStorageAllocations.members[index].pointer\n    };\n  }); //now let's create allocations for the immutables\n\n  let immutableVariableAllocations = immutableVariables.map(_ref3 => {\n    let {\n      definition,\n      definedIn\n    } = _ref3;\n    let references = immutableReferences[definition.id.toString()] || [];\n    let pointer;\n\n    if (references.length === 0) {\n      pointer = {\n        location: \"nowhere\"\n      };\n    } else {\n      pointer = {\n        location: \"code\",\n        start: references[0].start,\n        length: references[0].length\n      };\n    }\n\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer\n    };\n  }); //and let's create allocations for the constants\n\n  let constantVariableAllocations = constantVariables.map(_ref4 => {\n    let {\n      definition,\n      definedIn\n    } = _ref4;\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer: {\n        location: \"definition\",\n        definition: definition.value\n      }\n    };\n  }); //now, reweave the three together\n\n  let contractAllocation = [];\n\n  for (let variable of variables) {\n    let arrayToGrabFrom = isConstant(variable.definition) ? constantVariableAllocations : isImmutable(variable.definition) ? immutableVariableAllocations : storageVariableAllocations;\n    contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n  } //finally, set things and return\n\n\n  if (!allocations[compilationId]) {\n    allocations[compilationId] = {};\n  }\n\n  allocations[compilationId][contract.id] = {\n    members: contractAllocation\n  };\n  return allocations;\n} //NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.\n//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,\n//not to the wrapper, because it may need the allocations returned.\n\n\nfunction storageSize(dataType, userDefinedTypes, allocations, compiler) {\n  return storageSizeAndAllocate(dataType, userDefinedTypes, allocations, compiler).size;\n}\n\nexports.storageSize = storageSize;\n\nfunction storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //we'll only directly handle reference types here;\n  //direct types will be handled by dispatching to Basic.Allocate.byteLength\n  //in the default case\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      {\n        switch (dataType.kind) {\n          case \"static\":\n            //really a basic type :)\n            return {\n              size: {\n                bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n              },\n              allocations: existingAllocations\n            };\n\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n        }\n      }\n\n    case \"string\":\n    case \"mapping\":\n      return {\n        size: {\n          words: 1\n        },\n        allocations: existingAllocations\n      };\n\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n\n          case \"static\":\n            //static array case\n            const length = dataType.length.toNumber(); //warning! but if it's too big we have a problem\n\n            if (length === 0) {\n              //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word\n              return {\n                size: {\n                  words: 1\n                },\n                allocations: existingAllocations\n              };\n            }\n\n            let {\n              size: baseSize,\n              allocations\n            } = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n\n            if (!Utils.isWordsLength(baseSize)) {\n              //bytes case\n              const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n              debug(\"length %o\", length);\n              const numWords = Math.ceil(length / perWord);\n              return {\n                size: {\n                  words: numWords\n                },\n                allocations\n              };\n            } else {\n              //words case\n              return {\n                size: {\n                  words: baseSize.words * length\n                },\n                allocations\n              };\n            }\n\n        }\n      }\n\n    case \"struct\":\n      {\n        let allocations = existingAllocations;\n        let allocation = allocations[dataType.id]; //may be undefined!\n\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          const storedType = userDefinedTypes[dataType.id];\n\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n\n          allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = allocations[dataType.id];\n        } //having found our allocation, we can just look up its size\n\n\n        return {\n          size: allocation.size,\n          allocations\n        };\n      }\n\n    case \"userDefinedValueType\":\n      if (Compiler.Utils.solidityFamily(compiler) === \"0.8.7+\") {\n        //UDVTs were introduced in Solidity 0.8.8.  However, in that version,\n        //and that version only, they have a bug where they always take up a\n        //full word in storage regardless of the size of the underlying type.\n        return {\n          size: {\n            words: 1\n          },\n          allocations: existingAllocations\n        };\n      }\n\n    //otherwise, treat them normally\n    //DELIBERATE FALL-TRHOUGH\n\n    default:\n      //otherwise, it's a direct type\n      return {\n        size: {\n          bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n        },\n        allocations: existingAllocations\n      };\n  }\n}","map":{"version":3,"sources":["../../../../lib/storage/allocate/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:storage:allocate\");\nconst Compiler = __importStar(require(\"../../compiler\"));\nconst Common = __importStar(require(\"../../common\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Utils = __importStar(require(\"../utils\"));\nconst Ast = __importStar(require(\"../../ast\"));\nconst Evm = __importStar(require(\"../../evm\"));\nconst Format = __importStar(require(\"../../format\"));\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst lodash_partition_1 = __importDefault(require(\"lodash.partition\"));\nclass UnknownBaseContractIdError extends Error {\n    constructor(derivedId, derivedName, derivedKind, baseId) {\n        const message = `Cannot locate base contract ID ${baseId} of ${derivedKind} ${derivedName} (ID ${derivedId})`;\n        super(message);\n        this.name = \"UnknownBaseContractIdError\";\n        this.derivedId = derivedId;\n        this.derivedName = derivedName;\n        this.derivedKind = derivedKind;\n        this.baseId = baseId;\n    }\n}\nexports.UnknownBaseContractIdError = UnknownBaseContractIdError;\n//contracts contains only the contracts to be allocated; any base classes not\n//being allocated should just be in referenceDeclarations\nfunction getStorageAllocations(userDefinedTypesByCompilation) {\n    let allocations = {};\n    for (const compilation of Object.values(userDefinedTypesByCompilation)) {\n        const { compiler, types: userDefinedTypes } = compilation;\n        for (const dataType of Object.values(compilation.types)) {\n            if (dataType.typeClass === \"struct\") {\n                try {\n                    allocations = allocateStruct(dataType, userDefinedTypes, allocations, compiler);\n                }\n                catch (_a) {\n                    //if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n                    //note: a better way of handling this would probably be to *mark* it\n                    //as failed rather than throwing an exception as that would lead to less\n                    //recomputation, but this is simpler and I don't think the recomputation\n                    //should really be a problem\n                }\n            }\n        }\n    }\n    return allocations;\n}\nexports.getStorageAllocations = getStorageAllocations;\n/**\n * This function gets allocations for the state variables of the contracts;\n * this is distinct from getStorageAllocations, which gets allocations for\n * storage structs.\n *\n * While mostly state variables are kept in storage, constant ones are not.\n * And immutable ones, once those are introduced, will be kept in code!\n * (But those don't exist yet so this function doesn't handle them yet.)\n */\nfunction getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations, existingAllocations = {}) {\n    let allocations = existingAllocations;\n    for (const contractInfo of contracts) {\n        let { contractNode: contract, immutableReferences, compiler, compilationId } = contractInfo;\n        try {\n            allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);\n        }\n        catch (_a) {\n            //we're just going to allow failure here and catch the problem elsewhere\n        }\n    }\n    return allocations;\n}\nexports.getStateAllocations = getStateAllocations;\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations, compiler) {\n    //NOTE: dataType here should be a *stored* type!\n    //it is up to the caller to take care of this\n    return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations, compiler);\n}\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations, compiler) {\n    let offset = 0; //will convert to BN when placing in slot\n    let index = Evm.Utils.WORD_SIZE - 1;\n    //don't allocate things that have already been allocated\n    if (parentId in existingAllocations) {\n        return existingAllocations;\n    }\n    let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n    //otherwise, we need to allocate\n    let memberAllocations = [];\n    for (const member of members) {\n        let size;\n        ({ size, allocations } = storageSizeAndAllocate(member.type, userDefinedTypes, allocations, compiler));\n        //if it's sized in words (and we're not at the start of slot) we need to start on a new slot\n        //if it's sized in bytes but there's not enough room, we also need a new slot\n        if (Utils.isWordsLength(size)\n            ? index < Evm.Utils.WORD_SIZE - 1\n            : size.bytes > index + 1) {\n            index = Evm.Utils.WORD_SIZE - 1;\n            offset += 1;\n        }\n        //otherwise, we remain in place\n        let range;\n        if (Utils.isWordsLength(size)) {\n            //words case\n            range = {\n                from: {\n                    slot: {\n                        offset: new bn_js_1.default(offset) //start at the current slot...\n                    },\n                    index: 0 //...at the beginning of the word.\n                },\n                to: {\n                    slot: {\n                        offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...\n                    },\n                    index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.\n                }\n            };\n        }\n        else {\n            //bytes case\n            range = {\n                from: {\n                    slot: {\n                        offset: new bn_js_1.default(offset) //start at the current slot...\n                    },\n                    index: index - (size.bytes - 1) //...early enough to fit what's being allocated.\n                },\n                to: {\n                    slot: {\n                        offset: new bn_js_1.default(offset) //end at the current slot...\n                    },\n                    index: index //...at the current position.\n                }\n            };\n        }\n        memberAllocations.push({\n            name: member.name,\n            type: member.type,\n            pointer: {\n                location: \"storage\",\n                range\n            }\n        });\n        //finally, adjust the current position.\n        //if it was sized in words, move down that many slots and reset position w/in slot\n        if (Utils.isWordsLength(size)) {\n            offset += size.words;\n            index = Evm.Utils.WORD_SIZE - 1;\n        }\n        //if it was sized in bytes, move down an appropriate number of bytes.\n        else {\n            index -= size.bytes;\n            //but if this puts us into the next word, move to the next word.\n            if (index < 0) {\n                index = Evm.Utils.WORD_SIZE - 1;\n                offset += 1;\n            }\n        }\n    }\n    //finally, let's determine the overall siz; we're dealing with a struct, so\n    //the size is measured in words\n    //it's one plus the last word used, i.e. one plus the current word... unless the\n    //current word remains entirely unused, then it's just the current word\n    //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how\n    //empty structs behave in versions where they're legal)\n    let totalSize;\n    if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {\n        totalSize = { words: offset };\n    }\n    else {\n        totalSize = { words: offset + 1 };\n    }\n    //having made our allocation, let's add it to allocations!\n    allocations[parentId] = {\n        members: memberAllocations,\n        size: totalSize\n    };\n    //...and we're done!\n    return allocations;\n}\nfunction getStateVariables(contractNode) {\n    // process for state variables\n    return contractNode.nodes.filter((node) => node.nodeType === \"VariableDeclaration\" && node.stateVariable);\n}\nfunction allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations, existingAllocations = {}) {\n    //we're going to do a 2-deep clone here\n    let allocations = Object.assign({}, ...Object.entries(existingAllocations).map(([compilationId, compilationAllocations]) => ({\n        [compilationId]: Object.assign({}, compilationAllocations)\n    })));\n    if (!immutableReferences) {\n        immutableReferences = {}; //also, let's set this up for convenience\n    }\n    //base contracts are listed from most derived to most base, so we\n    //have to reverse before processing, but reverse() is in place, so we\n    //clone with slice first\n    let linearizedBaseContractsFromBase = contract.linearizedBaseContracts\n        .slice()\n        .reverse();\n    //first, let's get all the variables under consideration\n    let variables = [].concat(...linearizedBaseContractsFromBase.map((id) => {\n        let baseNode = referenceDeclarations[id];\n        if (baseNode === undefined) {\n            throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);\n        }\n        return getStateVariables(baseNode).map(definition => ({\n            definition,\n            definedIn: baseNode\n        }));\n    }));\n    //just in case the constant field ever gets removed\n    const isConstant = (definition) => definition.constant || definition.mutability === \"constant\";\n    //now: we split the variables into storage, constant, and code\n    let [constantVariables, variableVariables] = lodash_partition_1.default(variables, variable => isConstant(variable.definition));\n    //why use this function instead of just checking\n    //definition.mutability?\n    //because of a bug in Solidity 0.6.5 that causes the mutability field\n    //not to exist.  So, we also have to check against immutableReferences.\n    const isImmutable = (definition) => definition.mutability === \"immutable\" ||\n        definition.id.toString() in immutableReferences;\n    let [immutableVariables, storageVariables] = lodash_partition_1.default(variableVariables, variable => isImmutable(variable.definition));\n    //transform storage variables into data types\n    const storageVariableTypes = storageVariables.map(variable => ({\n        name: variable.definition.name,\n        type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)\n    }));\n    //let's allocate the storage variables using a fictitious ID\n    const id = \"-1\";\n    const storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations, compiler)[id];\n    //transform to new format\n    const storageVariableAllocations = storageVariables.map(({ definition, definedIn }, index) => ({\n        definition,\n        definedIn,\n        compilationId,\n        pointer: storageVariableStorageAllocations.members[index].pointer\n    }));\n    //now let's create allocations for the immutables\n    let immutableVariableAllocations = immutableVariables.map(({ definition, definedIn }) => {\n        let references = immutableReferences[definition.id.toString()] || [];\n        let pointer;\n        if (references.length === 0) {\n            pointer = {\n                location: \"nowhere\"\n            };\n        }\n        else {\n            pointer = {\n                location: \"code\",\n                start: references[0].start,\n                length: references[0].length\n            };\n        }\n        return {\n            definition,\n            definedIn,\n            compilationId,\n            pointer\n        };\n    });\n    //and let's create allocations for the constants\n    let constantVariableAllocations = constantVariables.map(({ definition, definedIn }) => ({\n        definition,\n        definedIn,\n        compilationId,\n        pointer: {\n            location: \"definition\",\n            definition: definition.value\n        }\n    }));\n    //now, reweave the three together\n    let contractAllocation = [];\n    for (let variable of variables) {\n        let arrayToGrabFrom = isConstant(variable.definition)\n            ? constantVariableAllocations\n            : isImmutable(variable.definition)\n                ? immutableVariableAllocations\n                : storageVariableAllocations;\n        contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n    }\n    //finally, set things and return\n    if (!allocations[compilationId]) {\n        allocations[compilationId] = {};\n    }\n    allocations[compilationId][contract.id] = {\n        members: contractAllocation\n    };\n    return allocations;\n}\n//NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.\n//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,\n//not to the wrapper, because it may need the allocations returned.\nfunction storageSize(dataType, userDefinedTypes, allocations, compiler) {\n    return storageSizeAndAllocate(dataType, userDefinedTypes, allocations, compiler).size;\n}\nexports.storageSize = storageSize;\nfunction storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations, compiler) {\n    //we'll only directly handle reference types here;\n    //direct types will be handled by dispatching to Basic.Allocate.byteLength\n    //in the default case\n    switch (dataType.typeClass) {\n        case \"bytes\": {\n            switch (dataType.kind) {\n                case \"static\":\n                    //really a basic type :)\n                    return {\n                        size: {\n                            bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n                        },\n                        allocations: existingAllocations\n                    };\n                case \"dynamic\":\n                    return {\n                        size: { words: 1 },\n                        allocations: existingAllocations\n                    };\n            }\n        }\n        case \"string\":\n        case \"mapping\":\n            return {\n                size: { words: 1 },\n                allocations: existingAllocations\n            };\n        case \"array\": {\n            switch (dataType.kind) {\n                case \"dynamic\":\n                    return {\n                        size: { words: 1 },\n                        allocations: existingAllocations\n                    };\n                case \"static\":\n                    //static array case\n                    const length = dataType.length.toNumber(); //warning! but if it's too big we have a problem\n                    if (length === 0) {\n                        //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word\n                        return {\n                            size: { words: 1 },\n                            allocations: existingAllocations\n                        };\n                    }\n                    let { size: baseSize, allocations } = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);\n                    if (!Utils.isWordsLength(baseSize)) {\n                        //bytes case\n                        const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n                        debug(\"length %o\", length);\n                        const numWords = Math.ceil(length / perWord);\n                        return {\n                            size: { words: numWords },\n                            allocations\n                        };\n                    }\n                    else {\n                        //words case\n                        return {\n                            size: { words: baseSize.words * length },\n                            allocations\n                        };\n                    }\n            }\n        }\n        case \"struct\": {\n            let allocations = existingAllocations;\n            let allocation = allocations[dataType.id]; //may be undefined!\n            if (allocation === undefined) {\n                //if we don't find an allocation, we'll have to do the allocation ourselves\n                const storedType = (userDefinedTypes[dataType.id]);\n                if (!storedType) {\n                    throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n                }\n                allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n                allocation = allocations[dataType.id];\n            }\n            //having found our allocation, we can just look up its size\n            return {\n                size: allocation.size,\n                allocations\n            };\n        }\n        case \"userDefinedValueType\":\n            if (Compiler.Utils.solidityFamily(compiler) === \"0.8.7+\") {\n                //UDVTs were introduced in Solidity 0.8.8.  However, in that version,\n                //and that version only, they have a bug where they always take up a\n                //full word in storage regardless of the size of the underlying type.\n                return {\n                    size: { words: 1 },\n                    allocations: existingAllocations\n                };\n            }\n        //otherwise, treat them normally\n        //DELIBERATE FALL-TRHOUGH\n        default:\n            //otherwise, it's a direct type\n            return {\n                size: {\n                    bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n                },\n                allocations: existingAllocations\n            };\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}