{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeConstant = void 0;\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:ast:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeConstant(dataType, pointer, info) {\n  debug(\"pointer %o\", pointer); //normally, we just dispatch to decodeBasic or decodeBytes.\n  //for statically-sized bytes, however, we need to make a special case.\n  //you see, decodeBasic expects to find the bytes at the *beginning*\n  //of the word, but readDefinition will put them at the *end* of the\n  //word.  So we'll have to adjust things ourselves.\n  //(if the constant is a string constant, it'll be *just* the bytes, so\n  //we have to pad it...)\n\n  if (dataType.typeClass === \"bytes\" && dataType.kind === \"static\") {\n    const size = dataType.length;\n    let word;\n\n    try {\n      word = yield* read_1.default(pointer, info.state);\n    } catch (error) {\n      return errors_1.handleDecodingError(dataType, error);\n    }\n\n    debug(\"got word: %O\", word); //not bothering to check padding; shouldn't be necessary\n\n    const bytes = word.slice(-size); //isolate the bytes we want (works in both cases, even if string literal is short)\n\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        asHex: Conversion.toHexString(bytes, size, true) //padding in case of short string literal\n\n      }\n    }; //we'll skip including a raw value, as that would be meaningless\n  } //otherwise, as mentioned, just dispatch to decodeBasic or decodeBytes\n\n\n  debug(\"not a static bytes\");\n\n  if (dataType.typeClass === \"bytes\" || dataType.typeClass === \"string\") {\n    return yield* Bytes.Decode.decodeBytes(dataType, pointer, info);\n  }\n\n  return yield* Basic.Decode.decodeBasic(dataType, pointer, info);\n}\n\nexports.decodeConstant = decodeConstant;","map":{"version":3,"sources":["../../../../lib/ast-constant/decode/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;AAIG;;AACH,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AACA,MAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,kBAAZ,CAAd;;AAEA,MAAA,MAAA,GAAA,eAAA,CAAA,OAAA,CAAA,YAAA,CAAA,CAAA;;AACA,MAAA,UAAA,GAAA,YAAA,CAAA,OAAA,CAAA,kBAAA,CAAA,CAAA;;AAGA,MAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AACA,MAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,aAAA,CAAA,CAAA;;AAGA,MAAA,QAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAEA,UAAiB,cAAjB,CACE,QADF,EAEE,OAFF,EAGE,IAHF,EAGmB;AAEjB,EAAA,KAAK,CAAC,YAAD,EAAe,OAAf,CAAL,CAFiB,CAIjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAI,QAAQ,CAAC,SAAT,KAAuB,OAAvB,IAAkC,QAAQ,CAAC,IAAT,KAAkB,QAAxD,EAAkE;AAChE,UAAM,IAAI,GAAG,QAAQ,CAAC,MAAtB;AACA,QAAI,IAAJ;;AACA,QAAI;AACF,MAAA,IAAI,GAAG,OAAO,MAAA,CAAA,OAAA,CAAK,OAAL,EAAc,IAAI,CAAC,KAAnB,CAAd;AACD,KAFD,CAEE,OAAO,KAAP,EAAc;AACd,aAAO,QAAA,CAAA,mBAAA,CAAoB,QAApB,EAA8B,KAA9B,CAAP;AACD;;AACD,IAAA,KAAK,CAAC,cAAD,EAAiB,IAAjB,CAAL,CARgE,CAShE;;AACA,UAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,IAAZ,CAAd,CAVgE,CAU/B;;AACjC,WAAO;AACL,MAAA,IAAI,EAAE,QADD;AAEL,MAAA,IAAI,EAAE,OAFD;AAGL,MAAA,KAAK,EAAE;AACL,QAAA,KAAK,EAAE,UAAU,CAAC,WAAX,CAAuB,KAAvB,EAA8B,IAA9B,EAAoC,IAApC,CADF,CAC4C;;AAD5C;AAHF,KAAP,CAXgE,CAiB7D;AACJ,GA9BgB,CAgCjB;;;AACA,EAAA,KAAK,CAAC,oBAAD,CAAL;;AACA,MAAI,QAAQ,CAAC,SAAT,KAAuB,OAAvB,IAAkC,QAAQ,CAAC,SAAT,KAAuB,QAA7D,EAAuE;AACrE,WAAO,OAAO,KAAK,CAAC,MAAN,CAAa,WAAb,CAAyB,QAAzB,EAAmC,OAAnC,EAA4C,IAA5C,CAAd;AACD;;AACD,SAAO,OAAO,KAAK,CAAC,MAAN,CAAa,WAAb,CAAyB,QAAzB,EAAmC,OAAnC,EAA4C,IAA5C,CAAd;AACD;;AAzCD,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeConstant = void 0;\n/**\n * @protected\n *\n * @packageDocumentation\n */\nconst debug_1 = __importDefault(require(\"debug\"));\nconst debug = debug_1.default(\"codec:ast:decode\");\nconst read_1 = __importDefault(require(\"../../read\"));\nconst Conversion = __importStar(require(\"../../conversion\"));\nconst Basic = __importStar(require(\"../../basic\"));\nconst Bytes = __importStar(require(\"../../bytes\"));\nconst errors_1 = require(\"../../errors\");\nfunction* decodeConstant(dataType, pointer, info) {\n    debug(\"pointer %o\", pointer);\n    //normally, we just dispatch to decodeBasic or decodeBytes.\n    //for statically-sized bytes, however, we need to make a special case.\n    //you see, decodeBasic expects to find the bytes at the *beginning*\n    //of the word, but readDefinition will put them at the *end* of the\n    //word.  So we'll have to adjust things ourselves.\n    //(if the constant is a string constant, it'll be *just* the bytes, so\n    //we have to pad it...)\n    if (dataType.typeClass === \"bytes\" && dataType.kind === \"static\") {\n        const size = dataType.length;\n        let word;\n        try {\n            word = yield* read_1.default(pointer, info.state);\n        }\n        catch (error) {\n            return errors_1.handleDecodingError(dataType, error);\n        }\n        debug(\"got word: %O\", word);\n        //not bothering to check padding; shouldn't be necessary\n        const bytes = word.slice(-size); //isolate the bytes we want (works in both cases, even if string literal is short)\n        return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n                asHex: Conversion.toHexString(bytes, size, true) //padding in case of short string literal\n            }\n        }; //we'll skip including a raw value, as that would be meaningless\n    }\n    //otherwise, as mentioned, just dispatch to decodeBasic or decodeBytes\n    debug(\"not a static bytes\");\n    if (dataType.typeClass === \"bytes\" || dataType.typeClass === \"string\") {\n        return yield* Bytes.Decode.decodeBytes(dataType, pointer, info);\n    }\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info);\n}\nexports.decodeConstant = decodeConstant;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}