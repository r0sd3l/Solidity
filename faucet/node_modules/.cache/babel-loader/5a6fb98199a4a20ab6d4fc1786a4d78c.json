{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forBytecode = exports.forContract = void 0;\n\nfunction forContract(contract) {\n  const {\n    contractName,\n    sourcePath,\n    source,\n    sourceMap,\n    deployedSourceMap,\n    legacyAST,\n    ast,\n    abi,\n    metadata,\n    bytecode,\n    deployedBytecode,\n    compiler,\n    devdoc,\n    userdoc,\n    immutableReferences,\n    generatedSources,\n    deployedGeneratedSources,\n    db\n  } = contract;\n  return {\n    contract_name: contractName,\n    sourcePath,\n    source,\n    sourceMap,\n    deployedSourceMap,\n    legacyAST,\n    ast,\n    abi,\n    metadata,\n    bytecode: forBytecode(bytecode),\n    deployedBytecode: forBytecode(deployedBytecode),\n    unlinked_binary: forBytecode(bytecode),\n    compiler,\n    devdoc,\n    userdoc,\n    immutableReferences,\n    generatedSources,\n    deployedGeneratedSources,\n    db\n  };\n}\n\nexports.forContract = forContract;\n\nfunction forBytecode(bytecode) {\n  if (!bytecode) {\n    return bytecode;\n  }\n\n  if (typeof bytecode === \"string\") {\n    return bytecode;\n  }\n\n  let {\n    bytes,\n    linkReferences\n  } = bytecode;\n  linkReferences = linkReferences || []; // inline link references - start by flattening the offsets\n\n  const flattenedLinkReferences = linkReferences // map each link ref to array of link refs with only one offset\n  .map(_ref => {\n    let {\n      offsets,\n      length,\n      name\n    } = _ref;\n    return offsets.map(offset => ({\n      offset,\n      length,\n      name\n    }));\n  }) // flatten\n  .reduce((a, b) => [...a, ...b], []); // then overwite bytes with link reference\n\n  bytes = flattenedLinkReferences.reduce((bytes, _ref2) => {\n    let {\n      offset,\n      name,\n      length\n    } = _ref2;\n    // length is a byte offset\n    const characterLength = length * 2;\n    let linkId = `__${name.slice(0, characterLength - 2)}`;\n\n    while (linkId.length < characterLength) {\n      linkId += \"_\";\n    }\n\n    const start = offset * 2;\n    return `${bytes.substring(0, start)}${linkId}${bytes.substring(start + characterLength)}`;\n  }, bytes);\n  return `0x${bytes}`;\n}\n\nexports.forBytecode = forBytecode;","map":{"version":3,"sources":["../../../src/shims/NewToLegacy.ts"],"names":[],"mappings":";;;;;;;AAEA,SAAgB,WAAhB,CAA4B,QAA5B,EAAsD;AACpD,QAAM;AACJ,IAAA,YADI;AAEJ,IAAA,UAFI;AAGJ,IAAA,MAHI;AAIJ,IAAA,SAJI;AAKJ,IAAA,iBALI;AAMJ,IAAA,SANI;AAOJ,IAAA,GAPI;AAQJ,IAAA,GARI;AASJ,IAAA,QATI;AAUJ,IAAA,QAVI;AAWJ,IAAA,gBAXI;AAYJ,IAAA,QAZI;AAaJ,IAAA,MAbI;AAcJ,IAAA,OAdI;AAeJ,IAAA,mBAfI;AAgBJ,IAAA,gBAhBI;AAiBJ,IAAA,wBAjBI;AAkBJ,IAAA;AAlBI,MAmBF,QAnBJ;AAqBA,SAAO;AACL,IAAA,aAAa,EAAE,YADV;AAEL,IAAA,UAFK;AAGL,IAAA,MAHK;AAIL,IAAA,SAJK;AAKL,IAAA,iBALK;AAML,IAAA,SANK;AAOL,IAAA,GAPK;AAQL,IAAA,GARK;AASL,IAAA,QATK;AAUL,IAAA,QAAQ,EAAE,WAAW,CAAC,QAAD,CAVhB;AAWL,IAAA,gBAAgB,EAAE,WAAW,CAAC,gBAAD,CAXxB;AAYL,IAAA,eAAe,EAAE,WAAW,CAAC,QAAD,CAZvB;AAaL,IAAA,QAbK;AAcL,IAAA,MAdK;AAeL,IAAA,OAfK;AAgBL,IAAA,mBAhBK;AAiBL,IAAA,gBAjBK;AAkBL,IAAA,wBAlBK;AAmBL,IAAA;AAnBK,GAAP;AAqBD;;AA3CD,OAAA,CAAA,WAAA,GAAA,WAAA;;AA6CA,SAAgB,WAAhB,CAA4B,QAA5B,EAAyC;AACvC,MAAI,CAAC,QAAL,EAAe;AACb,WAAO,QAAP;AACD;;AACD,MAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,WAAO,QAAP;AACD;;AAED,MAAI;AAAE,IAAA,KAAF;AAAS,IAAA;AAAT,MAA4B,QAAhC;AAEA,EAAA,cAAc,GAAG,cAAc,IAAI,EAAnC,CAVuC,CAYvC;;AACA,QAAM,uBAAuB,GAAG,cAAc,CAC5C;AAD4C,GAE3C,GAF6B,CAEzB;AAAA,QAAC;AAAE,MAAA,OAAF;AAAW,MAAA,MAAX;AAAmB,MAAA;AAAnB,KAAD;AAAA,WACH,OAAO,CAAC,GAAR,CAAY,MAAM,KAAK;AAAE,MAAA,MAAF;AAAU,MAAA,MAAV;AAAkB,MAAA;AAAlB,KAAL,CAAlB,CADG;AAAA,GAFyB,EAK9B;AAL8B,GAM7B,MAN6B,CAMtB,CAAC,CAAD,EAAc,CAAd,KAA8B,CAAC,GAAG,CAAJ,EAAO,GAAG,CAAV,CANR,EAMsB,EANtB,CAAhC,CAbuC,CAqBvC;;AACA,EAAA,KAAK,GAAG,uBAAuB,CAAC,MAAxB,CACN,CACE,KADF,YAGI;AAAA,QADF;AAAE,MAAA,MAAF;AAAU,MAAA,IAAV;AAAgB,MAAA;AAAhB,KACE;AACF;AACA,UAAM,eAAe,GAAG,MAAM,GAAG,CAAjC;AAEA,QAAI,MAAM,GAAG,KAAK,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,eAAe,GAAG,CAAhC,CAAkC,EAApD;;AACA,WAAO,MAAM,CAAC,MAAP,GAAgB,eAAvB,EAAwC;AACtC,MAAA,MAAM,IAAI,GAAV;AACD;;AAED,UAAM,KAAK,GAAG,MAAM,GAAG,CAAvB;AAEA,WAAO,GAAG,KAAK,CAAC,SAAN,CAAgB,CAAhB,EAAmB,KAAnB,CAAyB,GAAG,MAAM,GAAG,KAAK,CAAC,SAAN,CAC7C,KAAK,GAAG,eADqC,CAE9C,EAFD;AAGD,GAlBK,EAmBN,KAnBM,CAAR;AAsBA,SAAO,KAAK,KAAK,EAAjB;AACD;;AA7CD,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.forBytecode = exports.forContract = void 0;\nfunction forContract(contract) {\n    const { contractName, sourcePath, source, sourceMap, deployedSourceMap, legacyAST, ast, abi, metadata, bytecode, deployedBytecode, compiler, devdoc, userdoc, immutableReferences, generatedSources, deployedGeneratedSources, db } = contract;\n    return {\n        contract_name: contractName,\n        sourcePath,\n        source,\n        sourceMap,\n        deployedSourceMap,\n        legacyAST,\n        ast,\n        abi,\n        metadata,\n        bytecode: forBytecode(bytecode),\n        deployedBytecode: forBytecode(deployedBytecode),\n        unlinked_binary: forBytecode(bytecode),\n        compiler,\n        devdoc,\n        userdoc,\n        immutableReferences,\n        generatedSources,\n        deployedGeneratedSources,\n        db\n    };\n}\nexports.forContract = forContract;\nfunction forBytecode(bytecode) {\n    if (!bytecode) {\n        return bytecode;\n    }\n    if (typeof bytecode === \"string\") {\n        return bytecode;\n    }\n    let { bytes, linkReferences } = bytecode;\n    linkReferences = linkReferences || [];\n    // inline link references - start by flattening the offsets\n    const flattenedLinkReferences = linkReferences\n        // map each link ref to array of link refs with only one offset\n        .map(({ offsets, length, name }) => offsets.map(offset => ({ offset, length, name })))\n        // flatten\n        .reduce((a, b) => [...a, ...b], []);\n    // then overwite bytes with link reference\n    bytes = flattenedLinkReferences.reduce((bytes, { offset, name, length }) => {\n        // length is a byte offset\n        const characterLength = length * 2;\n        let linkId = `__${name.slice(0, characterLength - 2)}`;\n        while (linkId.length < characterLength) {\n            linkId += \"_\";\n        }\n        const start = offset * 2;\n        return `${bytes.substring(0, start)}${linkId}${bytes.substring(start + characterLength)}`;\n    }, bytes);\n    return `0x${bytes}`;\n}\nexports.forBytecode = forBytecode;\n//# sourceMappingURL=NewToLegacy.js.map"]},"metadata":{},"sourceType":"script"}